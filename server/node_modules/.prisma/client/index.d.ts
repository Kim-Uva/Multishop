
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Estado
 * 
 */
export type Estado = $Result.DefaultSelection<Prisma.$EstadoPayload>
/**
 * Model Categoria
 * 
 */
export type Categoria = $Result.DefaultSelection<Prisma.$CategoriaPayload>
/**
 * Model SubCategoria
 * 
 */
export type SubCategoria = $Result.DefaultSelection<Prisma.$SubCategoriaPayload>
/**
 * Model Producto
 * 
 */
export type Producto = $Result.DefaultSelection<Prisma.$ProductoPayload>
/**
 * Model Foto
 * 
 */
export type Foto = $Result.DefaultSelection<Prisma.$FotoPayload>
/**
 * Model Ubicacion
 * 
 */
export type Ubicacion = $Result.DefaultSelection<Prisma.$UbicacionPayload>
/**
 * Model Provincia
 * 
 */
export type Provincia = $Result.DefaultSelection<Prisma.$ProvinciaPayload>
/**
 * Model Canton
 * 
 */
export type Canton = $Result.DefaultSelection<Prisma.$CantonPayload>
/**
 * Model Distrito
 * 
 */
export type Distrito = $Result.DefaultSelection<Prisma.$DistritoPayload>
/**
 * Model Barrio
 * 
 */
export type Barrio = $Result.DefaultSelection<Prisma.$BarrioPayload>
/**
 * Model Bodega
 * 
 */
export type Bodega = $Result.DefaultSelection<Prisma.$BodegaPayload>
/**
 * Model BodegaProductos
 * 
 */
export type BodegaProductos = $Result.DefaultSelection<Prisma.$BodegaProductosPayload>
/**
 * Model EncabezadoCompra
 * 
 */
export type EncabezadoCompra = $Result.DefaultSelection<Prisma.$EncabezadoCompraPayload>
/**
 * Model DetalleCompra
 * 
 */
export type DetalleCompra = $Result.DefaultSelection<Prisma.$DetalleCompraPayload>
/**
 * Model Pedido
 * 
 */
export type Pedido = $Result.DefaultSelection<Prisma.$PedidoPayload>
/**
 * Model TrasladoBodegas
 * 
 */
export type TrasladoBodegas = $Result.DefaultSelection<Prisma.$TrasladoBodegasPayload>
/**
 * Model TrasladoDestino
 * 
 */
export type TrasladoDestino = $Result.DefaultSelection<Prisma.$TrasladoDestinoPayload>
/**
 * Model Historial
 * 
 */
export type Historial = $Result.DefaultSelection<Prisma.$HistorialPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  Administrador: 'Administrador',
  Encargado: 'Encargado',
  Proveeedor: 'Proveeedor'
};

export type Rol = (typeof Rol)[keyof typeof Rol]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.estado`: Exposes CRUD operations for the **Estado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estados
    * const estados = await prisma.estado.findMany()
    * ```
    */
  get estado(): Prisma.EstadoDelegate<ExtArgs>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<ExtArgs>;

  /**
   * `prisma.subCategoria`: Exposes CRUD operations for the **SubCategoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategorias
    * const subCategorias = await prisma.subCategoria.findMany()
    * ```
    */
  get subCategoria(): Prisma.SubCategoriaDelegate<ExtArgs>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<ExtArgs>;

  /**
   * `prisma.foto`: Exposes CRUD operations for the **Foto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fotos
    * const fotos = await prisma.foto.findMany()
    * ```
    */
  get foto(): Prisma.FotoDelegate<ExtArgs>;

  /**
   * `prisma.ubicacion`: Exposes CRUD operations for the **Ubicacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ubicacions
    * const ubicacions = await prisma.ubicacion.findMany()
    * ```
    */
  get ubicacion(): Prisma.UbicacionDelegate<ExtArgs>;

  /**
   * `prisma.provincia`: Exposes CRUD operations for the **Provincia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provincias
    * const provincias = await prisma.provincia.findMany()
    * ```
    */
  get provincia(): Prisma.ProvinciaDelegate<ExtArgs>;

  /**
   * `prisma.canton`: Exposes CRUD operations for the **Canton** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cantons
    * const cantons = await prisma.canton.findMany()
    * ```
    */
  get canton(): Prisma.CantonDelegate<ExtArgs>;

  /**
   * `prisma.distrito`: Exposes CRUD operations for the **Distrito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Distritos
    * const distritos = await prisma.distrito.findMany()
    * ```
    */
  get distrito(): Prisma.DistritoDelegate<ExtArgs>;

  /**
   * `prisma.barrio`: Exposes CRUD operations for the **Barrio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Barrios
    * const barrios = await prisma.barrio.findMany()
    * ```
    */
  get barrio(): Prisma.BarrioDelegate<ExtArgs>;

  /**
   * `prisma.bodega`: Exposes CRUD operations for the **Bodega** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bodegas
    * const bodegas = await prisma.bodega.findMany()
    * ```
    */
  get bodega(): Prisma.BodegaDelegate<ExtArgs>;

  /**
   * `prisma.bodegaProductos`: Exposes CRUD operations for the **BodegaProductos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BodegaProductos
    * const bodegaProductos = await prisma.bodegaProductos.findMany()
    * ```
    */
  get bodegaProductos(): Prisma.BodegaProductosDelegate<ExtArgs>;

  /**
   * `prisma.encabezadoCompra`: Exposes CRUD operations for the **EncabezadoCompra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncabezadoCompras
    * const encabezadoCompras = await prisma.encabezadoCompra.findMany()
    * ```
    */
  get encabezadoCompra(): Prisma.EncabezadoCompraDelegate<ExtArgs>;

  /**
   * `prisma.detalleCompra`: Exposes CRUD operations for the **DetalleCompra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetalleCompras
    * const detalleCompras = await prisma.detalleCompra.findMany()
    * ```
    */
  get detalleCompra(): Prisma.DetalleCompraDelegate<ExtArgs>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<ExtArgs>;

  /**
   * `prisma.trasladoBodegas`: Exposes CRUD operations for the **TrasladoBodegas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrasladoBodegases
    * const trasladoBodegases = await prisma.trasladoBodegas.findMany()
    * ```
    */
  get trasladoBodegas(): Prisma.TrasladoBodegasDelegate<ExtArgs>;

  /**
   * `prisma.trasladoDestino`: Exposes CRUD operations for the **TrasladoDestino** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrasladoDestinos
    * const trasladoDestinos = await prisma.trasladoDestino.findMany()
    * ```
    */
  get trasladoDestino(): Prisma.TrasladoDestinoDelegate<ExtArgs>;

  /**
   * `prisma.historial`: Exposes CRUD operations for the **Historial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historials
    * const historials = await prisma.historial.findMany()
    * ```
    */
  get historial(): Prisma.HistorialDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Estado: 'Estado',
    Categoria: 'Categoria',
    SubCategoria: 'SubCategoria',
    Producto: 'Producto',
    Foto: 'Foto',
    Ubicacion: 'Ubicacion',
    Provincia: 'Provincia',
    Canton: 'Canton',
    Distrito: 'Distrito',
    Barrio: 'Barrio',
    Bodega: 'Bodega',
    BodegaProductos: 'BodegaProductos',
    EncabezadoCompra: 'EncabezadoCompra',
    DetalleCompra: 'DetalleCompra',
    Pedido: 'Pedido',
    TrasladoBodegas: 'TrasladoBodegas',
    TrasladoDestino: 'TrasladoDestino',
    Historial: 'Historial'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'usuario' | 'estado' | 'categoria' | 'subCategoria' | 'producto' | 'foto' | 'ubicacion' | 'provincia' | 'canton' | 'distrito' | 'barrio' | 'bodega' | 'bodegaProductos' | 'encabezadoCompra' | 'detalleCompra' | 'pedido' | 'trasladoBodegas' | 'trasladoDestino' | 'historial'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Estado: {
        payload: Prisma.$EstadoPayload<ExtArgs>
        fields: Prisma.EstadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstadoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstadoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          findFirst: {
            args: Prisma.EstadoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstadoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          findMany: {
            args: Prisma.EstadoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>[]
          }
          create: {
            args: Prisma.EstadoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          createMany: {
            args: Prisma.EstadoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EstadoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          update: {
            args: Prisma.EstadoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          deleteMany: {
            args: Prisma.EstadoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EstadoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EstadoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          aggregate: {
            args: Prisma.EstadoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEstado>
          }
          groupBy: {
            args: Prisma.EstadoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EstadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstadoCountArgs<ExtArgs>,
            result: $Utils.Optional<EstadoCountAggregateOutputType> | number
          }
        }
      }
      Categoria: {
        payload: Prisma.$CategoriaPayload<ExtArgs>
        fields: Prisma.CategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findFirst: {
            args: Prisma.CategoriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findMany: {
            args: Prisma.CategoriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          create: {
            args: Prisma.CategoriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          createMany: {
            args: Prisma.CategoriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          update: {
            args: Prisma.CategoriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.CategoriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      SubCategoria: {
        payload: Prisma.$SubCategoriaPayload<ExtArgs>
        fields: Prisma.SubCategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubCategoriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubCategoriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          findFirst: {
            args: Prisma.SubCategoriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubCategoriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          findMany: {
            args: Prisma.SubCategoriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>[]
          }
          create: {
            args: Prisma.SubCategoriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          createMany: {
            args: Prisma.SubCategoriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubCategoriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          update: {
            args: Prisma.SubCategoriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          deleteMany: {
            args: Prisma.SubCategoriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubCategoriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubCategoriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          aggregate: {
            args: Prisma.SubCategoriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubCategoria>
          }
          groupBy: {
            args: Prisma.SubCategoriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubCategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubCategoriaCountArgs<ExtArgs>,
            result: $Utils.Optional<SubCategoriaCountAggregateOutputType> | number
          }
        }
      }
      Producto: {
        payload: Prisma.$ProductoPayload<ExtArgs>
        fields: Prisma.ProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findFirst: {
            args: Prisma.ProductoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findMany: {
            args: Prisma.ProductoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          create: {
            args: Prisma.ProductoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          createMany: {
            args: Prisma.ProductoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          update: {
            args: Prisma.ProductoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          deleteMany: {
            args: Prisma.ProductoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          aggregate: {
            args: Prisma.ProductoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProducto>
          }
          groupBy: {
            args: Prisma.ProductoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductoCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductoCountAggregateOutputType> | number
          }
        }
      }
      Foto: {
        payload: Prisma.$FotoPayload<ExtArgs>
        fields: Prisma.FotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          findFirst: {
            args: Prisma.FotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          findMany: {
            args: Prisma.FotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>[]
          }
          create: {
            args: Prisma.FotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          createMany: {
            args: Prisma.FotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          update: {
            args: Prisma.FotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          deleteMany: {
            args: Prisma.FotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          aggregate: {
            args: Prisma.FotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFoto>
          }
          groupBy: {
            args: Prisma.FotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FotoCountArgs<ExtArgs>,
            result: $Utils.Optional<FotoCountAggregateOutputType> | number
          }
        }
      }
      Ubicacion: {
        payload: Prisma.$UbicacionPayload<ExtArgs>
        fields: Prisma.UbicacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UbicacionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UbicacionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          findFirst: {
            args: Prisma.UbicacionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UbicacionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          findMany: {
            args: Prisma.UbicacionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>[]
          }
          create: {
            args: Prisma.UbicacionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          createMany: {
            args: Prisma.UbicacionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UbicacionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          update: {
            args: Prisma.UbicacionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          deleteMany: {
            args: Prisma.UbicacionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UbicacionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UbicacionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          aggregate: {
            args: Prisma.UbicacionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUbicacion>
          }
          groupBy: {
            args: Prisma.UbicacionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UbicacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UbicacionCountArgs<ExtArgs>,
            result: $Utils.Optional<UbicacionCountAggregateOutputType> | number
          }
        }
      }
      Provincia: {
        payload: Prisma.$ProvinciaPayload<ExtArgs>
        fields: Prisma.ProvinciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvinciaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvinciaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          findFirst: {
            args: Prisma.ProvinciaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvinciaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          findMany: {
            args: Prisma.ProvinciaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>[]
          }
          create: {
            args: Prisma.ProvinciaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          createMany: {
            args: Prisma.ProvinciaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProvinciaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          update: {
            args: Prisma.ProvinciaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          deleteMany: {
            args: Prisma.ProvinciaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProvinciaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProvinciaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          aggregate: {
            args: Prisma.ProvinciaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProvincia>
          }
          groupBy: {
            args: Prisma.ProvinciaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProvinciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvinciaCountArgs<ExtArgs>,
            result: $Utils.Optional<ProvinciaCountAggregateOutputType> | number
          }
        }
      }
      Canton: {
        payload: Prisma.$CantonPayload<ExtArgs>
        fields: Prisma.CantonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CantonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CantonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          findFirst: {
            args: Prisma.CantonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CantonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          findMany: {
            args: Prisma.CantonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>[]
          }
          create: {
            args: Prisma.CantonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          createMany: {
            args: Prisma.CantonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CantonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          update: {
            args: Prisma.CantonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          deleteMany: {
            args: Prisma.CantonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CantonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CantonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          aggregate: {
            args: Prisma.CantonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCanton>
          }
          groupBy: {
            args: Prisma.CantonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CantonGroupByOutputType>[]
          }
          count: {
            args: Prisma.CantonCountArgs<ExtArgs>,
            result: $Utils.Optional<CantonCountAggregateOutputType> | number
          }
        }
      }
      Distrito: {
        payload: Prisma.$DistritoPayload<ExtArgs>
        fields: Prisma.DistritoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistritoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistritoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          findFirst: {
            args: Prisma.DistritoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistritoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          findMany: {
            args: Prisma.DistritoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>[]
          }
          create: {
            args: Prisma.DistritoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          createMany: {
            args: Prisma.DistritoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DistritoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          update: {
            args: Prisma.DistritoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          deleteMany: {
            args: Prisma.DistritoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DistritoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DistritoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          aggregate: {
            args: Prisma.DistritoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDistrito>
          }
          groupBy: {
            args: Prisma.DistritoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DistritoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistritoCountArgs<ExtArgs>,
            result: $Utils.Optional<DistritoCountAggregateOutputType> | number
          }
        }
      }
      Barrio: {
        payload: Prisma.$BarrioPayload<ExtArgs>
        fields: Prisma.BarrioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarrioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarrioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload>
          }
          findFirst: {
            args: Prisma.BarrioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarrioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload>
          }
          findMany: {
            args: Prisma.BarrioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload>[]
          }
          create: {
            args: Prisma.BarrioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload>
          }
          createMany: {
            args: Prisma.BarrioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BarrioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload>
          }
          update: {
            args: Prisma.BarrioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload>
          }
          deleteMany: {
            args: Prisma.BarrioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BarrioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BarrioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BarrioPayload>
          }
          aggregate: {
            args: Prisma.BarrioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBarrio>
          }
          groupBy: {
            args: Prisma.BarrioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BarrioGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarrioCountArgs<ExtArgs>,
            result: $Utils.Optional<BarrioCountAggregateOutputType> | number
          }
        }
      }
      Bodega: {
        payload: Prisma.$BodegaPayload<ExtArgs>
        fields: Prisma.BodegaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BodegaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BodegaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          findFirst: {
            args: Prisma.BodegaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BodegaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          findMany: {
            args: Prisma.BodegaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>[]
          }
          create: {
            args: Prisma.BodegaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          createMany: {
            args: Prisma.BodegaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BodegaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          update: {
            args: Prisma.BodegaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          deleteMany: {
            args: Prisma.BodegaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BodegaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BodegaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          aggregate: {
            args: Prisma.BodegaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBodega>
          }
          groupBy: {
            args: Prisma.BodegaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BodegaGroupByOutputType>[]
          }
          count: {
            args: Prisma.BodegaCountArgs<ExtArgs>,
            result: $Utils.Optional<BodegaCountAggregateOutputType> | number
          }
        }
      }
      BodegaProductos: {
        payload: Prisma.$BodegaProductosPayload<ExtArgs>
        fields: Prisma.BodegaProductosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BodegaProductosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BodegaProductosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload>
          }
          findFirst: {
            args: Prisma.BodegaProductosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BodegaProductosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload>
          }
          findMany: {
            args: Prisma.BodegaProductosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload>[]
          }
          create: {
            args: Prisma.BodegaProductosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload>
          }
          createMany: {
            args: Prisma.BodegaProductosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BodegaProductosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload>
          }
          update: {
            args: Prisma.BodegaProductosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload>
          }
          deleteMany: {
            args: Prisma.BodegaProductosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BodegaProductosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BodegaProductosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaProductosPayload>
          }
          aggregate: {
            args: Prisma.BodegaProductosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBodegaProductos>
          }
          groupBy: {
            args: Prisma.BodegaProductosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BodegaProductosGroupByOutputType>[]
          }
          count: {
            args: Prisma.BodegaProductosCountArgs<ExtArgs>,
            result: $Utils.Optional<BodegaProductosCountAggregateOutputType> | number
          }
        }
      }
      EncabezadoCompra: {
        payload: Prisma.$EncabezadoCompraPayload<ExtArgs>
        fields: Prisma.EncabezadoCompraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncabezadoCompraFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncabezadoCompraFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          findFirst: {
            args: Prisma.EncabezadoCompraFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncabezadoCompraFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          findMany: {
            args: Prisma.EncabezadoCompraFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>[]
          }
          create: {
            args: Prisma.EncabezadoCompraCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          createMany: {
            args: Prisma.EncabezadoCompraCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EncabezadoCompraDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          update: {
            args: Prisma.EncabezadoCompraUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          deleteMany: {
            args: Prisma.EncabezadoCompraDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EncabezadoCompraUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EncabezadoCompraUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          aggregate: {
            args: Prisma.EncabezadoCompraAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEncabezadoCompra>
          }
          groupBy: {
            args: Prisma.EncabezadoCompraGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EncabezadoCompraGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncabezadoCompraCountArgs<ExtArgs>,
            result: $Utils.Optional<EncabezadoCompraCountAggregateOutputType> | number
          }
        }
      }
      DetalleCompra: {
        payload: Prisma.$DetalleCompraPayload<ExtArgs>
        fields: Prisma.DetalleCompraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetalleCompraFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetalleCompraFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          findFirst: {
            args: Prisma.DetalleCompraFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetalleCompraFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          findMany: {
            args: Prisma.DetalleCompraFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>[]
          }
          create: {
            args: Prisma.DetalleCompraCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          createMany: {
            args: Prisma.DetalleCompraCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DetalleCompraDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          update: {
            args: Prisma.DetalleCompraUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          deleteMany: {
            args: Prisma.DetalleCompraDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DetalleCompraUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DetalleCompraUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          aggregate: {
            args: Prisma.DetalleCompraAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetalleCompra>
          }
          groupBy: {
            args: Prisma.DetalleCompraGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DetalleCompraGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetalleCompraCountArgs<ExtArgs>,
            result: $Utils.Optional<DetalleCompraCountAggregateOutputType> | number
          }
        }
      }
      Pedido: {
        payload: Prisma.$PedidoPayload<ExtArgs>
        fields: Prisma.PedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findFirst: {
            args: Prisma.PedidoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findMany: {
            args: Prisma.PedidoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          create: {
            args: Prisma.PedidoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          createMany: {
            args: Prisma.PedidoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PedidoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          update: {
            args: Prisma.PedidoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PedidoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          aggregate: {
            args: Prisma.PedidoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePedido>
          }
          groupBy: {
            args: Prisma.PedidoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoCountArgs<ExtArgs>,
            result: $Utils.Optional<PedidoCountAggregateOutputType> | number
          }
        }
      }
      TrasladoBodegas: {
        payload: Prisma.$TrasladoBodegasPayload<ExtArgs>
        fields: Prisma.TrasladoBodegasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrasladoBodegasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrasladoBodegasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload>
          }
          findFirst: {
            args: Prisma.TrasladoBodegasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrasladoBodegasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload>
          }
          findMany: {
            args: Prisma.TrasladoBodegasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload>[]
          }
          create: {
            args: Prisma.TrasladoBodegasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload>
          }
          createMany: {
            args: Prisma.TrasladoBodegasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrasladoBodegasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload>
          }
          update: {
            args: Prisma.TrasladoBodegasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload>
          }
          deleteMany: {
            args: Prisma.TrasladoBodegasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrasladoBodegasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrasladoBodegasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoBodegasPayload>
          }
          aggregate: {
            args: Prisma.TrasladoBodegasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrasladoBodegas>
          }
          groupBy: {
            args: Prisma.TrasladoBodegasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrasladoBodegasGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrasladoBodegasCountArgs<ExtArgs>,
            result: $Utils.Optional<TrasladoBodegasCountAggregateOutputType> | number
          }
        }
      }
      TrasladoDestino: {
        payload: Prisma.$TrasladoDestinoPayload<ExtArgs>
        fields: Prisma.TrasladoDestinoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrasladoDestinoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrasladoDestinoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload>
          }
          findFirst: {
            args: Prisma.TrasladoDestinoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrasladoDestinoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload>
          }
          findMany: {
            args: Prisma.TrasladoDestinoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload>[]
          }
          create: {
            args: Prisma.TrasladoDestinoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload>
          }
          createMany: {
            args: Prisma.TrasladoDestinoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrasladoDestinoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload>
          }
          update: {
            args: Prisma.TrasladoDestinoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload>
          }
          deleteMany: {
            args: Prisma.TrasladoDestinoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrasladoDestinoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrasladoDestinoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoDestinoPayload>
          }
          aggregate: {
            args: Prisma.TrasladoDestinoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrasladoDestino>
          }
          groupBy: {
            args: Prisma.TrasladoDestinoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrasladoDestinoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrasladoDestinoCountArgs<ExtArgs>,
            result: $Utils.Optional<TrasladoDestinoCountAggregateOutputType> | number
          }
        }
      }
      Historial: {
        payload: Prisma.$HistorialPayload<ExtArgs>
        fields: Prisma.HistorialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistorialFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistorialFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          findFirst: {
            args: Prisma.HistorialFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistorialFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          findMany: {
            args: Prisma.HistorialFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>[]
          }
          create: {
            args: Prisma.HistorialCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          createMany: {
            args: Prisma.HistorialCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HistorialDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          update: {
            args: Prisma.HistorialUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          deleteMany: {
            args: Prisma.HistorialDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HistorialUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HistorialUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          aggregate: {
            args: Prisma.HistorialAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial>
          }
          groupBy: {
            args: Prisma.HistorialGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HistorialGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistorialCountArgs<ExtArgs>,
            result: $Utils.Optional<HistorialCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    bodegaProductos: number
    encabezadoCompras: number
    Historial: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodegaProductos?: boolean | UsuarioCountOutputTypeCountBodegaProductosArgs
    encabezadoCompras?: boolean | UsuarioCountOutputTypeCountEncabezadoComprasArgs
    Historial?: boolean | UsuarioCountOutputTypeCountHistorialArgs
  }

  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountBodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodegaProductosWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEncabezadoComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoCompraWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialWhereInput
  }



  /**
   * Count Type EstadoCountOutputType
   */

  export type EstadoCountOutputType = {
    pedidos: number
    TrasladoDestino: number
  }

  export type EstadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | EstadoCountOutputTypeCountPedidosArgs
    TrasladoDestino?: boolean | EstadoCountOutputTypeCountTrasladoDestinoArgs
  }

  // Custom InputTypes

  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCountOutputType
     */
    select?: EstadoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }


  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeCountTrasladoDestinoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoDestinoWhereInput
  }



  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    subCategoria: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategoria?: boolean | CategoriaCountOutputTypeCountSubCategoriaArgs
  }

  // Custom InputTypes

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountSubCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoriaWhereInput
  }



  /**
   * Count Type SubCategoriaCountOutputType
   */

  export type SubCategoriaCountOutputType = {
    producto: number
    categorias: number
  }

  export type SubCategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | SubCategoriaCountOutputTypeCountProductoArgs
    categorias?: boolean | SubCategoriaCountOutputTypeCountCategoriasArgs
  }

  // Custom InputTypes

  /**
   * SubCategoriaCountOutputType without action
   */
  export type SubCategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoriaCountOutputType
     */
    select?: SubCategoriaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SubCategoriaCountOutputType without action
   */
  export type SubCategoriaCountOutputTypeCountProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
  }


  /**
   * SubCategoriaCountOutputType without action
   */
  export type SubCategoriaCountOutputTypeCountCategoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
  }



  /**
   * Count Type ProductoCountOutputType
   */

  export type ProductoCountOutputType = {
    foto: number
    bodegaProductos: number
    detalleCompras: number
    Historial: number
  }

  export type ProductoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foto?: boolean | ProductoCountOutputTypeCountFotoArgs
    bodegaProductos?: boolean | ProductoCountOutputTypeCountBodegaProductosArgs
    detalleCompras?: boolean | ProductoCountOutputTypeCountDetalleComprasArgs
    Historial?: boolean | ProductoCountOutputTypeCountHistorialArgs
  }

  // Custom InputTypes

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     */
    select?: ProductoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountFotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FotoWhereInput
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountBodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodegaProductosWhereInput
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountDetalleComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleCompraWhereInput
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialWhereInput
  }



  /**
   * Count Type UbicacionCountOutputType
   */

  export type UbicacionCountOutputType = {
    usuario: number
    bodega: number
    provincia: number
    cantones: number
    distritos: number
    barrios: number
  }

  export type UbicacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UbicacionCountOutputTypeCountUsuarioArgs
    bodega?: boolean | UbicacionCountOutputTypeCountBodegaArgs
    provincia?: boolean | UbicacionCountOutputTypeCountProvinciaArgs
    cantones?: boolean | UbicacionCountOutputTypeCountCantonesArgs
    distritos?: boolean | UbicacionCountOutputTypeCountDistritosArgs
    barrios?: boolean | UbicacionCountOutputTypeCountBarriosArgs
  }

  // Custom InputTypes

  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UbicacionCountOutputType
     */
    select?: UbicacionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeCountBodegaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodegaWhereInput
  }


  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeCountProvinciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinciaWhereInput
  }


  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeCountCantonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CantonWhereInput
  }


  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeCountDistritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistritoWhereInput
  }


  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeCountBarriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarrioWhereInput
  }



  /**
   * Count Type ProvinciaCountOutputType
   */

  export type ProvinciaCountOutputType = {
    cantones: number
    distritos: number
    barrios: number
  }

  export type ProvinciaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cantones?: boolean | ProvinciaCountOutputTypeCountCantonesArgs
    distritos?: boolean | ProvinciaCountOutputTypeCountDistritosArgs
    barrios?: boolean | ProvinciaCountOutputTypeCountBarriosArgs
  }

  // Custom InputTypes

  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinciaCountOutputType
     */
    select?: ProvinciaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeCountCantonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CantonWhereInput
  }


  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeCountDistritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistritoWhereInput
  }


  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeCountBarriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarrioWhereInput
  }



  /**
   * Count Type CantonCountOutputType
   */

  export type CantonCountOutputType = {
    distritos: number
    barrios: number
  }

  export type CantonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    distritos?: boolean | CantonCountOutputTypeCountDistritosArgs
    barrios?: boolean | CantonCountOutputTypeCountBarriosArgs
  }

  // Custom InputTypes

  /**
   * CantonCountOutputType without action
   */
  export type CantonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CantonCountOutputType
     */
    select?: CantonCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CantonCountOutputType without action
   */
  export type CantonCountOutputTypeCountDistritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistritoWhereInput
  }


  /**
   * CantonCountOutputType without action
   */
  export type CantonCountOutputTypeCountBarriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarrioWhereInput
  }



  /**
   * Count Type DistritoCountOutputType
   */

  export type DistritoCountOutputType = {
    barrios: number
  }

  export type DistritoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barrios?: boolean | DistritoCountOutputTypeCountBarriosArgs
  }

  // Custom InputTypes

  /**
   * DistritoCountOutputType without action
   */
  export type DistritoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistritoCountOutputType
     */
    select?: DistritoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DistritoCountOutputType without action
   */
  export type DistritoCountOutputTypeCountBarriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarrioWhereInput
  }



  /**
   * Count Type BodegaCountOutputType
   */

  export type BodegaCountOutputType = {
    bodegaProductos: number
    detalleCompras: number
    Historial: number
    TrasladoDestino: number
  }

  export type BodegaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodegaProductos?: boolean | BodegaCountOutputTypeCountBodegaProductosArgs
    detalleCompras?: boolean | BodegaCountOutputTypeCountDetalleComprasArgs
    Historial?: boolean | BodegaCountOutputTypeCountHistorialArgs
    TrasladoDestino?: boolean | BodegaCountOutputTypeCountTrasladoDestinoArgs
  }

  // Custom InputTypes

  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaCountOutputType
     */
    select?: BodegaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountBodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodegaProductosWhereInput
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountDetalleComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleCompraWhereInput
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialWhereInput
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountTrasladoDestinoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoDestinoWhereInput
  }



  /**
   * Count Type EncabezadoCompraCountOutputType
   */

  export type EncabezadoCompraCountOutputType = {
    detalleCompras: number
    pedidos: number
  }

  export type EncabezadoCompraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalleCompras?: boolean | EncabezadoCompraCountOutputTypeCountDetalleComprasArgs
    pedidos?: boolean | EncabezadoCompraCountOutputTypeCountPedidosArgs
  }

  // Custom InputTypes

  /**
   * EncabezadoCompraCountOutputType without action
   */
  export type EncabezadoCompraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompraCountOutputType
     */
    select?: EncabezadoCompraCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EncabezadoCompraCountOutputType without action
   */
  export type EncabezadoCompraCountOutputTypeCountDetalleComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleCompraWhereInput
  }


  /**
   * EncabezadoCompraCountOutputType without action
   */
  export type EncabezadoCompraCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }



  /**
   * Count Type PedidoCountOutputType
   */

  export type PedidoCountOutputType = {
    TrasladoBodegas: number
  }

  export type PedidoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TrasladoBodegas?: boolean | PedidoCountOutputTypeCountTrasladoBodegasArgs
  }

  // Custom InputTypes

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     */
    select?: PedidoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountTrasladoBodegasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoBodegasWhereInput
  }



  /**
   * Count Type TrasladoDestinoCountOutputType
   */

  export type TrasladoDestinoCountOutputType = {
    TrasladoBodegas: number
  }

  export type TrasladoDestinoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TrasladoBodegas?: boolean | TrasladoDestinoCountOutputTypeCountTrasladoBodegasArgs
  }

  // Custom InputTypes

  /**
   * TrasladoDestinoCountOutputType without action
   */
  export type TrasladoDestinoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestinoCountOutputType
     */
    select?: TrasladoDestinoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TrasladoDestinoCountOutputType without action
   */
  export type TrasladoDestinoCountOutputTypeCountTrasladoBodegasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoBodegasWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    idUbicacion: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    idUbicacion: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    nombreProveedor: string | null
    correo: string | null
    contrasenna: string | null
    fechaRegistro: Date | null
    rol: $Enums.Rol | null
    idUbicacion: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    nombreProveedor: string | null
    correo: string | null
    contrasenna: string | null
    fechaRegistro: Date | null
    rol: $Enums.Rol | null
    idUbicacion: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    apellidos: number
    nombreProveedor: number
    correo: number
    contrasenna: number
    fechaRegistro: number
    rol: number
    idUbicacion: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    idUbicacion?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    idUbicacion?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    nombreProveedor?: true
    correo?: true
    contrasenna?: true
    fechaRegistro?: true
    rol?: true
    idUbicacion?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    nombreProveedor?: true
    correo?: true
    contrasenna?: true
    fechaRegistro?: true
    rol?: true
    idUbicacion?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    nombreProveedor?: true
    correo?: true
    contrasenna?: true
    fechaRegistro?: true
    rol?: true
    idUbicacion?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nombre: string
    apellidos: string
    nombreProveedor: string | null
    correo: string
    contrasenna: string
    fechaRegistro: Date
    rol: $Enums.Rol
    idUbicacion: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    nombreProveedor?: boolean
    correo?: boolean
    contrasenna?: boolean
    fechaRegistro?: boolean
    rol?: boolean
    idUbicacion?: boolean
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    bodegaProductos?: boolean | Usuario$bodegaProductosArgs<ExtArgs>
    encabezadoCompras?: boolean | Usuario$encabezadoComprasArgs<ExtArgs>
    Historial?: boolean | Usuario$HistorialArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    nombreProveedor?: boolean
    correo?: boolean
    contrasenna?: boolean
    fechaRegistro?: boolean
    rol?: boolean
    idUbicacion?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    bodegaProductos?: boolean | Usuario$bodegaProductosArgs<ExtArgs>
    encabezadoCompras?: boolean | Usuario$encabezadoComprasArgs<ExtArgs>
    Historial?: boolean | Usuario$HistorialArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      ubicacion: Prisma.$UbicacionPayload<ExtArgs>
      bodegaProductos: Prisma.$BodegaProductosPayload<ExtArgs>[]
      encabezadoCompras: Prisma.$EncabezadoCompraPayload<ExtArgs>[]
      Historial: Prisma.$HistorialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellidos: string
      nombreProveedor: string | null
      correo: string
      contrasenna: string
      fechaRegistro: Date
      rol: $Enums.Rol
      idUbicacion: number
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }


  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ubicacion<T extends UbicacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UbicacionDefaultArgs<ExtArgs>>): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bodegaProductos<T extends Usuario$bodegaProductosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$bodegaProductosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'findMany'> | Null>;

    encabezadoCompras<T extends Usuario$encabezadoComprasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$encabezadoComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    Historial<T extends Usuario$HistorialArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$HistorialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellidos: FieldRef<"Usuario", 'String'>
    readonly nombreProveedor: FieldRef<"Usuario", 'String'>
    readonly correo: FieldRef<"Usuario", 'String'>
    readonly contrasenna: FieldRef<"Usuario", 'String'>
    readonly fechaRegistro: FieldRef<"Usuario", 'DateTime'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly idUbicacion: FieldRef<"Usuario", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario.bodegaProductos
   */
  export type Usuario$bodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    where?: BodegaProductosWhereInput
    orderBy?: BodegaProductosOrderByWithRelationInput | BodegaProductosOrderByWithRelationInput[]
    cursor?: BodegaProductosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BodegaProductosScalarFieldEnum | BodegaProductosScalarFieldEnum[]
  }


  /**
   * Usuario.encabezadoCompras
   */
  export type Usuario$encabezadoComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    where?: EncabezadoCompraWhereInput
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    cursor?: EncabezadoCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * Usuario.Historial
   */
  export type Usuario$HistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    where?: HistorialWhereInput
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    cursor?: HistorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
  }



  /**
   * Model Estado
   */

  export type AggregateEstado = {
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  export type EstadoAvgAggregateOutputType = {
    id: number | null
  }

  export type EstadoSumAggregateOutputType = {
    id: number | null
  }

  export type EstadoMinAggregateOutputType = {
    id: number | null
    estado: string | null
  }

  export type EstadoMaxAggregateOutputType = {
    id: number | null
    estado: string | null
  }

  export type EstadoCountAggregateOutputType = {
    id: number
    estado: number
    _all: number
  }


  export type EstadoAvgAggregateInputType = {
    id?: true
  }

  export type EstadoSumAggregateInputType = {
    id?: true
  }

  export type EstadoMinAggregateInputType = {
    id?: true
    estado?: true
  }

  export type EstadoMaxAggregateInputType = {
    id?: true
    estado?: true
  }

  export type EstadoCountAggregateInputType = {
    id?: true
    estado?: true
    _all?: true
  }

  export type EstadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estado to aggregate.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estados
    **/
    _count?: true | EstadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoMaxAggregateInputType
  }

  export type GetEstadoAggregateType<T extends EstadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEstado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstado[P]>
      : GetScalarType<T[P], AggregateEstado[P]>
  }




  export type EstadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstadoWhereInput
    orderBy?: EstadoOrderByWithAggregationInput | EstadoOrderByWithAggregationInput[]
    by: EstadoScalarFieldEnum[] | EstadoScalarFieldEnum
    having?: EstadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoCountAggregateInputType | true
    _avg?: EstadoAvgAggregateInputType
    _sum?: EstadoSumAggregateInputType
    _min?: EstadoMinAggregateInputType
    _max?: EstadoMaxAggregateInputType
  }

  export type EstadoGroupByOutputType = {
    id: number
    estado: string
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  type GetEstadoGroupByPayload<T extends EstadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoGroupByOutputType[P]>
        }
      >
    >


  export type EstadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estado?: boolean
    pedidos?: boolean | Estado$pedidosArgs<ExtArgs>
    TrasladoDestino?: boolean | Estado$TrasladoDestinoArgs<ExtArgs>
    _count?: boolean | EstadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estado"]>

  export type EstadoSelectScalar = {
    id?: boolean
    estado?: boolean
  }

  export type EstadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | Estado$pedidosArgs<ExtArgs>
    TrasladoDestino?: boolean | Estado$TrasladoDestinoArgs<ExtArgs>
    _count?: boolean | EstadoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EstadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estado"
    objects: {
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
      TrasladoDestino: Prisma.$TrasladoDestinoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      estado: string
    }, ExtArgs["result"]["estado"]>
    composites: {}
  }


  type EstadoGetPayload<S extends boolean | null | undefined | EstadoDefaultArgs> = $Result.GetResult<Prisma.$EstadoPayload, S>

  type EstadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstadoCountAggregateInputType | true
    }

  export interface EstadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estado'], meta: { name: 'Estado' } }
    /**
     * Find zero or one Estado that matches the filter.
     * @param {EstadoFindUniqueArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EstadoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoFindUniqueArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Estado that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EstadoFindUniqueOrThrowArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EstadoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Estado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindFirstArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EstadoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoFindFirstArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Estado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindFirstOrThrowArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EstadoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estados
     * const estados = await prisma.estado.findMany()
     * 
     * // Get first 10 Estados
     * const estados = await prisma.estado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadoWithIdOnly = await prisma.estado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EstadoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Estado.
     * @param {EstadoCreateArgs} args - Arguments to create a Estado.
     * @example
     * // Create one Estado
     * const Estado = await prisma.estado.create({
     *   data: {
     *     // ... data to create a Estado
     *   }
     * })
     * 
    **/
    create<T extends EstadoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoCreateArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Estados.
     *     @param {EstadoCreateManyArgs} args - Arguments to create many Estados.
     *     @example
     *     // Create many Estados
     *     const estado = await prisma.estado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EstadoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estado.
     * @param {EstadoDeleteArgs} args - Arguments to delete one Estado.
     * @example
     * // Delete one Estado
     * const Estado = await prisma.estado.delete({
     *   where: {
     *     // ... filter to delete one Estado
     *   }
     * })
     * 
    **/
    delete<T extends EstadoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoDeleteArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Estado.
     * @param {EstadoUpdateArgs} args - Arguments to update one Estado.
     * @example
     * // Update one Estado
     * const estado = await prisma.estado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstadoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoUpdateArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Estados.
     * @param {EstadoDeleteManyArgs} args - Arguments to filter Estados to delete.
     * @example
     * // Delete a few Estados
     * const { count } = await prisma.estado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstadoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estados
     * const estado = await prisma.estado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstadoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estado.
     * @param {EstadoUpsertArgs} args - Arguments to update or create a Estado.
     * @example
     * // Update or create a Estado
     * const estado = await prisma.estado.upsert({
     *   create: {
     *     // ... data to create a Estado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estado we want to update
     *   }
     * })
    **/
    upsert<T extends EstadoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoUpsertArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCountArgs} args - Arguments to filter Estados to count.
     * @example
     * // Count the number of Estados
     * const count = await prisma.estado.count({
     *   where: {
     *     // ... the filter for the Estados we want to count
     *   }
     * })
    **/
    count<T extends EstadoCountArgs>(
      args?: Subset<T, EstadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoAggregateArgs>(args: Subset<T, EstadoAggregateArgs>): Prisma.PrismaPromise<GetEstadoAggregateType<T>>

    /**
     * Group by Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoGroupByArgs['orderBy'] }
        : { orderBy?: EstadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estado model
   */
  readonly fields: EstadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pedidos<T extends Estado$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, Estado$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'> | Null>;

    TrasladoDestino<T extends Estado$TrasladoDestinoArgs<ExtArgs> = {}>(args?: Subset<T, Estado$TrasladoDestinoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Estado model
   */ 
  interface EstadoFieldRefs {
    readonly id: FieldRef<"Estado", 'Int'>
    readonly estado: FieldRef<"Estado", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Estado findUnique
   */
  export type EstadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado findUniqueOrThrow
   */
  export type EstadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado findFirst
   */
  export type EstadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estados.
     */
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }


  /**
   * Estado findFirstOrThrow
   */
  export type EstadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estados.
     */
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }


  /**
   * Estado findMany
   */
  export type EstadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estados to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }


  /**
   * Estado create
   */
  export type EstadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The data needed to create a Estado.
     */
    data: XOR<EstadoCreateInput, EstadoUncheckedCreateInput>
  }


  /**
   * Estado createMany
   */
  export type EstadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estados.
     */
    data: EstadoCreateManyInput | EstadoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Estado update
   */
  export type EstadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The data needed to update a Estado.
     */
    data: XOR<EstadoUpdateInput, EstadoUncheckedUpdateInput>
    /**
     * Choose, which Estado to update.
     */
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado updateMany
   */
  export type EstadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estados.
     */
    data: XOR<EstadoUpdateManyMutationInput, EstadoUncheckedUpdateManyInput>
    /**
     * Filter which Estados to update
     */
    where?: EstadoWhereInput
  }


  /**
   * Estado upsert
   */
  export type EstadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The filter to search for the Estado to update in case it exists.
     */
    where: EstadoWhereUniqueInput
    /**
     * In case the Estado found by the `where` argument doesn't exist, create a new Estado with this data.
     */
    create: XOR<EstadoCreateInput, EstadoUncheckedCreateInput>
    /**
     * In case the Estado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstadoUpdateInput, EstadoUncheckedUpdateInput>
  }


  /**
   * Estado delete
   */
  export type EstadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter which Estado to delete.
     */
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado deleteMany
   */
  export type EstadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estados to delete
     */
    where?: EstadoWhereInput
  }


  /**
   * Estado.pedidos
   */
  export type Estado$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Estado.TrasladoDestino
   */
  export type Estado$TrasladoDestinoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    where?: TrasladoDestinoWhereInput
    orderBy?: TrasladoDestinoOrderByWithRelationInput | TrasladoDestinoOrderByWithRelationInput[]
    cursor?: TrasladoDestinoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoDestinoScalarFieldEnum | TrasladoDestinoScalarFieldEnum[]
  }


  /**
   * Estado without action
   */
  export type EstadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
  }



  /**
   * Model Categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithAggregationInput | CategoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    id: number
    nombre: string
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    subCategoria?: boolean | Categoria$subCategoriaArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type CategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategoria?: boolean | Categoria$subCategoriaArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categoria"
    objects: {
      subCategoria: Prisma.$SubCategoriaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }


  type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaDefaultArgs> = $Result.GetResult<Prisma.$CategoriaPayload, S>

  type CategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface CategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categoria'], meta: { name: 'Categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Categoria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaFindFirstArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
    **/
    create<T extends CategoriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaCreateArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categorias.
     *     @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     *     @example
     *     // Create many Categorias
     *     const categoria = await prisma.categoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
    **/
    delete<T extends CategoriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaDeleteArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaUpdateArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaUpsertArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categoria model
   */
  readonly fields: CategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    subCategoria<T extends Categoria$subCategoriaArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$subCategoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Categoria model
   */ 
  interface CategoriaFieldRefs {
    readonly id: FieldRef<"Categoria", 'Int'>
    readonly nombre: FieldRef<"Categoria", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * Categoria create
   */
  export type CategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }


  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
  }


  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }


  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput
  }


  /**
   * Categoria.subCategoria
   */
  export type Categoria$subCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    where?: SubCategoriaWhereInput
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    cursor?: SubCategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoriaScalarFieldEnum | SubCategoriaScalarFieldEnum[]
  }


  /**
   * Categoria without action
   */
  export type CategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
  }



  /**
   * Model SubCategoria
   */

  export type AggregateSubCategoria = {
    _count: SubCategoriaCountAggregateOutputType | null
    _avg: SubCategoriaAvgAggregateOutputType | null
    _sum: SubCategoriaSumAggregateOutputType | null
    _min: SubCategoriaMinAggregateOutputType | null
    _max: SubCategoriaMaxAggregateOutputType | null
  }

  export type SubCategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type SubCategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type SubCategoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type SubCategoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type SubCategoriaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type SubCategoriaAvgAggregateInputType = {
    id?: true
  }

  export type SubCategoriaSumAggregateInputType = {
    id?: true
  }

  export type SubCategoriaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type SubCategoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type SubCategoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type SubCategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategoria to aggregate.
     */
    where?: SubCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategorias to fetch.
     */
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategorias
    **/
    _count?: true | SubCategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubCategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubCategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoriaMaxAggregateInputType
  }

  export type GetSubCategoriaAggregateType<T extends SubCategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategoria[P]>
      : GetScalarType<T[P], AggregateSubCategoria[P]>
  }




  export type SubCategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoriaWhereInput
    orderBy?: SubCategoriaOrderByWithAggregationInput | SubCategoriaOrderByWithAggregationInput[]
    by: SubCategoriaScalarFieldEnum[] | SubCategoriaScalarFieldEnum
    having?: SubCategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoriaCountAggregateInputType | true
    _avg?: SubCategoriaAvgAggregateInputType
    _sum?: SubCategoriaSumAggregateInputType
    _min?: SubCategoriaMinAggregateInputType
    _max?: SubCategoriaMaxAggregateInputType
  }

  export type SubCategoriaGroupByOutputType = {
    id: number
    nombre: string
    _count: SubCategoriaCountAggregateOutputType | null
    _avg: SubCategoriaAvgAggregateOutputType | null
    _sum: SubCategoriaSumAggregateOutputType | null
    _min: SubCategoriaMinAggregateOutputType | null
    _max: SubCategoriaMaxAggregateOutputType | null
  }

  type GetSubCategoriaGroupByPayload<T extends SubCategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubCategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoriaGroupByOutputType[P]>
        }
      >
    >


  export type SubCategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    producto?: boolean | SubCategoria$productoArgs<ExtArgs>
    categorias?: boolean | SubCategoria$categoriasArgs<ExtArgs>
    _count?: boolean | SubCategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategoria"]>

  export type SubCategoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type SubCategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | SubCategoria$productoArgs<ExtArgs>
    categorias?: boolean | SubCategoria$categoriasArgs<ExtArgs>
    _count?: boolean | SubCategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SubCategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubCategoria"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>[]
      categorias: Prisma.$CategoriaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["subCategoria"]>
    composites: {}
  }


  type SubCategoriaGetPayload<S extends boolean | null | undefined | SubCategoriaDefaultArgs> = $Result.GetResult<Prisma.$SubCategoriaPayload, S>

  type SubCategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubCategoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubCategoriaCountAggregateInputType | true
    }

  export interface SubCategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubCategoria'], meta: { name: 'SubCategoria' } }
    /**
     * Find zero or one SubCategoria that matches the filter.
     * @param {SubCategoriaFindUniqueArgs} args - Arguments to find a SubCategoria
     * @example
     * // Get one SubCategoria
     * const subCategoria = await prisma.subCategoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubCategoriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaFindUniqueArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SubCategoria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubCategoriaFindUniqueOrThrowArgs} args - Arguments to find a SubCategoria
     * @example
     * // Get one SubCategoria
     * const subCategoria = await prisma.subCategoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubCategoriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SubCategoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaFindFirstArgs} args - Arguments to find a SubCategoria
     * @example
     * // Get one SubCategoria
     * const subCategoria = await prisma.subCategoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubCategoriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaFindFirstArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SubCategoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaFindFirstOrThrowArgs} args - Arguments to find a SubCategoria
     * @example
     * // Get one SubCategoria
     * const subCategoria = await prisma.subCategoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubCategoriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SubCategorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategorias
     * const subCategorias = await prisma.subCategoria.findMany()
     * 
     * // Get first 10 SubCategorias
     * const subCategorias = await prisma.subCategoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoriaWithIdOnly = await prisma.subCategoria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubCategoriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SubCategoria.
     * @param {SubCategoriaCreateArgs} args - Arguments to create a SubCategoria.
     * @example
     * // Create one SubCategoria
     * const SubCategoria = await prisma.subCategoria.create({
     *   data: {
     *     // ... data to create a SubCategoria
     *   }
     * })
     * 
    **/
    create<T extends SubCategoriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaCreateArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SubCategorias.
     *     @param {SubCategoriaCreateManyArgs} args - Arguments to create many SubCategorias.
     *     @example
     *     // Create many SubCategorias
     *     const subCategoria = await prisma.subCategoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubCategoriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategoria.
     * @param {SubCategoriaDeleteArgs} args - Arguments to delete one SubCategoria.
     * @example
     * // Delete one SubCategoria
     * const SubCategoria = await prisma.subCategoria.delete({
     *   where: {
     *     // ... filter to delete one SubCategoria
     *   }
     * })
     * 
    **/
    delete<T extends SubCategoriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaDeleteArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SubCategoria.
     * @param {SubCategoriaUpdateArgs} args - Arguments to update one SubCategoria.
     * @example
     * // Update one SubCategoria
     * const subCategoria = await prisma.subCategoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubCategoriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaUpdateArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SubCategorias.
     * @param {SubCategoriaDeleteManyArgs} args - Arguments to filter SubCategorias to delete.
     * @example
     * // Delete a few SubCategorias
     * const { count } = await prisma.subCategoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubCategoriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategorias
     * const subCategoria = await prisma.subCategoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubCategoriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategoria.
     * @param {SubCategoriaUpsertArgs} args - Arguments to update or create a SubCategoria.
     * @example
     * // Update or create a SubCategoria
     * const subCategoria = await prisma.subCategoria.upsert({
     *   create: {
     *     // ... data to create a SubCategoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategoria we want to update
     *   }
     * })
    **/
    upsert<T extends SubCategoriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaUpsertArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SubCategorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaCountArgs} args - Arguments to filter SubCategorias to count.
     * @example
     * // Count the number of SubCategorias
     * const count = await prisma.subCategoria.count({
     *   where: {
     *     // ... the filter for the SubCategorias we want to count
     *   }
     * })
    **/
    count<T extends SubCategoriaCountArgs>(
      args?: Subset<T, SubCategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoriaAggregateArgs>(args: Subset<T, SubCategoriaAggregateArgs>): Prisma.PrismaPromise<GetSubCategoriaAggregateType<T>>

    /**
     * Group by SubCategoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoriaGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubCategoria model
   */
  readonly fields: SubCategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubCategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    producto<T extends SubCategoria$productoArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoria$productoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findMany'> | Null>;

    categorias<T extends SubCategoria$categoriasArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoria$categoriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SubCategoria model
   */ 
  interface SubCategoriaFieldRefs {
    readonly id: FieldRef<"SubCategoria", 'Int'>
    readonly nombre: FieldRef<"SubCategoria", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SubCategoria findUnique
   */
  export type SubCategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoria to fetch.
     */
    where: SubCategoriaWhereUniqueInput
  }


  /**
   * SubCategoria findUniqueOrThrow
   */
  export type SubCategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoria to fetch.
     */
    where: SubCategoriaWhereUniqueInput
  }


  /**
   * SubCategoria findFirst
   */
  export type SubCategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoria to fetch.
     */
    where?: SubCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategorias to fetch.
     */
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategorias.
     */
    cursor?: SubCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategorias.
     */
    distinct?: SubCategoriaScalarFieldEnum | SubCategoriaScalarFieldEnum[]
  }


  /**
   * SubCategoria findFirstOrThrow
   */
  export type SubCategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoria to fetch.
     */
    where?: SubCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategorias to fetch.
     */
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategorias.
     */
    cursor?: SubCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategorias.
     */
    distinct?: SubCategoriaScalarFieldEnum | SubCategoriaScalarFieldEnum[]
  }


  /**
   * SubCategoria findMany
   */
  export type SubCategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategorias to fetch.
     */
    where?: SubCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategorias to fetch.
     */
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategorias.
     */
    cursor?: SubCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategorias.
     */
    skip?: number
    distinct?: SubCategoriaScalarFieldEnum | SubCategoriaScalarFieldEnum[]
  }


  /**
   * SubCategoria create
   */
  export type SubCategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a SubCategoria.
     */
    data: XOR<SubCategoriaCreateInput, SubCategoriaUncheckedCreateInput>
  }


  /**
   * SubCategoria createMany
   */
  export type SubCategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubCategorias.
     */
    data: SubCategoriaCreateManyInput | SubCategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SubCategoria update
   */
  export type SubCategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a SubCategoria.
     */
    data: XOR<SubCategoriaUpdateInput, SubCategoriaUncheckedUpdateInput>
    /**
     * Choose, which SubCategoria to update.
     */
    where: SubCategoriaWhereUniqueInput
  }


  /**
   * SubCategoria updateMany
   */
  export type SubCategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubCategorias.
     */
    data: XOR<SubCategoriaUpdateManyMutationInput, SubCategoriaUncheckedUpdateManyInput>
    /**
     * Filter which SubCategorias to update
     */
    where?: SubCategoriaWhereInput
  }


  /**
   * SubCategoria upsert
   */
  export type SubCategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the SubCategoria to update in case it exists.
     */
    where: SubCategoriaWhereUniqueInput
    /**
     * In case the SubCategoria found by the `where` argument doesn't exist, create a new SubCategoria with this data.
     */
    create: XOR<SubCategoriaCreateInput, SubCategoriaUncheckedCreateInput>
    /**
     * In case the SubCategoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoriaUpdateInput, SubCategoriaUncheckedUpdateInput>
  }


  /**
   * SubCategoria delete
   */
  export type SubCategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter which SubCategoria to delete.
     */
    where: SubCategoriaWhereUniqueInput
  }


  /**
   * SubCategoria deleteMany
   */
  export type SubCategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategorias to delete
     */
    where?: SubCategoriaWhereInput
  }


  /**
   * SubCategoria.producto
   */
  export type SubCategoria$productoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    cursor?: ProductoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * SubCategoria.categorias
   */
  export type SubCategoria$categoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    cursor?: CategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * SubCategoria without action
   */
  export type SubCategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
  }



  /**
   * Model Producto
   */

  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    id: number | null
    idSubCategoria: number | null
    stock: number | null
    precio: Decimal | null
  }

  export type ProductoSumAggregateOutputType = {
    id: number | null
    idSubCategoria: number | null
    stock: number | null
    precio: Decimal | null
  }

  export type ProductoMinAggregateOutputType = {
    id: number | null
    codigoProducto: string | null
    nombre: string | null
    descripcion: string | null
    idSubCategoria: number | null
    stock: number | null
    precio: Decimal | null
  }

  export type ProductoMaxAggregateOutputType = {
    id: number | null
    codigoProducto: string | null
    nombre: string | null
    descripcion: string | null
    idSubCategoria: number | null
    stock: number | null
    precio: Decimal | null
  }

  export type ProductoCountAggregateOutputType = {
    id: number
    codigoProducto: number
    nombre: number
    descripcion: number
    idSubCategoria: number
    stock: number
    precio: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    id?: true
    idSubCategoria?: true
    stock?: true
    precio?: true
  }

  export type ProductoSumAggregateInputType = {
    id?: true
    idSubCategoria?: true
    stock?: true
    precio?: true
  }

  export type ProductoMinAggregateInputType = {
    id?: true
    codigoProducto?: true
    nombre?: true
    descripcion?: true
    idSubCategoria?: true
    stock?: true
    precio?: true
  }

  export type ProductoMaxAggregateInputType = {
    id?: true
    codigoProducto?: true
    nombre?: true
    descripcion?: true
    idSubCategoria?: true
    stock?: true
    precio?: true
  }

  export type ProductoCountAggregateInputType = {
    id?: true
    codigoProducto?: true
    nombre?: true
    descripcion?: true
    idSubCategoria?: true
    stock?: true
    precio?: true
    _all?: true
  }

  export type ProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Producto to aggregate.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithAggregationInput | ProductoOrderByWithAggregationInput[]
    by: ProductoScalarFieldEnum[] | ProductoScalarFieldEnum
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }

  export type ProductoGroupByOutputType = {
    id: number
    codigoProducto: string
    nombre: string
    descripcion: string
    idSubCategoria: number
    stock: number
    precio: Decimal
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoProducto?: boolean
    nombre?: boolean
    descripcion?: boolean
    idSubCategoria?: boolean
    stock?: boolean
    precio?: boolean
    subCategorias?: boolean | SubCategoriaDefaultArgs<ExtArgs>
    foto?: boolean | Producto$fotoArgs<ExtArgs>
    bodegaProductos?: boolean | Producto$bodegaProductosArgs<ExtArgs>
    detalleCompras?: boolean | Producto$detalleComprasArgs<ExtArgs>
    Historial?: boolean | Producto$HistorialArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>

  export type ProductoSelectScalar = {
    id?: boolean
    codigoProducto?: boolean
    nombre?: boolean
    descripcion?: boolean
    idSubCategoria?: boolean
    stock?: boolean
    precio?: boolean
  }

  export type ProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategorias?: boolean | SubCategoriaDefaultArgs<ExtArgs>
    foto?: boolean | Producto$fotoArgs<ExtArgs>
    bodegaProductos?: boolean | Producto$bodegaProductosArgs<ExtArgs>
    detalleCompras?: boolean | Producto$detalleComprasArgs<ExtArgs>
    Historial?: boolean | Producto$HistorialArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Producto"
    objects: {
      subCategorias: Prisma.$SubCategoriaPayload<ExtArgs>
      foto: Prisma.$FotoPayload<ExtArgs>[]
      bodegaProductos: Prisma.$BodegaProductosPayload<ExtArgs>[]
      detalleCompras: Prisma.$DetalleCompraPayload<ExtArgs>[]
      Historial: Prisma.$HistorialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigoProducto: string
      nombre: string
      descripcion: string
      idSubCategoria: number
      stock: number
      precio: Prisma.Decimal
    }, ExtArgs["result"]["producto"]>
    composites: {}
  }


  type ProductoGetPayload<S extends boolean | null | undefined | ProductoDefaultArgs> = $Result.GetResult<Prisma.$ProductoPayload, S>

  type ProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductoCountAggregateInputType | true
    }

  export interface ProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Producto'], meta: { name: 'Producto' } }
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Producto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoFindFirstArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Producto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
    **/
    create<T extends ProductoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoCreateArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Productos.
     *     @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     *     @example
     *     // Create many Productos
     *     const producto = await prisma.producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
    **/
    delete<T extends ProductoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoDeleteArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoUpdateArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
    **/
    upsert<T extends ProductoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoUpsertArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): Prisma.PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Producto model
   */
  readonly fields: ProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    subCategorias<T extends SubCategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoriaDefaultArgs<ExtArgs>>): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    foto<T extends Producto$fotoArgs<ExtArgs> = {}>(args?: Subset<T, Producto$fotoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    bodegaProductos<T extends Producto$bodegaProductosArgs<ExtArgs> = {}>(args?: Subset<T, Producto$bodegaProductosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'findMany'> | Null>;

    detalleCompras<T extends Producto$detalleComprasArgs<ExtArgs> = {}>(args?: Subset<T, Producto$detalleComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    Historial<T extends Producto$HistorialArgs<ExtArgs> = {}>(args?: Subset<T, Producto$HistorialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Producto model
   */ 
  interface ProductoFieldRefs {
    readonly id: FieldRef<"Producto", 'Int'>
    readonly codigoProducto: FieldRef<"Producto", 'String'>
    readonly nombre: FieldRef<"Producto", 'String'>
    readonly descripcion: FieldRef<"Producto", 'String'>
    readonly idSubCategoria: FieldRef<"Producto", 'Int'>
    readonly stock: FieldRef<"Producto", 'Int'>
    readonly precio: FieldRef<"Producto", 'Decimal'>
  }
    

  // Custom InputTypes

  /**
   * Producto findUnique
   */
  export type ProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto findFirst
   */
  export type ProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * Producto findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * Producto create
   */
  export type ProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a Producto.
     */
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }


  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Producto update
   */
  export type ProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a Producto.
     */
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     */
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productos.
     */
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     */
    where?: ProductoWhereInput
  }


  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the Producto to update in case it exists.
     */
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     */
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }


  /**
   * Producto delete
   */
  export type ProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter which Producto to delete.
     */
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productos to delete
     */
    where?: ProductoWhereInput
  }


  /**
   * Producto.foto
   */
  export type Producto$fotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    where?: FotoWhereInput
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    cursor?: FotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FotoScalarFieldEnum | FotoScalarFieldEnum[]
  }


  /**
   * Producto.bodegaProductos
   */
  export type Producto$bodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    where?: BodegaProductosWhereInput
    orderBy?: BodegaProductosOrderByWithRelationInput | BodegaProductosOrderByWithRelationInput[]
    cursor?: BodegaProductosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BodegaProductosScalarFieldEnum | BodegaProductosScalarFieldEnum[]
  }


  /**
   * Producto.detalleCompras
   */
  export type Producto$detalleComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    where?: DetalleCompraWhereInput
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    cursor?: DetalleCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * Producto.Historial
   */
  export type Producto$HistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    where?: HistorialWhereInput
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    cursor?: HistorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Producto without action
   */
  export type ProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
  }



  /**
   * Model Foto
   */

  export type AggregateFoto = {
    _count: FotoCountAggregateOutputType | null
    _avg: FotoAvgAggregateOutputType | null
    _sum: FotoSumAggregateOutputType | null
    _min: FotoMinAggregateOutputType | null
    _max: FotoMaxAggregateOutputType | null
  }

  export type FotoAvgAggregateOutputType = {
    id: number | null
    idProducto: number | null
  }

  export type FotoSumAggregateOutputType = {
    id: number | null
    idProducto: number | null
  }

  export type FotoMinAggregateOutputType = {
    id: number | null
    idProducto: number | null
    foto: Buffer | null
  }

  export type FotoMaxAggregateOutputType = {
    id: number | null
    idProducto: number | null
    foto: Buffer | null
  }

  export type FotoCountAggregateOutputType = {
    id: number
    idProducto: number
    foto: number
    _all: number
  }


  export type FotoAvgAggregateInputType = {
    id?: true
    idProducto?: true
  }

  export type FotoSumAggregateInputType = {
    id?: true
    idProducto?: true
  }

  export type FotoMinAggregateInputType = {
    id?: true
    idProducto?: true
    foto?: true
  }

  export type FotoMaxAggregateInputType = {
    id?: true
    idProducto?: true
    foto?: true
  }

  export type FotoCountAggregateInputType = {
    id?: true
    idProducto?: true
    foto?: true
    _all?: true
  }

  export type FotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foto to aggregate.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fotos
    **/
    _count?: true | FotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FotoMaxAggregateInputType
  }

  export type GetFotoAggregateType<T extends FotoAggregateArgs> = {
        [P in keyof T & keyof AggregateFoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoto[P]>
      : GetScalarType<T[P], AggregateFoto[P]>
  }




  export type FotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FotoWhereInput
    orderBy?: FotoOrderByWithAggregationInput | FotoOrderByWithAggregationInput[]
    by: FotoScalarFieldEnum[] | FotoScalarFieldEnum
    having?: FotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FotoCountAggregateInputType | true
    _avg?: FotoAvgAggregateInputType
    _sum?: FotoSumAggregateInputType
    _min?: FotoMinAggregateInputType
    _max?: FotoMaxAggregateInputType
  }

  export type FotoGroupByOutputType = {
    id: number
    idProducto: number
    foto: Buffer
    _count: FotoCountAggregateOutputType | null
    _avg: FotoAvgAggregateOutputType | null
    _sum: FotoSumAggregateOutputType | null
    _min: FotoMinAggregateOutputType | null
    _max: FotoMaxAggregateOutputType | null
  }

  type GetFotoGroupByPayload<T extends FotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FotoGroupByOutputType[P]>
            : GetScalarType<T[P], FotoGroupByOutputType[P]>
        }
      >
    >


  export type FotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProducto?: boolean
    foto?: boolean
    productos?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foto"]>

  export type FotoSelectScalar = {
    id?: boolean
    idProducto?: boolean
    foto?: boolean
  }

  export type FotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | ProductoDefaultArgs<ExtArgs>
  }


  export type $FotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Foto"
    objects: {
      productos: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idProducto: number
      foto: Buffer
    }, ExtArgs["result"]["foto"]>
    composites: {}
  }


  type FotoGetPayload<S extends boolean | null | undefined | FotoDefaultArgs> = $Result.GetResult<Prisma.$FotoPayload, S>

  type FotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FotoCountAggregateInputType | true
    }

  export interface FotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Foto'], meta: { name: 'Foto' } }
    /**
     * Find zero or one Foto that matches the filter.
     * @param {FotoFindUniqueArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FotoFindUniqueArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Foto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FotoFindUniqueOrThrowArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Foto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindFirstArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoFindFirstArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Foto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindFirstOrThrowArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fotos
     * const fotos = await prisma.foto.findMany()
     * 
     * // Get first 10 Fotos
     * const fotos = await prisma.foto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fotoWithIdOnly = await prisma.foto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Foto.
     * @param {FotoCreateArgs} args - Arguments to create a Foto.
     * @example
     * // Create one Foto
     * const Foto = await prisma.foto.create({
     *   data: {
     *     // ... data to create a Foto
     *   }
     * })
     * 
    **/
    create<T extends FotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FotoCreateArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Fotos.
     *     @param {FotoCreateManyArgs} args - Arguments to create many Fotos.
     *     @example
     *     // Create many Fotos
     *     const foto = await prisma.foto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Foto.
     * @param {FotoDeleteArgs} args - Arguments to delete one Foto.
     * @example
     * // Delete one Foto
     * const Foto = await prisma.foto.delete({
     *   where: {
     *     // ... filter to delete one Foto
     *   }
     * })
     * 
    **/
    delete<T extends FotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FotoDeleteArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Foto.
     * @param {FotoUpdateArgs} args - Arguments to update one Foto.
     * @example
     * // Update one Foto
     * const foto = await prisma.foto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FotoUpdateArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fotos.
     * @param {FotoDeleteManyArgs} args - Arguments to filter Fotos to delete.
     * @example
     * // Delete a few Fotos
     * const { count } = await prisma.foto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fotos
     * const foto = await prisma.foto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foto.
     * @param {FotoUpsertArgs} args - Arguments to update or create a Foto.
     * @example
     * // Update or create a Foto
     * const foto = await prisma.foto.upsert({
     *   create: {
     *     // ... data to create a Foto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foto we want to update
     *   }
     * })
    **/
    upsert<T extends FotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FotoUpsertArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoCountArgs} args - Arguments to filter Fotos to count.
     * @example
     * // Count the number of Fotos
     * const count = await prisma.foto.count({
     *   where: {
     *     // ... the filter for the Fotos we want to count
     *   }
     * })
    **/
    count<T extends FotoCountArgs>(
      args?: Subset<T, FotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FotoAggregateArgs>(args: Subset<T, FotoAggregateArgs>): Prisma.PrismaPromise<GetFotoAggregateType<T>>

    /**
     * Group by Foto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FotoGroupByArgs['orderBy'] }
        : { orderBy?: FotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Foto model
   */
  readonly fields: FotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Foto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    productos<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Foto model
   */ 
  interface FotoFieldRefs {
    readonly id: FieldRef<"Foto", 'Int'>
    readonly idProducto: FieldRef<"Foto", 'Int'>
    readonly foto: FieldRef<"Foto", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * Foto findUnique
   */
  export type FotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Foto to fetch.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto findUniqueOrThrow
   */
  export type FotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Foto to fetch.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto findFirst
   */
  export type FotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Foto to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fotos.
     */
    distinct?: FotoScalarFieldEnum | FotoScalarFieldEnum[]
  }


  /**
   * Foto findFirstOrThrow
   */
  export type FotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Foto to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fotos.
     */
    distinct?: FotoScalarFieldEnum | FotoScalarFieldEnum[]
  }


  /**
   * Foto findMany
   */
  export type FotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Fotos to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    distinct?: FotoScalarFieldEnum | FotoScalarFieldEnum[]
  }


  /**
   * Foto create
   */
  export type FotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Foto.
     */
    data: XOR<FotoCreateInput, FotoUncheckedCreateInput>
  }


  /**
   * Foto createMany
   */
  export type FotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fotos.
     */
    data: FotoCreateManyInput | FotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Foto update
   */
  export type FotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Foto.
     */
    data: XOR<FotoUpdateInput, FotoUncheckedUpdateInput>
    /**
     * Choose, which Foto to update.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto updateMany
   */
  export type FotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fotos.
     */
    data: XOR<FotoUpdateManyMutationInput, FotoUncheckedUpdateManyInput>
    /**
     * Filter which Fotos to update
     */
    where?: FotoWhereInput
  }


  /**
   * Foto upsert
   */
  export type FotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Foto to update in case it exists.
     */
    where: FotoWhereUniqueInput
    /**
     * In case the Foto found by the `where` argument doesn't exist, create a new Foto with this data.
     */
    create: XOR<FotoCreateInput, FotoUncheckedCreateInput>
    /**
     * In case the Foto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FotoUpdateInput, FotoUncheckedUpdateInput>
  }


  /**
   * Foto delete
   */
  export type FotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter which Foto to delete.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto deleteMany
   */
  export type FotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fotos to delete
     */
    where?: FotoWhereInput
  }


  /**
   * Foto without action
   */
  export type FotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
  }



  /**
   * Model Ubicacion
   */

  export type AggregateUbicacion = {
    _count: UbicacionCountAggregateOutputType | null
    _avg: UbicacionAvgAggregateOutputType | null
    _sum: UbicacionSumAggregateOutputType | null
    _min: UbicacionMinAggregateOutputType | null
    _max: UbicacionMaxAggregateOutputType | null
  }

  export type UbicacionAvgAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
    idBarrio: number | null
  }

  export type UbicacionSumAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
    idBarrio: number | null
  }

  export type UbicacionMinAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
    idBarrio: number | null
  }

  export type UbicacionMaxAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
    idBarrio: number | null
  }

  export type UbicacionCountAggregateOutputType = {
    id: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    _all: number
  }


  export type UbicacionAvgAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    idBarrio?: true
  }

  export type UbicacionSumAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    idBarrio?: true
  }

  export type UbicacionMinAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    idBarrio?: true
  }

  export type UbicacionMaxAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    idBarrio?: true
  }

  export type UbicacionCountAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    idBarrio?: true
    _all?: true
  }

  export type UbicacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ubicacion to aggregate.
     */
    where?: UbicacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ubicacions to fetch.
     */
    orderBy?: UbicacionOrderByWithRelationInput | UbicacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UbicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ubicacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ubicacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ubicacions
    **/
    _count?: true | UbicacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UbicacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UbicacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UbicacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UbicacionMaxAggregateInputType
  }

  export type GetUbicacionAggregateType<T extends UbicacionAggregateArgs> = {
        [P in keyof T & keyof AggregateUbicacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUbicacion[P]>
      : GetScalarType<T[P], AggregateUbicacion[P]>
  }




  export type UbicacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UbicacionWhereInput
    orderBy?: UbicacionOrderByWithAggregationInput | UbicacionOrderByWithAggregationInput[]
    by: UbicacionScalarFieldEnum[] | UbicacionScalarFieldEnum
    having?: UbicacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UbicacionCountAggregateInputType | true
    _avg?: UbicacionAvgAggregateInputType
    _sum?: UbicacionSumAggregateInputType
    _min?: UbicacionMinAggregateInputType
    _max?: UbicacionMaxAggregateInputType
  }

  export type UbicacionGroupByOutputType = {
    id: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    _count: UbicacionCountAggregateOutputType | null
    _avg: UbicacionAvgAggregateOutputType | null
    _sum: UbicacionSumAggregateOutputType | null
    _min: UbicacionMinAggregateOutputType | null
    _max: UbicacionMaxAggregateOutputType | null
  }

  type GetUbicacionGroupByPayload<T extends UbicacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UbicacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UbicacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UbicacionGroupByOutputType[P]>
            : GetScalarType<T[P], UbicacionGroupByOutputType[P]>
        }
      >
    >


  export type UbicacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProvincia?: boolean
    idCanton?: boolean
    idDistrito?: boolean
    idBarrio?: boolean
    usuario?: boolean | Ubicacion$usuarioArgs<ExtArgs>
    bodega?: boolean | Ubicacion$bodegaArgs<ExtArgs>
    provincia?: boolean | Ubicacion$provinciaArgs<ExtArgs>
    cantones?: boolean | Ubicacion$cantonesArgs<ExtArgs>
    distritos?: boolean | Ubicacion$distritosArgs<ExtArgs>
    barrios?: boolean | Ubicacion$barriosArgs<ExtArgs>
    _count?: boolean | UbicacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ubicacion"]>

  export type UbicacionSelectScalar = {
    id?: boolean
    idProvincia?: boolean
    idCanton?: boolean
    idDistrito?: boolean
    idBarrio?: boolean
  }

  export type UbicacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | Ubicacion$usuarioArgs<ExtArgs>
    bodega?: boolean | Ubicacion$bodegaArgs<ExtArgs>
    provincia?: boolean | Ubicacion$provinciaArgs<ExtArgs>
    cantones?: boolean | Ubicacion$cantonesArgs<ExtArgs>
    distritos?: boolean | Ubicacion$distritosArgs<ExtArgs>
    barrios?: boolean | Ubicacion$barriosArgs<ExtArgs>
    _count?: boolean | UbicacionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UbicacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ubicacion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>[]
      bodega: Prisma.$BodegaPayload<ExtArgs>[]
      provincia: Prisma.$ProvinciaPayload<ExtArgs>[]
      cantones: Prisma.$CantonPayload<ExtArgs>[]
      distritos: Prisma.$DistritoPayload<ExtArgs>[]
      barrios: Prisma.$BarrioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idProvincia: number
      idCanton: number
      idDistrito: number
      idBarrio: number
    }, ExtArgs["result"]["ubicacion"]>
    composites: {}
  }


  type UbicacionGetPayload<S extends boolean | null | undefined | UbicacionDefaultArgs> = $Result.GetResult<Prisma.$UbicacionPayload, S>

  type UbicacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UbicacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UbicacionCountAggregateInputType | true
    }

  export interface UbicacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ubicacion'], meta: { name: 'Ubicacion' } }
    /**
     * Find zero or one Ubicacion that matches the filter.
     * @param {UbicacionFindUniqueArgs} args - Arguments to find a Ubicacion
     * @example
     * // Get one Ubicacion
     * const ubicacion = await prisma.ubicacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UbicacionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionFindUniqueArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ubicacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UbicacionFindUniqueOrThrowArgs} args - Arguments to find a Ubicacion
     * @example
     * // Get one Ubicacion
     * const ubicacion = await prisma.ubicacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UbicacionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ubicacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionFindFirstArgs} args - Arguments to find a Ubicacion
     * @example
     * // Get one Ubicacion
     * const ubicacion = await prisma.ubicacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UbicacionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionFindFirstArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ubicacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionFindFirstOrThrowArgs} args - Arguments to find a Ubicacion
     * @example
     * // Get one Ubicacion
     * const ubicacion = await prisma.ubicacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UbicacionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ubicacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ubicacions
     * const ubicacions = await prisma.ubicacion.findMany()
     * 
     * // Get first 10 Ubicacions
     * const ubicacions = await prisma.ubicacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ubicacionWithIdOnly = await prisma.ubicacion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UbicacionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ubicacion.
     * @param {UbicacionCreateArgs} args - Arguments to create a Ubicacion.
     * @example
     * // Create one Ubicacion
     * const Ubicacion = await prisma.ubicacion.create({
     *   data: {
     *     // ... data to create a Ubicacion
     *   }
     * })
     * 
    **/
    create<T extends UbicacionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionCreateArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ubicacions.
     *     @param {UbicacionCreateManyArgs} args - Arguments to create many Ubicacions.
     *     @example
     *     // Create many Ubicacions
     *     const ubicacion = await prisma.ubicacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UbicacionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ubicacion.
     * @param {UbicacionDeleteArgs} args - Arguments to delete one Ubicacion.
     * @example
     * // Delete one Ubicacion
     * const Ubicacion = await prisma.ubicacion.delete({
     *   where: {
     *     // ... filter to delete one Ubicacion
     *   }
     * })
     * 
    **/
    delete<T extends UbicacionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionDeleteArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ubicacion.
     * @param {UbicacionUpdateArgs} args - Arguments to update one Ubicacion.
     * @example
     * // Update one Ubicacion
     * const ubicacion = await prisma.ubicacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UbicacionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionUpdateArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ubicacions.
     * @param {UbicacionDeleteManyArgs} args - Arguments to filter Ubicacions to delete.
     * @example
     * // Delete a few Ubicacions
     * const { count } = await prisma.ubicacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UbicacionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ubicacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ubicacions
     * const ubicacion = await prisma.ubicacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UbicacionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ubicacion.
     * @param {UbicacionUpsertArgs} args - Arguments to update or create a Ubicacion.
     * @example
     * // Update or create a Ubicacion
     * const ubicacion = await prisma.ubicacion.upsert({
     *   create: {
     *     // ... data to create a Ubicacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ubicacion we want to update
     *   }
     * })
    **/
    upsert<T extends UbicacionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionUpsertArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ubicacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionCountArgs} args - Arguments to filter Ubicacions to count.
     * @example
     * // Count the number of Ubicacions
     * const count = await prisma.ubicacion.count({
     *   where: {
     *     // ... the filter for the Ubicacions we want to count
     *   }
     * })
    **/
    count<T extends UbicacionCountArgs>(
      args?: Subset<T, UbicacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UbicacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ubicacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UbicacionAggregateArgs>(args: Subset<T, UbicacionAggregateArgs>): Prisma.PrismaPromise<GetUbicacionAggregateType<T>>

    /**
     * Group by Ubicacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UbicacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UbicacionGroupByArgs['orderBy'] }
        : { orderBy?: UbicacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UbicacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUbicacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ubicacion model
   */
  readonly fields: UbicacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ubicacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UbicacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuario<T extends Ubicacion$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Ubicacion$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    bodega<T extends Ubicacion$bodegaArgs<ExtArgs> = {}>(args?: Subset<T, Ubicacion$bodegaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findMany'> | Null>;

    provincia<T extends Ubicacion$provinciaArgs<ExtArgs> = {}>(args?: Subset<T, Ubicacion$provinciaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findMany'> | Null>;

    cantones<T extends Ubicacion$cantonesArgs<ExtArgs> = {}>(args?: Subset<T, Ubicacion$cantonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findMany'> | Null>;

    distritos<T extends Ubicacion$distritosArgs<ExtArgs> = {}>(args?: Subset<T, Ubicacion$distritosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findMany'> | Null>;

    barrios<T extends Ubicacion$barriosArgs<ExtArgs> = {}>(args?: Subset<T, Ubicacion$barriosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ubicacion model
   */ 
  interface UbicacionFieldRefs {
    readonly id: FieldRef<"Ubicacion", 'Int'>
    readonly idProvincia: FieldRef<"Ubicacion", 'Int'>
    readonly idCanton: FieldRef<"Ubicacion", 'Int'>
    readonly idDistrito: FieldRef<"Ubicacion", 'Int'>
    readonly idBarrio: FieldRef<"Ubicacion", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Ubicacion findUnique
   */
  export type UbicacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacion to fetch.
     */
    where: UbicacionWhereUniqueInput
  }


  /**
   * Ubicacion findUniqueOrThrow
   */
  export type UbicacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacion to fetch.
     */
    where: UbicacionWhereUniqueInput
  }


  /**
   * Ubicacion findFirst
   */
  export type UbicacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacion to fetch.
     */
    where?: UbicacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ubicacions to fetch.
     */
    orderBy?: UbicacionOrderByWithRelationInput | UbicacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ubicacions.
     */
    cursor?: UbicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ubicacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ubicacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ubicacions.
     */
    distinct?: UbicacionScalarFieldEnum | UbicacionScalarFieldEnum[]
  }


  /**
   * Ubicacion findFirstOrThrow
   */
  export type UbicacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacion to fetch.
     */
    where?: UbicacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ubicacions to fetch.
     */
    orderBy?: UbicacionOrderByWithRelationInput | UbicacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ubicacions.
     */
    cursor?: UbicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ubicacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ubicacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ubicacions.
     */
    distinct?: UbicacionScalarFieldEnum | UbicacionScalarFieldEnum[]
  }


  /**
   * Ubicacion findMany
   */
  export type UbicacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacions to fetch.
     */
    where?: UbicacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ubicacions to fetch.
     */
    orderBy?: UbicacionOrderByWithRelationInput | UbicacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ubicacions.
     */
    cursor?: UbicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ubicacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ubicacions.
     */
    skip?: number
    distinct?: UbicacionScalarFieldEnum | UbicacionScalarFieldEnum[]
  }


  /**
   * Ubicacion create
   */
  export type UbicacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Ubicacion.
     */
    data: XOR<UbicacionCreateInput, UbicacionUncheckedCreateInput>
  }


  /**
   * Ubicacion createMany
   */
  export type UbicacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ubicacions.
     */
    data: UbicacionCreateManyInput | UbicacionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ubicacion update
   */
  export type UbicacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Ubicacion.
     */
    data: XOR<UbicacionUpdateInput, UbicacionUncheckedUpdateInput>
    /**
     * Choose, which Ubicacion to update.
     */
    where: UbicacionWhereUniqueInput
  }


  /**
   * Ubicacion updateMany
   */
  export type UbicacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ubicacions.
     */
    data: XOR<UbicacionUpdateManyMutationInput, UbicacionUncheckedUpdateManyInput>
    /**
     * Filter which Ubicacions to update
     */
    where?: UbicacionWhereInput
  }


  /**
   * Ubicacion upsert
   */
  export type UbicacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Ubicacion to update in case it exists.
     */
    where: UbicacionWhereUniqueInput
    /**
     * In case the Ubicacion found by the `where` argument doesn't exist, create a new Ubicacion with this data.
     */
    create: XOR<UbicacionCreateInput, UbicacionUncheckedCreateInput>
    /**
     * In case the Ubicacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UbicacionUpdateInput, UbicacionUncheckedUpdateInput>
  }


  /**
   * Ubicacion delete
   */
  export type UbicacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter which Ubicacion to delete.
     */
    where: UbicacionWhereUniqueInput
  }


  /**
   * Ubicacion deleteMany
   */
  export type UbicacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ubicacions to delete
     */
    where?: UbicacionWhereInput
  }


  /**
   * Ubicacion.usuario
   */
  export type Ubicacion$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Ubicacion.bodega
   */
  export type Ubicacion$bodegaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    where?: BodegaWhereInput
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    cursor?: BodegaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BodegaScalarFieldEnum | BodegaScalarFieldEnum[]
  }


  /**
   * Ubicacion.provincia
   */
  export type Ubicacion$provinciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    where?: ProvinciaWhereInput
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    cursor?: ProvinciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }


  /**
   * Ubicacion.cantones
   */
  export type Ubicacion$cantonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    where?: CantonWhereInput
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    cursor?: CantonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CantonScalarFieldEnum | CantonScalarFieldEnum[]
  }


  /**
   * Ubicacion.distritos
   */
  export type Ubicacion$distritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    where?: DistritoWhereInput
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    cursor?: DistritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }


  /**
   * Ubicacion.barrios
   */
  export type Ubicacion$barriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    where?: BarrioWhereInput
    orderBy?: BarrioOrderByWithRelationInput | BarrioOrderByWithRelationInput[]
    cursor?: BarrioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarrioScalarFieldEnum | BarrioScalarFieldEnum[]
  }


  /**
   * Ubicacion without action
   */
  export type UbicacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
  }



  /**
   * Model Provincia
   */

  export type AggregateProvincia = {
    _count: ProvinciaCountAggregateOutputType | null
    _avg: ProvinciaAvgAggregateOutputType | null
    _sum: ProvinciaSumAggregateOutputType | null
    _min: ProvinciaMinAggregateOutputType | null
    _max: ProvinciaMaxAggregateOutputType | null
  }

  export type ProvinciaAvgAggregateOutputType = {
    id: number | null
  }

  export type ProvinciaSumAggregateOutputType = {
    id: number | null
  }

  export type ProvinciaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type ProvinciaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type ProvinciaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type ProvinciaAvgAggregateInputType = {
    id?: true
  }

  export type ProvinciaSumAggregateInputType = {
    id?: true
  }

  export type ProvinciaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type ProvinciaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type ProvinciaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type ProvinciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provincia to aggregate.
     */
    where?: ProvinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provincias to fetch.
     */
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provincias
    **/
    _count?: true | ProvinciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinciaMaxAggregateInputType
  }

  export type GetProvinciaAggregateType<T extends ProvinciaAggregateArgs> = {
        [P in keyof T & keyof AggregateProvincia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvincia[P]>
      : GetScalarType<T[P], AggregateProvincia[P]>
  }




  export type ProvinciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinciaWhereInput
    orderBy?: ProvinciaOrderByWithAggregationInput | ProvinciaOrderByWithAggregationInput[]
    by: ProvinciaScalarFieldEnum[] | ProvinciaScalarFieldEnum
    having?: ProvinciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinciaCountAggregateInputType | true
    _avg?: ProvinciaAvgAggregateInputType
    _sum?: ProvinciaSumAggregateInputType
    _min?: ProvinciaMinAggregateInputType
    _max?: ProvinciaMaxAggregateInputType
  }

  export type ProvinciaGroupByOutputType = {
    id: number
    nombre: string
    _count: ProvinciaCountAggregateOutputType | null
    _avg: ProvinciaAvgAggregateOutputType | null
    _sum: ProvinciaSumAggregateOutputType | null
    _min: ProvinciaMinAggregateOutputType | null
    _max: ProvinciaMaxAggregateOutputType | null
  }

  type GetProvinciaGroupByPayload<T extends ProvinciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinciaGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinciaGroupByOutputType[P]>
        }
      >
    >


  export type ProvinciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    cantones?: boolean | Provincia$cantonesArgs<ExtArgs>
    distritos?: boolean | Provincia$distritosArgs<ExtArgs>
    barrios?: boolean | Provincia$barriosArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    _count?: boolean | ProvinciaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provincia"]>

  export type ProvinciaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type ProvinciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cantones?: boolean | Provincia$cantonesArgs<ExtArgs>
    distritos?: boolean | Provincia$distritosArgs<ExtArgs>
    barrios?: boolean | Provincia$barriosArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    _count?: boolean | ProvinciaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProvinciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provincia"
    objects: {
      cantones: Prisma.$CantonPayload<ExtArgs>[]
      distritos: Prisma.$DistritoPayload<ExtArgs>[]
      barrios: Prisma.$BarrioPayload<ExtArgs>[]
      ubicacion: Prisma.$UbicacionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["provincia"]>
    composites: {}
  }


  type ProvinciaGetPayload<S extends boolean | null | undefined | ProvinciaDefaultArgs> = $Result.GetResult<Prisma.$ProvinciaPayload, S>

  type ProvinciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProvinciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProvinciaCountAggregateInputType | true
    }

  export interface ProvinciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provincia'], meta: { name: 'Provincia' } }
    /**
     * Find zero or one Provincia that matches the filter.
     * @param {ProvinciaFindUniqueArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProvinciaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProvinciaFindUniqueArgs<ExtArgs>>
    ): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Provincia that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProvinciaFindUniqueOrThrowArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProvinciaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvinciaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Provincia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaFindFirstArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProvinciaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvinciaFindFirstArgs<ExtArgs>>
    ): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Provincia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaFindFirstOrThrowArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProvinciaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvinciaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Provincias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provincias
     * const provincias = await prisma.provincia.findMany()
     * 
     * // Get first 10 Provincias
     * const provincias = await prisma.provincia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provinciaWithIdOnly = await prisma.provincia.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProvinciaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvinciaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Provincia.
     * @param {ProvinciaCreateArgs} args - Arguments to create a Provincia.
     * @example
     * // Create one Provincia
     * const Provincia = await prisma.provincia.create({
     *   data: {
     *     // ... data to create a Provincia
     *   }
     * })
     * 
    **/
    create<T extends ProvinciaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProvinciaCreateArgs<ExtArgs>>
    ): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Provincias.
     *     @param {ProvinciaCreateManyArgs} args - Arguments to create many Provincias.
     *     @example
     *     // Create many Provincias
     *     const provincia = await prisma.provincia.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProvinciaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvinciaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Provincia.
     * @param {ProvinciaDeleteArgs} args - Arguments to delete one Provincia.
     * @example
     * // Delete one Provincia
     * const Provincia = await prisma.provincia.delete({
     *   where: {
     *     // ... filter to delete one Provincia
     *   }
     * })
     * 
    **/
    delete<T extends ProvinciaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProvinciaDeleteArgs<ExtArgs>>
    ): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Provincia.
     * @param {ProvinciaUpdateArgs} args - Arguments to update one Provincia.
     * @example
     * // Update one Provincia
     * const provincia = await prisma.provincia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProvinciaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProvinciaUpdateArgs<ExtArgs>>
    ): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Provincias.
     * @param {ProvinciaDeleteManyArgs} args - Arguments to filter Provincias to delete.
     * @example
     * // Delete a few Provincias
     * const { count } = await prisma.provincia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProvinciaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvinciaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provincias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provincias
     * const provincia = await prisma.provincia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProvinciaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProvinciaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provincia.
     * @param {ProvinciaUpsertArgs} args - Arguments to update or create a Provincia.
     * @example
     * // Update or create a Provincia
     * const provincia = await prisma.provincia.upsert({
     *   create: {
     *     // ... data to create a Provincia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provincia we want to update
     *   }
     * })
    **/
    upsert<T extends ProvinciaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProvinciaUpsertArgs<ExtArgs>>
    ): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Provincias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaCountArgs} args - Arguments to filter Provincias to count.
     * @example
     * // Count the number of Provincias
     * const count = await prisma.provincia.count({
     *   where: {
     *     // ... the filter for the Provincias we want to count
     *   }
     * })
    **/
    count<T extends ProvinciaCountArgs>(
      args?: Subset<T, ProvinciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provincia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinciaAggregateArgs>(args: Subset<T, ProvinciaAggregateArgs>): Prisma.PrismaPromise<GetProvinciaAggregateType<T>>

    /**
     * Group by Provincia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinciaGroupByArgs['orderBy'] }
        : { orderBy?: ProvinciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provincia model
   */
  readonly fields: ProvinciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provincia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvinciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cantones<T extends Provincia$cantonesArgs<ExtArgs> = {}>(args?: Subset<T, Provincia$cantonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findMany'> | Null>;

    distritos<T extends Provincia$distritosArgs<ExtArgs> = {}>(args?: Subset<T, Provincia$distritosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findMany'> | Null>;

    barrios<T extends Provincia$barriosArgs<ExtArgs> = {}>(args?: Subset<T, Provincia$barriosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findMany'> | Null>;

    ubicacion<T extends UbicacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UbicacionDefaultArgs<ExtArgs>>): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Provincia model
   */ 
  interface ProvinciaFieldRefs {
    readonly id: FieldRef<"Provincia", 'Int'>
    readonly nombre: FieldRef<"Provincia", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Provincia findUnique
   */
  export type ProvinciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincia to fetch.
     */
    where: ProvinciaWhereUniqueInput
  }


  /**
   * Provincia findUniqueOrThrow
   */
  export type ProvinciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincia to fetch.
     */
    where: ProvinciaWhereUniqueInput
  }


  /**
   * Provincia findFirst
   */
  export type ProvinciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincia to fetch.
     */
    where?: ProvinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provincias to fetch.
     */
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provincias.
     */
    cursor?: ProvinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provincias.
     */
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }


  /**
   * Provincia findFirstOrThrow
   */
  export type ProvinciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincia to fetch.
     */
    where?: ProvinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provincias to fetch.
     */
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provincias.
     */
    cursor?: ProvinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provincias.
     */
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }


  /**
   * Provincia findMany
   */
  export type ProvinciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincias to fetch.
     */
    where?: ProvinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provincias to fetch.
     */
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provincias.
     */
    cursor?: ProvinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provincias.
     */
    skip?: number
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }


  /**
   * Provincia create
   */
  export type ProvinciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Provincia.
     */
    data: XOR<ProvinciaCreateInput, ProvinciaUncheckedCreateInput>
  }


  /**
   * Provincia createMany
   */
  export type ProvinciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Provincias.
     */
    data: ProvinciaCreateManyInput | ProvinciaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Provincia update
   */
  export type ProvinciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Provincia.
     */
    data: XOR<ProvinciaUpdateInput, ProvinciaUncheckedUpdateInput>
    /**
     * Choose, which Provincia to update.
     */
    where: ProvinciaWhereUniqueInput
  }


  /**
   * Provincia updateMany
   */
  export type ProvinciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Provincias.
     */
    data: XOR<ProvinciaUpdateManyMutationInput, ProvinciaUncheckedUpdateManyInput>
    /**
     * Filter which Provincias to update
     */
    where?: ProvinciaWhereInput
  }


  /**
   * Provincia upsert
   */
  export type ProvinciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Provincia to update in case it exists.
     */
    where: ProvinciaWhereUniqueInput
    /**
     * In case the Provincia found by the `where` argument doesn't exist, create a new Provincia with this data.
     */
    create: XOR<ProvinciaCreateInput, ProvinciaUncheckedCreateInput>
    /**
     * In case the Provincia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvinciaUpdateInput, ProvinciaUncheckedUpdateInput>
  }


  /**
   * Provincia delete
   */
  export type ProvinciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter which Provincia to delete.
     */
    where: ProvinciaWhereUniqueInput
  }


  /**
   * Provincia deleteMany
   */
  export type ProvinciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provincias to delete
     */
    where?: ProvinciaWhereInput
  }


  /**
   * Provincia.cantones
   */
  export type Provincia$cantonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    where?: CantonWhereInput
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    cursor?: CantonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CantonScalarFieldEnum | CantonScalarFieldEnum[]
  }


  /**
   * Provincia.distritos
   */
  export type Provincia$distritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    where?: DistritoWhereInput
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    cursor?: DistritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }


  /**
   * Provincia.barrios
   */
  export type Provincia$barriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    where?: BarrioWhereInput
    orderBy?: BarrioOrderByWithRelationInput | BarrioOrderByWithRelationInput[]
    cursor?: BarrioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarrioScalarFieldEnum | BarrioScalarFieldEnum[]
  }


  /**
   * Provincia without action
   */
  export type ProvinciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvinciaInclude<ExtArgs> | null
  }



  /**
   * Model Canton
   */

  export type AggregateCanton = {
    _count: CantonCountAggregateOutputType | null
    _avg: CantonAvgAggregateOutputType | null
    _sum: CantonSumAggregateOutputType | null
    _min: CantonMinAggregateOutputType | null
    _max: CantonMaxAggregateOutputType | null
  }

  export type CantonAvgAggregateOutputType = {
    id: number | null
    idProvincia: number | null
  }

  export type CantonSumAggregateOutputType = {
    id: number | null
    idProvincia: number | null
  }

  export type CantonMinAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    nombre: string | null
  }

  export type CantonMaxAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    nombre: string | null
  }

  export type CantonCountAggregateOutputType = {
    id: number
    idProvincia: number
    nombre: number
    _all: number
  }


  export type CantonAvgAggregateInputType = {
    id?: true
    idProvincia?: true
  }

  export type CantonSumAggregateInputType = {
    id?: true
    idProvincia?: true
  }

  export type CantonMinAggregateInputType = {
    id?: true
    idProvincia?: true
    nombre?: true
  }

  export type CantonMaxAggregateInputType = {
    id?: true
    idProvincia?: true
    nombre?: true
  }

  export type CantonCountAggregateInputType = {
    id?: true
    idProvincia?: true
    nombre?: true
    _all?: true
  }

  export type CantonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canton to aggregate.
     */
    where?: CantonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cantons to fetch.
     */
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CantonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cantons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cantons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cantons
    **/
    _count?: true | CantonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CantonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CantonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CantonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CantonMaxAggregateInputType
  }

  export type GetCantonAggregateType<T extends CantonAggregateArgs> = {
        [P in keyof T & keyof AggregateCanton]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanton[P]>
      : GetScalarType<T[P], AggregateCanton[P]>
  }




  export type CantonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CantonWhereInput
    orderBy?: CantonOrderByWithAggregationInput | CantonOrderByWithAggregationInput[]
    by: CantonScalarFieldEnum[] | CantonScalarFieldEnum
    having?: CantonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CantonCountAggregateInputType | true
    _avg?: CantonAvgAggregateInputType
    _sum?: CantonSumAggregateInputType
    _min?: CantonMinAggregateInputType
    _max?: CantonMaxAggregateInputType
  }

  export type CantonGroupByOutputType = {
    id: number
    idProvincia: number
    nombre: string
    _count: CantonCountAggregateOutputType | null
    _avg: CantonAvgAggregateOutputType | null
    _sum: CantonSumAggregateOutputType | null
    _min: CantonMinAggregateOutputType | null
    _max: CantonMaxAggregateOutputType | null
  }

  type GetCantonGroupByPayload<T extends CantonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CantonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CantonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CantonGroupByOutputType[P]>
            : GetScalarType<T[P], CantonGroupByOutputType[P]>
        }
      >
    >


  export type CantonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProvincia?: boolean
    nombre?: boolean
    provincias?: boolean | ProvinciaDefaultArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    distritos?: boolean | Canton$distritosArgs<ExtArgs>
    barrios?: boolean | Canton$barriosArgs<ExtArgs>
    _count?: boolean | CantonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canton"]>

  export type CantonSelectScalar = {
    id?: boolean
    idProvincia?: boolean
    nombre?: boolean
  }

  export type CantonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provincias?: boolean | ProvinciaDefaultArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    distritos?: boolean | Canton$distritosArgs<ExtArgs>
    barrios?: boolean | Canton$barriosArgs<ExtArgs>
    _count?: boolean | CantonCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CantonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Canton"
    objects: {
      provincias: Prisma.$ProvinciaPayload<ExtArgs>
      ubicacion: Prisma.$UbicacionPayload<ExtArgs>
      distritos: Prisma.$DistritoPayload<ExtArgs>[]
      barrios: Prisma.$BarrioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idProvincia: number
      nombre: string
    }, ExtArgs["result"]["canton"]>
    composites: {}
  }


  type CantonGetPayload<S extends boolean | null | undefined | CantonDefaultArgs> = $Result.GetResult<Prisma.$CantonPayload, S>

  type CantonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CantonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CantonCountAggregateInputType | true
    }

  export interface CantonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Canton'], meta: { name: 'Canton' } }
    /**
     * Find zero or one Canton that matches the filter.
     * @param {CantonFindUniqueArgs} args - Arguments to find a Canton
     * @example
     * // Get one Canton
     * const canton = await prisma.canton.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CantonFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CantonFindUniqueArgs<ExtArgs>>
    ): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Canton that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CantonFindUniqueOrThrowArgs} args - Arguments to find a Canton
     * @example
     * // Get one Canton
     * const canton = await prisma.canton.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CantonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CantonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Canton that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonFindFirstArgs} args - Arguments to find a Canton
     * @example
     * // Get one Canton
     * const canton = await prisma.canton.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CantonFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CantonFindFirstArgs<ExtArgs>>
    ): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Canton that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonFindFirstOrThrowArgs} args - Arguments to find a Canton
     * @example
     * // Get one Canton
     * const canton = await prisma.canton.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CantonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CantonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cantons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cantons
     * const cantons = await prisma.canton.findMany()
     * 
     * // Get first 10 Cantons
     * const cantons = await prisma.canton.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cantonWithIdOnly = await prisma.canton.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CantonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CantonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Canton.
     * @param {CantonCreateArgs} args - Arguments to create a Canton.
     * @example
     * // Create one Canton
     * const Canton = await prisma.canton.create({
     *   data: {
     *     // ... data to create a Canton
     *   }
     * })
     * 
    **/
    create<T extends CantonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CantonCreateArgs<ExtArgs>>
    ): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cantons.
     *     @param {CantonCreateManyArgs} args - Arguments to create many Cantons.
     *     @example
     *     // Create many Cantons
     *     const canton = await prisma.canton.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CantonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CantonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Canton.
     * @param {CantonDeleteArgs} args - Arguments to delete one Canton.
     * @example
     * // Delete one Canton
     * const Canton = await prisma.canton.delete({
     *   where: {
     *     // ... filter to delete one Canton
     *   }
     * })
     * 
    **/
    delete<T extends CantonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CantonDeleteArgs<ExtArgs>>
    ): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Canton.
     * @param {CantonUpdateArgs} args - Arguments to update one Canton.
     * @example
     * // Update one Canton
     * const canton = await prisma.canton.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CantonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CantonUpdateArgs<ExtArgs>>
    ): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cantons.
     * @param {CantonDeleteManyArgs} args - Arguments to filter Cantons to delete.
     * @example
     * // Delete a few Cantons
     * const { count } = await prisma.canton.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CantonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CantonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cantons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cantons
     * const canton = await prisma.canton.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CantonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CantonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Canton.
     * @param {CantonUpsertArgs} args - Arguments to update or create a Canton.
     * @example
     * // Update or create a Canton
     * const canton = await prisma.canton.upsert({
     *   create: {
     *     // ... data to create a Canton
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Canton we want to update
     *   }
     * })
    **/
    upsert<T extends CantonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CantonUpsertArgs<ExtArgs>>
    ): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cantons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonCountArgs} args - Arguments to filter Cantons to count.
     * @example
     * // Count the number of Cantons
     * const count = await prisma.canton.count({
     *   where: {
     *     // ... the filter for the Cantons we want to count
     *   }
     * })
    **/
    count<T extends CantonCountArgs>(
      args?: Subset<T, CantonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CantonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Canton.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CantonAggregateArgs>(args: Subset<T, CantonAggregateArgs>): Prisma.PrismaPromise<GetCantonAggregateType<T>>

    /**
     * Group by Canton.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CantonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CantonGroupByArgs['orderBy'] }
        : { orderBy?: CantonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CantonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCantonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Canton model
   */
  readonly fields: CantonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Canton.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CantonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    provincias<T extends ProvinciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinciaDefaultArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ubicacion<T extends UbicacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UbicacionDefaultArgs<ExtArgs>>): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    distritos<T extends Canton$distritosArgs<ExtArgs> = {}>(args?: Subset<T, Canton$distritosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findMany'> | Null>;

    barrios<T extends Canton$barriosArgs<ExtArgs> = {}>(args?: Subset<T, Canton$barriosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Canton model
   */ 
  interface CantonFieldRefs {
    readonly id: FieldRef<"Canton", 'Int'>
    readonly idProvincia: FieldRef<"Canton", 'Int'>
    readonly nombre: FieldRef<"Canton", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Canton findUnique
   */
  export type CantonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Canton to fetch.
     */
    where: CantonWhereUniqueInput
  }


  /**
   * Canton findUniqueOrThrow
   */
  export type CantonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Canton to fetch.
     */
    where: CantonWhereUniqueInput
  }


  /**
   * Canton findFirst
   */
  export type CantonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Canton to fetch.
     */
    where?: CantonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cantons to fetch.
     */
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cantons.
     */
    cursor?: CantonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cantons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cantons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cantons.
     */
    distinct?: CantonScalarFieldEnum | CantonScalarFieldEnum[]
  }


  /**
   * Canton findFirstOrThrow
   */
  export type CantonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Canton to fetch.
     */
    where?: CantonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cantons to fetch.
     */
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cantons.
     */
    cursor?: CantonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cantons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cantons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cantons.
     */
    distinct?: CantonScalarFieldEnum | CantonScalarFieldEnum[]
  }


  /**
   * Canton findMany
   */
  export type CantonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Cantons to fetch.
     */
    where?: CantonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cantons to fetch.
     */
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cantons.
     */
    cursor?: CantonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cantons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cantons.
     */
    skip?: number
    distinct?: CantonScalarFieldEnum | CantonScalarFieldEnum[]
  }


  /**
   * Canton create
   */
  export type CantonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * The data needed to create a Canton.
     */
    data: XOR<CantonCreateInput, CantonUncheckedCreateInput>
  }


  /**
   * Canton createMany
   */
  export type CantonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cantons.
     */
    data: CantonCreateManyInput | CantonCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Canton update
   */
  export type CantonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * The data needed to update a Canton.
     */
    data: XOR<CantonUpdateInput, CantonUncheckedUpdateInput>
    /**
     * Choose, which Canton to update.
     */
    where: CantonWhereUniqueInput
  }


  /**
   * Canton updateMany
   */
  export type CantonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cantons.
     */
    data: XOR<CantonUpdateManyMutationInput, CantonUncheckedUpdateManyInput>
    /**
     * Filter which Cantons to update
     */
    where?: CantonWhereInput
  }


  /**
   * Canton upsert
   */
  export type CantonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * The filter to search for the Canton to update in case it exists.
     */
    where: CantonWhereUniqueInput
    /**
     * In case the Canton found by the `where` argument doesn't exist, create a new Canton with this data.
     */
    create: XOR<CantonCreateInput, CantonUncheckedCreateInput>
    /**
     * In case the Canton was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CantonUpdateInput, CantonUncheckedUpdateInput>
  }


  /**
   * Canton delete
   */
  export type CantonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter which Canton to delete.
     */
    where: CantonWhereUniqueInput
  }


  /**
   * Canton deleteMany
   */
  export type CantonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cantons to delete
     */
    where?: CantonWhereInput
  }


  /**
   * Canton.distritos
   */
  export type Canton$distritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    where?: DistritoWhereInput
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    cursor?: DistritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }


  /**
   * Canton.barrios
   */
  export type Canton$barriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    where?: BarrioWhereInput
    orderBy?: BarrioOrderByWithRelationInput | BarrioOrderByWithRelationInput[]
    cursor?: BarrioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarrioScalarFieldEnum | BarrioScalarFieldEnum[]
  }


  /**
   * Canton without action
   */
  export type CantonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CantonInclude<ExtArgs> | null
  }



  /**
   * Model Distrito
   */

  export type AggregateDistrito = {
    _count: DistritoCountAggregateOutputType | null
    _avg: DistritoAvgAggregateOutputType | null
    _sum: DistritoSumAggregateOutputType | null
    _min: DistritoMinAggregateOutputType | null
    _max: DistritoMaxAggregateOutputType | null
  }

  export type DistritoAvgAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
  }

  export type DistritoSumAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
  }

  export type DistritoMinAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    nombre: string | null
  }

  export type DistritoMaxAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    nombre: string | null
  }

  export type DistritoCountAggregateOutputType = {
    id: number
    idProvincia: number
    idCanton: number
    nombre: number
    _all: number
  }


  export type DistritoAvgAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
  }

  export type DistritoSumAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
  }

  export type DistritoMinAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    nombre?: true
  }

  export type DistritoMaxAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    nombre?: true
  }

  export type DistritoCountAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    nombre?: true
    _all?: true
  }

  export type DistritoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distrito to aggregate.
     */
    where?: DistritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distritos to fetch.
     */
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Distritos
    **/
    _count?: true | DistritoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistritoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistritoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistritoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistritoMaxAggregateInputType
  }

  export type GetDistritoAggregateType<T extends DistritoAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrito[P]>
      : GetScalarType<T[P], AggregateDistrito[P]>
  }




  export type DistritoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistritoWhereInput
    orderBy?: DistritoOrderByWithAggregationInput | DistritoOrderByWithAggregationInput[]
    by: DistritoScalarFieldEnum[] | DistritoScalarFieldEnum
    having?: DistritoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistritoCountAggregateInputType | true
    _avg?: DistritoAvgAggregateInputType
    _sum?: DistritoSumAggregateInputType
    _min?: DistritoMinAggregateInputType
    _max?: DistritoMaxAggregateInputType
  }

  export type DistritoGroupByOutputType = {
    id: number
    idProvincia: number
    idCanton: number
    nombre: string
    _count: DistritoCountAggregateOutputType | null
    _avg: DistritoAvgAggregateOutputType | null
    _sum: DistritoSumAggregateOutputType | null
    _min: DistritoMinAggregateOutputType | null
    _max: DistritoMaxAggregateOutputType | null
  }

  type GetDistritoGroupByPayload<T extends DistritoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistritoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistritoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistritoGroupByOutputType[P]>
            : GetScalarType<T[P], DistritoGroupByOutputType[P]>
        }
      >
    >


  export type DistritoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProvincia?: boolean
    idCanton?: boolean
    nombre?: boolean
    provincias?: boolean | ProvinciaDefaultArgs<ExtArgs>
    cantones?: boolean | CantonDefaultArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    barrios?: boolean | Distrito$barriosArgs<ExtArgs>
    _count?: boolean | DistritoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distrito"]>

  export type DistritoSelectScalar = {
    id?: boolean
    idProvincia?: boolean
    idCanton?: boolean
    nombre?: boolean
  }

  export type DistritoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provincias?: boolean | ProvinciaDefaultArgs<ExtArgs>
    cantones?: boolean | CantonDefaultArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    barrios?: boolean | Distrito$barriosArgs<ExtArgs>
    _count?: boolean | DistritoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DistritoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Distrito"
    objects: {
      provincias: Prisma.$ProvinciaPayload<ExtArgs>
      cantones: Prisma.$CantonPayload<ExtArgs>
      ubicacion: Prisma.$UbicacionPayload<ExtArgs>
      barrios: Prisma.$BarrioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idProvincia: number
      idCanton: number
      nombre: string
    }, ExtArgs["result"]["distrito"]>
    composites: {}
  }


  type DistritoGetPayload<S extends boolean | null | undefined | DistritoDefaultArgs> = $Result.GetResult<Prisma.$DistritoPayload, S>

  type DistritoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistritoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistritoCountAggregateInputType | true
    }

  export interface DistritoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Distrito'], meta: { name: 'Distrito' } }
    /**
     * Find zero or one Distrito that matches the filter.
     * @param {DistritoFindUniqueArgs} args - Arguments to find a Distrito
     * @example
     * // Get one Distrito
     * const distrito = await prisma.distrito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DistritoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DistritoFindUniqueArgs<ExtArgs>>
    ): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Distrito that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DistritoFindUniqueOrThrowArgs} args - Arguments to find a Distrito
     * @example
     * // Get one Distrito
     * const distrito = await prisma.distrito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DistritoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DistritoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Distrito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoFindFirstArgs} args - Arguments to find a Distrito
     * @example
     * // Get one Distrito
     * const distrito = await prisma.distrito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DistritoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DistritoFindFirstArgs<ExtArgs>>
    ): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Distrito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoFindFirstOrThrowArgs} args - Arguments to find a Distrito
     * @example
     * // Get one Distrito
     * const distrito = await prisma.distrito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DistritoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DistritoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Distritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Distritos
     * const distritos = await prisma.distrito.findMany()
     * 
     * // Get first 10 Distritos
     * const distritos = await prisma.distrito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distritoWithIdOnly = await prisma.distrito.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DistritoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistritoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Distrito.
     * @param {DistritoCreateArgs} args - Arguments to create a Distrito.
     * @example
     * // Create one Distrito
     * const Distrito = await prisma.distrito.create({
     *   data: {
     *     // ... data to create a Distrito
     *   }
     * })
     * 
    **/
    create<T extends DistritoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DistritoCreateArgs<ExtArgs>>
    ): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Distritos.
     *     @param {DistritoCreateManyArgs} args - Arguments to create many Distritos.
     *     @example
     *     // Create many Distritos
     *     const distrito = await prisma.distrito.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DistritoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistritoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Distrito.
     * @param {DistritoDeleteArgs} args - Arguments to delete one Distrito.
     * @example
     * // Delete one Distrito
     * const Distrito = await prisma.distrito.delete({
     *   where: {
     *     // ... filter to delete one Distrito
     *   }
     * })
     * 
    **/
    delete<T extends DistritoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DistritoDeleteArgs<ExtArgs>>
    ): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Distrito.
     * @param {DistritoUpdateArgs} args - Arguments to update one Distrito.
     * @example
     * // Update one Distrito
     * const distrito = await prisma.distrito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DistritoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DistritoUpdateArgs<ExtArgs>>
    ): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Distritos.
     * @param {DistritoDeleteManyArgs} args - Arguments to filter Distritos to delete.
     * @example
     * // Delete a few Distritos
     * const { count } = await prisma.distrito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DistritoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistritoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Distritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Distritos
     * const distrito = await prisma.distrito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DistritoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DistritoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Distrito.
     * @param {DistritoUpsertArgs} args - Arguments to update or create a Distrito.
     * @example
     * // Update or create a Distrito
     * const distrito = await prisma.distrito.upsert({
     *   create: {
     *     // ... data to create a Distrito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Distrito we want to update
     *   }
     * })
    **/
    upsert<T extends DistritoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DistritoUpsertArgs<ExtArgs>>
    ): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Distritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoCountArgs} args - Arguments to filter Distritos to count.
     * @example
     * // Count the number of Distritos
     * const count = await prisma.distrito.count({
     *   where: {
     *     // ... the filter for the Distritos we want to count
     *   }
     * })
    **/
    count<T extends DistritoCountArgs>(
      args?: Subset<T, DistritoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistritoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Distrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistritoAggregateArgs>(args: Subset<T, DistritoAggregateArgs>): Prisma.PrismaPromise<GetDistritoAggregateType<T>>

    /**
     * Group by Distrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistritoGroupByArgs['orderBy'] }
        : { orderBy?: DistritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistritoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistritoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Distrito model
   */
  readonly fields: DistritoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Distrito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistritoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    provincias<T extends ProvinciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinciaDefaultArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cantones<T extends CantonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CantonDefaultArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ubicacion<T extends UbicacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UbicacionDefaultArgs<ExtArgs>>): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    barrios<T extends Distrito$barriosArgs<ExtArgs> = {}>(args?: Subset<T, Distrito$barriosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Distrito model
   */ 
  interface DistritoFieldRefs {
    readonly id: FieldRef<"Distrito", 'Int'>
    readonly idProvincia: FieldRef<"Distrito", 'Int'>
    readonly idCanton: FieldRef<"Distrito", 'Int'>
    readonly nombre: FieldRef<"Distrito", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Distrito findUnique
   */
  export type DistritoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distrito to fetch.
     */
    where: DistritoWhereUniqueInput
  }


  /**
   * Distrito findUniqueOrThrow
   */
  export type DistritoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distrito to fetch.
     */
    where: DistritoWhereUniqueInput
  }


  /**
   * Distrito findFirst
   */
  export type DistritoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distrito to fetch.
     */
    where?: DistritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distritos to fetch.
     */
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distritos.
     */
    cursor?: DistritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distritos.
     */
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }


  /**
   * Distrito findFirstOrThrow
   */
  export type DistritoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distrito to fetch.
     */
    where?: DistritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distritos to fetch.
     */
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distritos.
     */
    cursor?: DistritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distritos.
     */
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }


  /**
   * Distrito findMany
   */
  export type DistritoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distritos to fetch.
     */
    where?: DistritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distritos to fetch.
     */
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Distritos.
     */
    cursor?: DistritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distritos.
     */
    skip?: number
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }


  /**
   * Distrito create
   */
  export type DistritoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * The data needed to create a Distrito.
     */
    data: XOR<DistritoCreateInput, DistritoUncheckedCreateInput>
  }


  /**
   * Distrito createMany
   */
  export type DistritoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Distritos.
     */
    data: DistritoCreateManyInput | DistritoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Distrito update
   */
  export type DistritoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * The data needed to update a Distrito.
     */
    data: XOR<DistritoUpdateInput, DistritoUncheckedUpdateInput>
    /**
     * Choose, which Distrito to update.
     */
    where: DistritoWhereUniqueInput
  }


  /**
   * Distrito updateMany
   */
  export type DistritoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Distritos.
     */
    data: XOR<DistritoUpdateManyMutationInput, DistritoUncheckedUpdateManyInput>
    /**
     * Filter which Distritos to update
     */
    where?: DistritoWhereInput
  }


  /**
   * Distrito upsert
   */
  export type DistritoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * The filter to search for the Distrito to update in case it exists.
     */
    where: DistritoWhereUniqueInput
    /**
     * In case the Distrito found by the `where` argument doesn't exist, create a new Distrito with this data.
     */
    create: XOR<DistritoCreateInput, DistritoUncheckedCreateInput>
    /**
     * In case the Distrito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistritoUpdateInput, DistritoUncheckedUpdateInput>
  }


  /**
   * Distrito delete
   */
  export type DistritoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter which Distrito to delete.
     */
    where: DistritoWhereUniqueInput
  }


  /**
   * Distrito deleteMany
   */
  export type DistritoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distritos to delete
     */
    where?: DistritoWhereInput
  }


  /**
   * Distrito.barrios
   */
  export type Distrito$barriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    where?: BarrioWhereInput
    orderBy?: BarrioOrderByWithRelationInput | BarrioOrderByWithRelationInput[]
    cursor?: BarrioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarrioScalarFieldEnum | BarrioScalarFieldEnum[]
  }


  /**
   * Distrito without action
   */
  export type DistritoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistritoInclude<ExtArgs> | null
  }



  /**
   * Model Barrio
   */

  export type AggregateBarrio = {
    _count: BarrioCountAggregateOutputType | null
    _avg: BarrioAvgAggregateOutputType | null
    _sum: BarrioSumAggregateOutputType | null
    _min: BarrioMinAggregateOutputType | null
    _max: BarrioMaxAggregateOutputType | null
  }

  export type BarrioAvgAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
  }

  export type BarrioSumAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
  }

  export type BarrioMinAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
    nombre: string | null
  }

  export type BarrioMaxAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
    nombre: string | null
  }

  export type BarrioCountAggregateOutputType = {
    id: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    nombre: number
    _all: number
  }


  export type BarrioAvgAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
  }

  export type BarrioSumAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
  }

  export type BarrioMinAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    nombre?: true
  }

  export type BarrioMaxAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    nombre?: true
  }

  export type BarrioCountAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    nombre?: true
    _all?: true
  }

  export type BarrioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Barrio to aggregate.
     */
    where?: BarrioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Barrios to fetch.
     */
    orderBy?: BarrioOrderByWithRelationInput | BarrioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarrioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Barrios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Barrios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Barrios
    **/
    _count?: true | BarrioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarrioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarrioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarrioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarrioMaxAggregateInputType
  }

  export type GetBarrioAggregateType<T extends BarrioAggregateArgs> = {
        [P in keyof T & keyof AggregateBarrio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarrio[P]>
      : GetScalarType<T[P], AggregateBarrio[P]>
  }




  export type BarrioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarrioWhereInput
    orderBy?: BarrioOrderByWithAggregationInput | BarrioOrderByWithAggregationInput[]
    by: BarrioScalarFieldEnum[] | BarrioScalarFieldEnum
    having?: BarrioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarrioCountAggregateInputType | true
    _avg?: BarrioAvgAggregateInputType
    _sum?: BarrioSumAggregateInputType
    _min?: BarrioMinAggregateInputType
    _max?: BarrioMaxAggregateInputType
  }

  export type BarrioGroupByOutputType = {
    id: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    nombre: string
    _count: BarrioCountAggregateOutputType | null
    _avg: BarrioAvgAggregateOutputType | null
    _sum: BarrioSumAggregateOutputType | null
    _min: BarrioMinAggregateOutputType | null
    _max: BarrioMaxAggregateOutputType | null
  }

  type GetBarrioGroupByPayload<T extends BarrioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarrioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarrioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarrioGroupByOutputType[P]>
            : GetScalarType<T[P], BarrioGroupByOutputType[P]>
        }
      >
    >


  export type BarrioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProvincia?: boolean
    idCanton?: boolean
    idDistrito?: boolean
    nombre?: boolean
    provincias?: boolean | ProvinciaDefaultArgs<ExtArgs>
    cantones?: boolean | CantonDefaultArgs<ExtArgs>
    distritos?: boolean | DistritoDefaultArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barrio"]>

  export type BarrioSelectScalar = {
    id?: boolean
    idProvincia?: boolean
    idCanton?: boolean
    idDistrito?: boolean
    nombre?: boolean
  }

  export type BarrioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provincias?: boolean | ProvinciaDefaultArgs<ExtArgs>
    cantones?: boolean | CantonDefaultArgs<ExtArgs>
    distritos?: boolean | DistritoDefaultArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
  }


  export type $BarrioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Barrio"
    objects: {
      provincias: Prisma.$ProvinciaPayload<ExtArgs>
      cantones: Prisma.$CantonPayload<ExtArgs>
      distritos: Prisma.$DistritoPayload<ExtArgs>
      ubicacion: Prisma.$UbicacionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idProvincia: number
      idCanton: number
      idDistrito: number
      nombre: string
    }, ExtArgs["result"]["barrio"]>
    composites: {}
  }


  type BarrioGetPayload<S extends boolean | null | undefined | BarrioDefaultArgs> = $Result.GetResult<Prisma.$BarrioPayload, S>

  type BarrioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BarrioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BarrioCountAggregateInputType | true
    }

  export interface BarrioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Barrio'], meta: { name: 'Barrio' } }
    /**
     * Find zero or one Barrio that matches the filter.
     * @param {BarrioFindUniqueArgs} args - Arguments to find a Barrio
     * @example
     * // Get one Barrio
     * const barrio = await prisma.barrio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BarrioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BarrioFindUniqueArgs<ExtArgs>>
    ): Prisma__BarrioClient<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Barrio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BarrioFindUniqueOrThrowArgs} args - Arguments to find a Barrio
     * @example
     * // Get one Barrio
     * const barrio = await prisma.barrio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BarrioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BarrioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BarrioClient<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Barrio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarrioFindFirstArgs} args - Arguments to find a Barrio
     * @example
     * // Get one Barrio
     * const barrio = await prisma.barrio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BarrioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BarrioFindFirstArgs<ExtArgs>>
    ): Prisma__BarrioClient<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Barrio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarrioFindFirstOrThrowArgs} args - Arguments to find a Barrio
     * @example
     * // Get one Barrio
     * const barrio = await prisma.barrio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BarrioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BarrioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BarrioClient<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Barrios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarrioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Barrios
     * const barrios = await prisma.barrio.findMany()
     * 
     * // Get first 10 Barrios
     * const barrios = await prisma.barrio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barrioWithIdOnly = await prisma.barrio.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BarrioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BarrioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Barrio.
     * @param {BarrioCreateArgs} args - Arguments to create a Barrio.
     * @example
     * // Create one Barrio
     * const Barrio = await prisma.barrio.create({
     *   data: {
     *     // ... data to create a Barrio
     *   }
     * })
     * 
    **/
    create<T extends BarrioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BarrioCreateArgs<ExtArgs>>
    ): Prisma__BarrioClient<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Barrios.
     *     @param {BarrioCreateManyArgs} args - Arguments to create many Barrios.
     *     @example
     *     // Create many Barrios
     *     const barrio = await prisma.barrio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BarrioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BarrioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Barrio.
     * @param {BarrioDeleteArgs} args - Arguments to delete one Barrio.
     * @example
     * // Delete one Barrio
     * const Barrio = await prisma.barrio.delete({
     *   where: {
     *     // ... filter to delete one Barrio
     *   }
     * })
     * 
    **/
    delete<T extends BarrioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BarrioDeleteArgs<ExtArgs>>
    ): Prisma__BarrioClient<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Barrio.
     * @param {BarrioUpdateArgs} args - Arguments to update one Barrio.
     * @example
     * // Update one Barrio
     * const barrio = await prisma.barrio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BarrioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BarrioUpdateArgs<ExtArgs>>
    ): Prisma__BarrioClient<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Barrios.
     * @param {BarrioDeleteManyArgs} args - Arguments to filter Barrios to delete.
     * @example
     * // Delete a few Barrios
     * const { count } = await prisma.barrio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BarrioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BarrioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Barrios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarrioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Barrios
     * const barrio = await prisma.barrio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BarrioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BarrioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Barrio.
     * @param {BarrioUpsertArgs} args - Arguments to update or create a Barrio.
     * @example
     * // Update or create a Barrio
     * const barrio = await prisma.barrio.upsert({
     *   create: {
     *     // ... data to create a Barrio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Barrio we want to update
     *   }
     * })
    **/
    upsert<T extends BarrioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BarrioUpsertArgs<ExtArgs>>
    ): Prisma__BarrioClient<$Result.GetResult<Prisma.$BarrioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Barrios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarrioCountArgs} args - Arguments to filter Barrios to count.
     * @example
     * // Count the number of Barrios
     * const count = await prisma.barrio.count({
     *   where: {
     *     // ... the filter for the Barrios we want to count
     *   }
     * })
    **/
    count<T extends BarrioCountArgs>(
      args?: Subset<T, BarrioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarrioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Barrio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarrioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarrioAggregateArgs>(args: Subset<T, BarrioAggregateArgs>): Prisma.PrismaPromise<GetBarrioAggregateType<T>>

    /**
     * Group by Barrio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarrioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarrioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarrioGroupByArgs['orderBy'] }
        : { orderBy?: BarrioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarrioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarrioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Barrio model
   */
  readonly fields: BarrioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Barrio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarrioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    provincias<T extends ProvinciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinciaDefaultArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cantones<T extends CantonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CantonDefaultArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    distritos<T extends DistritoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistritoDefaultArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ubicacion<T extends UbicacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UbicacionDefaultArgs<ExtArgs>>): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Barrio model
   */ 
  interface BarrioFieldRefs {
    readonly id: FieldRef<"Barrio", 'Int'>
    readonly idProvincia: FieldRef<"Barrio", 'Int'>
    readonly idCanton: FieldRef<"Barrio", 'Int'>
    readonly idDistrito: FieldRef<"Barrio", 'Int'>
    readonly nombre: FieldRef<"Barrio", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Barrio findUnique
   */
  export type BarrioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * Filter, which Barrio to fetch.
     */
    where: BarrioWhereUniqueInput
  }


  /**
   * Barrio findUniqueOrThrow
   */
  export type BarrioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * Filter, which Barrio to fetch.
     */
    where: BarrioWhereUniqueInput
  }


  /**
   * Barrio findFirst
   */
  export type BarrioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * Filter, which Barrio to fetch.
     */
    where?: BarrioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Barrios to fetch.
     */
    orderBy?: BarrioOrderByWithRelationInput | BarrioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Barrios.
     */
    cursor?: BarrioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Barrios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Barrios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Barrios.
     */
    distinct?: BarrioScalarFieldEnum | BarrioScalarFieldEnum[]
  }


  /**
   * Barrio findFirstOrThrow
   */
  export type BarrioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * Filter, which Barrio to fetch.
     */
    where?: BarrioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Barrios to fetch.
     */
    orderBy?: BarrioOrderByWithRelationInput | BarrioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Barrios.
     */
    cursor?: BarrioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Barrios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Barrios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Barrios.
     */
    distinct?: BarrioScalarFieldEnum | BarrioScalarFieldEnum[]
  }


  /**
   * Barrio findMany
   */
  export type BarrioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * Filter, which Barrios to fetch.
     */
    where?: BarrioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Barrios to fetch.
     */
    orderBy?: BarrioOrderByWithRelationInput | BarrioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Barrios.
     */
    cursor?: BarrioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Barrios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Barrios.
     */
    skip?: number
    distinct?: BarrioScalarFieldEnum | BarrioScalarFieldEnum[]
  }


  /**
   * Barrio create
   */
  export type BarrioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * The data needed to create a Barrio.
     */
    data: XOR<BarrioCreateInput, BarrioUncheckedCreateInput>
  }


  /**
   * Barrio createMany
   */
  export type BarrioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Barrios.
     */
    data: BarrioCreateManyInput | BarrioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Barrio update
   */
  export type BarrioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * The data needed to update a Barrio.
     */
    data: XOR<BarrioUpdateInput, BarrioUncheckedUpdateInput>
    /**
     * Choose, which Barrio to update.
     */
    where: BarrioWhereUniqueInput
  }


  /**
   * Barrio updateMany
   */
  export type BarrioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Barrios.
     */
    data: XOR<BarrioUpdateManyMutationInput, BarrioUncheckedUpdateManyInput>
    /**
     * Filter which Barrios to update
     */
    where?: BarrioWhereInput
  }


  /**
   * Barrio upsert
   */
  export type BarrioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * The filter to search for the Barrio to update in case it exists.
     */
    where: BarrioWhereUniqueInput
    /**
     * In case the Barrio found by the `where` argument doesn't exist, create a new Barrio with this data.
     */
    create: XOR<BarrioCreateInput, BarrioUncheckedCreateInput>
    /**
     * In case the Barrio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarrioUpdateInput, BarrioUncheckedUpdateInput>
  }


  /**
   * Barrio delete
   */
  export type BarrioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
    /**
     * Filter which Barrio to delete.
     */
    where: BarrioWhereUniqueInput
  }


  /**
   * Barrio deleteMany
   */
  export type BarrioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Barrios to delete
     */
    where?: BarrioWhereInput
  }


  /**
   * Barrio without action
   */
  export type BarrioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barrio
     */
    select?: BarrioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BarrioInclude<ExtArgs> | null
  }



  /**
   * Model Bodega
   */

  export type AggregateBodega = {
    _count: BodegaCountAggregateOutputType | null
    _avg: BodegaAvgAggregateOutputType | null
    _sum: BodegaSumAggregateOutputType | null
    _min: BodegaMinAggregateOutputType | null
    _max: BodegaMaxAggregateOutputType | null
  }

  export type BodegaAvgAggregateOutputType = {
    id: number | null
    idUbicacion: number | null
    tamanno: number | null
    capacidad: number | null
  }

  export type BodegaSumAggregateOutputType = {
    id: number | null
    idUbicacion: number | null
    tamanno: number | null
    capacidad: number | null
  }

  export type BodegaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    idUbicacion: number | null
    tamanno: number | null
    capacidad: number | null
    seguridad: boolean | null
  }

  export type BodegaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    idUbicacion: number | null
    tamanno: number | null
    capacidad: number | null
    seguridad: boolean | null
  }

  export type BodegaCountAggregateOutputType = {
    id: number
    nombre: number
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: number
    _all: number
  }


  export type BodegaAvgAggregateInputType = {
    id?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
  }

  export type BodegaSumAggregateInputType = {
    id?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
  }

  export type BodegaMinAggregateInputType = {
    id?: true
    nombre?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
    seguridad?: true
  }

  export type BodegaMaxAggregateInputType = {
    id?: true
    nombre?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
    seguridad?: true
  }

  export type BodegaCountAggregateInputType = {
    id?: true
    nombre?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
    seguridad?: true
    _all?: true
  }

  export type BodegaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bodega to aggregate.
     */
    where?: BodegaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bodegas to fetch.
     */
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BodegaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bodegas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bodegas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bodegas
    **/
    _count?: true | BodegaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BodegaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BodegaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BodegaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BodegaMaxAggregateInputType
  }

  export type GetBodegaAggregateType<T extends BodegaAggregateArgs> = {
        [P in keyof T & keyof AggregateBodega]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBodega[P]>
      : GetScalarType<T[P], AggregateBodega[P]>
  }




  export type BodegaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodegaWhereInput
    orderBy?: BodegaOrderByWithAggregationInput | BodegaOrderByWithAggregationInput[]
    by: BodegaScalarFieldEnum[] | BodegaScalarFieldEnum
    having?: BodegaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BodegaCountAggregateInputType | true
    _avg?: BodegaAvgAggregateInputType
    _sum?: BodegaSumAggregateInputType
    _min?: BodegaMinAggregateInputType
    _max?: BodegaMaxAggregateInputType
  }

  export type BodegaGroupByOutputType = {
    id: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    _count: BodegaCountAggregateOutputType | null
    _avg: BodegaAvgAggregateOutputType | null
    _sum: BodegaSumAggregateOutputType | null
    _min: BodegaMinAggregateOutputType | null
    _max: BodegaMaxAggregateOutputType | null
  }

  type GetBodegaGroupByPayload<T extends BodegaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BodegaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BodegaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BodegaGroupByOutputType[P]>
            : GetScalarType<T[P], BodegaGroupByOutputType[P]>
        }
      >
    >


  export type BodegaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    idUbicacion?: boolean
    tamanno?: boolean
    capacidad?: boolean
    seguridad?: boolean
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    bodegaProductos?: boolean | Bodega$bodegaProductosArgs<ExtArgs>
    detalleCompras?: boolean | Bodega$detalleComprasArgs<ExtArgs>
    Historial?: boolean | Bodega$HistorialArgs<ExtArgs>
    TrasladoDestino?: boolean | Bodega$TrasladoDestinoArgs<ExtArgs>
    _count?: boolean | BodegaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bodega"]>

  export type BodegaSelectScalar = {
    id?: boolean
    nombre?: boolean
    idUbicacion?: boolean
    tamanno?: boolean
    capacidad?: boolean
    seguridad?: boolean
  }

  export type BodegaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    bodegaProductos?: boolean | Bodega$bodegaProductosArgs<ExtArgs>
    detalleCompras?: boolean | Bodega$detalleComprasArgs<ExtArgs>
    Historial?: boolean | Bodega$HistorialArgs<ExtArgs>
    TrasladoDestino?: boolean | Bodega$TrasladoDestinoArgs<ExtArgs>
    _count?: boolean | BodegaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BodegaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bodega"
    objects: {
      ubicacion: Prisma.$UbicacionPayload<ExtArgs>
      bodegaProductos: Prisma.$BodegaProductosPayload<ExtArgs>[]
      detalleCompras: Prisma.$DetalleCompraPayload<ExtArgs>[]
      Historial: Prisma.$HistorialPayload<ExtArgs>[]
      TrasladoDestino: Prisma.$TrasladoDestinoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      idUbicacion: number
      tamanno: number
      capacidad: number
      seguridad: boolean
    }, ExtArgs["result"]["bodega"]>
    composites: {}
  }


  type BodegaGetPayload<S extends boolean | null | undefined | BodegaDefaultArgs> = $Result.GetResult<Prisma.$BodegaPayload, S>

  type BodegaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BodegaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BodegaCountAggregateInputType | true
    }

  export interface BodegaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bodega'], meta: { name: 'Bodega' } }
    /**
     * Find zero or one Bodega that matches the filter.
     * @param {BodegaFindUniqueArgs} args - Arguments to find a Bodega
     * @example
     * // Get one Bodega
     * const bodega = await prisma.bodega.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BodegaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaFindUniqueArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bodega that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BodegaFindUniqueOrThrowArgs} args - Arguments to find a Bodega
     * @example
     * // Get one Bodega
     * const bodega = await prisma.bodega.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BodegaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bodega that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaFindFirstArgs} args - Arguments to find a Bodega
     * @example
     * // Get one Bodega
     * const bodega = await prisma.bodega.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BodegaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaFindFirstArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bodega that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaFindFirstOrThrowArgs} args - Arguments to find a Bodega
     * @example
     * // Get one Bodega
     * const bodega = await prisma.bodega.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BodegaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bodegas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bodegas
     * const bodegas = await prisma.bodega.findMany()
     * 
     * // Get first 10 Bodegas
     * const bodegas = await prisma.bodega.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bodegaWithIdOnly = await prisma.bodega.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BodegaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bodega.
     * @param {BodegaCreateArgs} args - Arguments to create a Bodega.
     * @example
     * // Create one Bodega
     * const Bodega = await prisma.bodega.create({
     *   data: {
     *     // ... data to create a Bodega
     *   }
     * })
     * 
    **/
    create<T extends BodegaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaCreateArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bodegas.
     *     @param {BodegaCreateManyArgs} args - Arguments to create many Bodegas.
     *     @example
     *     // Create many Bodegas
     *     const bodega = await prisma.bodega.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BodegaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bodega.
     * @param {BodegaDeleteArgs} args - Arguments to delete one Bodega.
     * @example
     * // Delete one Bodega
     * const Bodega = await prisma.bodega.delete({
     *   where: {
     *     // ... filter to delete one Bodega
     *   }
     * })
     * 
    **/
    delete<T extends BodegaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaDeleteArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bodega.
     * @param {BodegaUpdateArgs} args - Arguments to update one Bodega.
     * @example
     * // Update one Bodega
     * const bodega = await prisma.bodega.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BodegaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaUpdateArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bodegas.
     * @param {BodegaDeleteManyArgs} args - Arguments to filter Bodegas to delete.
     * @example
     * // Delete a few Bodegas
     * const { count } = await prisma.bodega.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BodegaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bodegas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bodegas
     * const bodega = await prisma.bodega.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BodegaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bodega.
     * @param {BodegaUpsertArgs} args - Arguments to update or create a Bodega.
     * @example
     * // Update or create a Bodega
     * const bodega = await prisma.bodega.upsert({
     *   create: {
     *     // ... data to create a Bodega
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bodega we want to update
     *   }
     * })
    **/
    upsert<T extends BodegaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaUpsertArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bodegas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaCountArgs} args - Arguments to filter Bodegas to count.
     * @example
     * // Count the number of Bodegas
     * const count = await prisma.bodega.count({
     *   where: {
     *     // ... the filter for the Bodegas we want to count
     *   }
     * })
    **/
    count<T extends BodegaCountArgs>(
      args?: Subset<T, BodegaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BodegaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bodega.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BodegaAggregateArgs>(args: Subset<T, BodegaAggregateArgs>): Prisma.PrismaPromise<GetBodegaAggregateType<T>>

    /**
     * Group by Bodega.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BodegaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BodegaGroupByArgs['orderBy'] }
        : { orderBy?: BodegaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BodegaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBodegaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bodega model
   */
  readonly fields: BodegaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bodega.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BodegaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ubicacion<T extends UbicacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UbicacionDefaultArgs<ExtArgs>>): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bodegaProductos<T extends Bodega$bodegaProductosArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$bodegaProductosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'findMany'> | Null>;

    detalleCompras<T extends Bodega$detalleComprasArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$detalleComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    Historial<T extends Bodega$HistorialArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$HistorialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findMany'> | Null>;

    TrasladoDestino<T extends Bodega$TrasladoDestinoArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$TrasladoDestinoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Bodega model
   */ 
  interface BodegaFieldRefs {
    readonly id: FieldRef<"Bodega", 'Int'>
    readonly nombre: FieldRef<"Bodega", 'String'>
    readonly idUbicacion: FieldRef<"Bodega", 'Int'>
    readonly tamanno: FieldRef<"Bodega", 'Float'>
    readonly capacidad: FieldRef<"Bodega", 'Float'>
    readonly seguridad: FieldRef<"Bodega", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Bodega findUnique
   */
  export type BodegaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodega to fetch.
     */
    where: BodegaWhereUniqueInput
  }


  /**
   * Bodega findUniqueOrThrow
   */
  export type BodegaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodega to fetch.
     */
    where: BodegaWhereUniqueInput
  }


  /**
   * Bodega findFirst
   */
  export type BodegaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodega to fetch.
     */
    where?: BodegaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bodegas to fetch.
     */
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bodegas.
     */
    cursor?: BodegaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bodegas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bodegas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bodegas.
     */
    distinct?: BodegaScalarFieldEnum | BodegaScalarFieldEnum[]
  }


  /**
   * Bodega findFirstOrThrow
   */
  export type BodegaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodega to fetch.
     */
    where?: BodegaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bodegas to fetch.
     */
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bodegas.
     */
    cursor?: BodegaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bodegas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bodegas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bodegas.
     */
    distinct?: BodegaScalarFieldEnum | BodegaScalarFieldEnum[]
  }


  /**
   * Bodega findMany
   */
  export type BodegaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodegas to fetch.
     */
    where?: BodegaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bodegas to fetch.
     */
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bodegas.
     */
    cursor?: BodegaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bodegas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bodegas.
     */
    skip?: number
    distinct?: BodegaScalarFieldEnum | BodegaScalarFieldEnum[]
  }


  /**
   * Bodega create
   */
  export type BodegaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * The data needed to create a Bodega.
     */
    data: XOR<BodegaCreateInput, BodegaUncheckedCreateInput>
  }


  /**
   * Bodega createMany
   */
  export type BodegaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bodegas.
     */
    data: BodegaCreateManyInput | BodegaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Bodega update
   */
  export type BodegaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * The data needed to update a Bodega.
     */
    data: XOR<BodegaUpdateInput, BodegaUncheckedUpdateInput>
    /**
     * Choose, which Bodega to update.
     */
    where: BodegaWhereUniqueInput
  }


  /**
   * Bodega updateMany
   */
  export type BodegaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bodegas.
     */
    data: XOR<BodegaUpdateManyMutationInput, BodegaUncheckedUpdateManyInput>
    /**
     * Filter which Bodegas to update
     */
    where?: BodegaWhereInput
  }


  /**
   * Bodega upsert
   */
  export type BodegaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * The filter to search for the Bodega to update in case it exists.
     */
    where: BodegaWhereUniqueInput
    /**
     * In case the Bodega found by the `where` argument doesn't exist, create a new Bodega with this data.
     */
    create: XOR<BodegaCreateInput, BodegaUncheckedCreateInput>
    /**
     * In case the Bodega was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BodegaUpdateInput, BodegaUncheckedUpdateInput>
  }


  /**
   * Bodega delete
   */
  export type BodegaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter which Bodega to delete.
     */
    where: BodegaWhereUniqueInput
  }


  /**
   * Bodega deleteMany
   */
  export type BodegaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bodegas to delete
     */
    where?: BodegaWhereInput
  }


  /**
   * Bodega.bodegaProductos
   */
  export type Bodega$bodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    where?: BodegaProductosWhereInput
    orderBy?: BodegaProductosOrderByWithRelationInput | BodegaProductosOrderByWithRelationInput[]
    cursor?: BodegaProductosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BodegaProductosScalarFieldEnum | BodegaProductosScalarFieldEnum[]
  }


  /**
   * Bodega.detalleCompras
   */
  export type Bodega$detalleComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    where?: DetalleCompraWhereInput
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    cursor?: DetalleCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * Bodega.Historial
   */
  export type Bodega$HistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    where?: HistorialWhereInput
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    cursor?: HistorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Bodega.TrasladoDestino
   */
  export type Bodega$TrasladoDestinoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    where?: TrasladoDestinoWhereInput
    orderBy?: TrasladoDestinoOrderByWithRelationInput | TrasladoDestinoOrderByWithRelationInput[]
    cursor?: TrasladoDestinoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoDestinoScalarFieldEnum | TrasladoDestinoScalarFieldEnum[]
  }


  /**
   * Bodega without action
   */
  export type BodegaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
  }



  /**
   * Model BodegaProductos
   */

  export type AggregateBodegaProductos = {
    _count: BodegaProductosCountAggregateOutputType | null
    _avg: BodegaProductosAvgAggregateOutputType | null
    _sum: BodegaProductosSumAggregateOutputType | null
    _min: BodegaProductosMinAggregateOutputType | null
    _max: BodegaProductosMaxAggregateOutputType | null
  }

  export type BodegaProductosAvgAggregateOutputType = {
    idBodega: number | null
    idProducto: number | null
    idUsuario: number | null
    cantidad: number | null
  }

  export type BodegaProductosSumAggregateOutputType = {
    idBodega: number | null
    idProducto: number | null
    idUsuario: number | null
    cantidad: number | null
  }

  export type BodegaProductosMinAggregateOutputType = {
    idBodega: number | null
    idProducto: number | null
    idUsuario: number | null
    fechaRegistro: Date | null
    cantidad: number | null
  }

  export type BodegaProductosMaxAggregateOutputType = {
    idBodega: number | null
    idProducto: number | null
    idUsuario: number | null
    fechaRegistro: Date | null
    cantidad: number | null
  }

  export type BodegaProductosCountAggregateOutputType = {
    idBodega: number
    idProducto: number
    idUsuario: number
    fechaRegistro: number
    cantidad: number
    _all: number
  }


  export type BodegaProductosAvgAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuario?: true
    cantidad?: true
  }

  export type BodegaProductosSumAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuario?: true
    cantidad?: true
  }

  export type BodegaProductosMinAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuario?: true
    fechaRegistro?: true
    cantidad?: true
  }

  export type BodegaProductosMaxAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuario?: true
    fechaRegistro?: true
    cantidad?: true
  }

  export type BodegaProductosCountAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuario?: true
    fechaRegistro?: true
    cantidad?: true
    _all?: true
  }

  export type BodegaProductosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodegaProductos to aggregate.
     */
    where?: BodegaProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodegaProductos to fetch.
     */
    orderBy?: BodegaProductosOrderByWithRelationInput | BodegaProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BodegaProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodegaProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodegaProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BodegaProductos
    **/
    _count?: true | BodegaProductosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BodegaProductosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BodegaProductosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BodegaProductosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BodegaProductosMaxAggregateInputType
  }

  export type GetBodegaProductosAggregateType<T extends BodegaProductosAggregateArgs> = {
        [P in keyof T & keyof AggregateBodegaProductos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBodegaProductos[P]>
      : GetScalarType<T[P], AggregateBodegaProductos[P]>
  }




  export type BodegaProductosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodegaProductosWhereInput
    orderBy?: BodegaProductosOrderByWithAggregationInput | BodegaProductosOrderByWithAggregationInput[]
    by: BodegaProductosScalarFieldEnum[] | BodegaProductosScalarFieldEnum
    having?: BodegaProductosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BodegaProductosCountAggregateInputType | true
    _avg?: BodegaProductosAvgAggregateInputType
    _sum?: BodegaProductosSumAggregateInputType
    _min?: BodegaProductosMinAggregateInputType
    _max?: BodegaProductosMaxAggregateInputType
  }

  export type BodegaProductosGroupByOutputType = {
    idBodega: number
    idProducto: number
    idUsuario: number
    fechaRegistro: Date
    cantidad: number
    _count: BodegaProductosCountAggregateOutputType | null
    _avg: BodegaProductosAvgAggregateOutputType | null
    _sum: BodegaProductosSumAggregateOutputType | null
    _min: BodegaProductosMinAggregateOutputType | null
    _max: BodegaProductosMaxAggregateOutputType | null
  }

  type GetBodegaProductosGroupByPayload<T extends BodegaProductosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BodegaProductosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BodegaProductosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BodegaProductosGroupByOutputType[P]>
            : GetScalarType<T[P], BodegaProductosGroupByOutputType[P]>
        }
      >
    >


  export type BodegaProductosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBodega?: boolean
    idProducto?: boolean
    idUsuario?: boolean
    fechaRegistro?: boolean
    cantidad?: boolean
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bodegaProductos"]>

  export type BodegaProductosSelectScalar = {
    idBodega?: boolean
    idProducto?: boolean
    idUsuario?: boolean
    fechaRegistro?: boolean
    cantidad?: boolean
  }

  export type BodegaProductosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }


  export type $BodegaProductosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BodegaProductos"
    objects: {
      bodegas: Prisma.$BodegaPayload<ExtArgs>
      producto: Prisma.$ProductoPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBodega: number
      idProducto: number
      idUsuario: number
      fechaRegistro: Date
      cantidad: number
    }, ExtArgs["result"]["bodegaProductos"]>
    composites: {}
  }


  type BodegaProductosGetPayload<S extends boolean | null | undefined | BodegaProductosDefaultArgs> = $Result.GetResult<Prisma.$BodegaProductosPayload, S>

  type BodegaProductosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BodegaProductosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BodegaProductosCountAggregateInputType | true
    }

  export interface BodegaProductosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BodegaProductos'], meta: { name: 'BodegaProductos' } }
    /**
     * Find zero or one BodegaProductos that matches the filter.
     * @param {BodegaProductosFindUniqueArgs} args - Arguments to find a BodegaProductos
     * @example
     * // Get one BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BodegaProductosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaProductosFindUniqueArgs<ExtArgs>>
    ): Prisma__BodegaProductosClient<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BodegaProductos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BodegaProductosFindUniqueOrThrowArgs} args - Arguments to find a BodegaProductos
     * @example
     * // Get one BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BodegaProductosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaProductosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BodegaProductosClient<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BodegaProductos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaProductosFindFirstArgs} args - Arguments to find a BodegaProductos
     * @example
     * // Get one BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BodegaProductosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaProductosFindFirstArgs<ExtArgs>>
    ): Prisma__BodegaProductosClient<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BodegaProductos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaProductosFindFirstOrThrowArgs} args - Arguments to find a BodegaProductos
     * @example
     * // Get one BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BodegaProductosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaProductosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BodegaProductosClient<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BodegaProductos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaProductosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.findMany()
     * 
     * // Get first 10 BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.findMany({ take: 10 })
     * 
     * // Only select the `idBodega`
     * const bodegaProductosWithIdBodegaOnly = await prisma.bodegaProductos.findMany({ select: { idBodega: true } })
     * 
    **/
    findMany<T extends BodegaProductosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaProductosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BodegaProductos.
     * @param {BodegaProductosCreateArgs} args - Arguments to create a BodegaProductos.
     * @example
     * // Create one BodegaProductos
     * const BodegaProductos = await prisma.bodegaProductos.create({
     *   data: {
     *     // ... data to create a BodegaProductos
     *   }
     * })
     * 
    **/
    create<T extends BodegaProductosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaProductosCreateArgs<ExtArgs>>
    ): Prisma__BodegaProductosClient<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BodegaProductos.
     *     @param {BodegaProductosCreateManyArgs} args - Arguments to create many BodegaProductos.
     *     @example
     *     // Create many BodegaProductos
     *     const bodegaProductos = await prisma.bodegaProductos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BodegaProductosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaProductosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BodegaProductos.
     * @param {BodegaProductosDeleteArgs} args - Arguments to delete one BodegaProductos.
     * @example
     * // Delete one BodegaProductos
     * const BodegaProductos = await prisma.bodegaProductos.delete({
     *   where: {
     *     // ... filter to delete one BodegaProductos
     *   }
     * })
     * 
    **/
    delete<T extends BodegaProductosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaProductosDeleteArgs<ExtArgs>>
    ): Prisma__BodegaProductosClient<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BodegaProductos.
     * @param {BodegaProductosUpdateArgs} args - Arguments to update one BodegaProductos.
     * @example
     * // Update one BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BodegaProductosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaProductosUpdateArgs<ExtArgs>>
    ): Prisma__BodegaProductosClient<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BodegaProductos.
     * @param {BodegaProductosDeleteManyArgs} args - Arguments to filter BodegaProductos to delete.
     * @example
     * // Delete a few BodegaProductos
     * const { count } = await prisma.bodegaProductos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BodegaProductosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaProductosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BodegaProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaProductosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BodegaProductosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaProductosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BodegaProductos.
     * @param {BodegaProductosUpsertArgs} args - Arguments to update or create a BodegaProductos.
     * @example
     * // Update or create a BodegaProductos
     * const bodegaProductos = await prisma.bodegaProductos.upsert({
     *   create: {
     *     // ... data to create a BodegaProductos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BodegaProductos we want to update
     *   }
     * })
    **/
    upsert<T extends BodegaProductosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaProductosUpsertArgs<ExtArgs>>
    ): Prisma__BodegaProductosClient<$Result.GetResult<Prisma.$BodegaProductosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BodegaProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaProductosCountArgs} args - Arguments to filter BodegaProductos to count.
     * @example
     * // Count the number of BodegaProductos
     * const count = await prisma.bodegaProductos.count({
     *   where: {
     *     // ... the filter for the BodegaProductos we want to count
     *   }
     * })
    **/
    count<T extends BodegaProductosCountArgs>(
      args?: Subset<T, BodegaProductosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BodegaProductosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BodegaProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaProductosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BodegaProductosAggregateArgs>(args: Subset<T, BodegaProductosAggregateArgs>): Prisma.PrismaPromise<GetBodegaProductosAggregateType<T>>

    /**
     * Group by BodegaProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaProductosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BodegaProductosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BodegaProductosGroupByArgs['orderBy'] }
        : { orderBy?: BodegaProductosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BodegaProductosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBodegaProductosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BodegaProductos model
   */
  readonly fields: BodegaProductosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BodegaProductos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BodegaProductosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bodegas<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BodegaProductos model
   */ 
  interface BodegaProductosFieldRefs {
    readonly idBodega: FieldRef<"BodegaProductos", 'Int'>
    readonly idProducto: FieldRef<"BodegaProductos", 'Int'>
    readonly idUsuario: FieldRef<"BodegaProductos", 'Int'>
    readonly fechaRegistro: FieldRef<"BodegaProductos", 'DateTime'>
    readonly cantidad: FieldRef<"BodegaProductos", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BodegaProductos findUnique
   */
  export type BodegaProductosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * Filter, which BodegaProductos to fetch.
     */
    where: BodegaProductosWhereUniqueInput
  }


  /**
   * BodegaProductos findUniqueOrThrow
   */
  export type BodegaProductosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * Filter, which BodegaProductos to fetch.
     */
    where: BodegaProductosWhereUniqueInput
  }


  /**
   * BodegaProductos findFirst
   */
  export type BodegaProductosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * Filter, which BodegaProductos to fetch.
     */
    where?: BodegaProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodegaProductos to fetch.
     */
    orderBy?: BodegaProductosOrderByWithRelationInput | BodegaProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodegaProductos.
     */
    cursor?: BodegaProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodegaProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodegaProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodegaProductos.
     */
    distinct?: BodegaProductosScalarFieldEnum | BodegaProductosScalarFieldEnum[]
  }


  /**
   * BodegaProductos findFirstOrThrow
   */
  export type BodegaProductosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * Filter, which BodegaProductos to fetch.
     */
    where?: BodegaProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodegaProductos to fetch.
     */
    orderBy?: BodegaProductosOrderByWithRelationInput | BodegaProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodegaProductos.
     */
    cursor?: BodegaProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodegaProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodegaProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodegaProductos.
     */
    distinct?: BodegaProductosScalarFieldEnum | BodegaProductosScalarFieldEnum[]
  }


  /**
   * BodegaProductos findMany
   */
  export type BodegaProductosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * Filter, which BodegaProductos to fetch.
     */
    where?: BodegaProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodegaProductos to fetch.
     */
    orderBy?: BodegaProductosOrderByWithRelationInput | BodegaProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BodegaProductos.
     */
    cursor?: BodegaProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodegaProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodegaProductos.
     */
    skip?: number
    distinct?: BodegaProductosScalarFieldEnum | BodegaProductosScalarFieldEnum[]
  }


  /**
   * BodegaProductos create
   */
  export type BodegaProductosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * The data needed to create a BodegaProductos.
     */
    data: XOR<BodegaProductosCreateInput, BodegaProductosUncheckedCreateInput>
  }


  /**
   * BodegaProductos createMany
   */
  export type BodegaProductosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BodegaProductos.
     */
    data: BodegaProductosCreateManyInput | BodegaProductosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BodegaProductos update
   */
  export type BodegaProductosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * The data needed to update a BodegaProductos.
     */
    data: XOR<BodegaProductosUpdateInput, BodegaProductosUncheckedUpdateInput>
    /**
     * Choose, which BodegaProductos to update.
     */
    where: BodegaProductosWhereUniqueInput
  }


  /**
   * BodegaProductos updateMany
   */
  export type BodegaProductosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BodegaProductos.
     */
    data: XOR<BodegaProductosUpdateManyMutationInput, BodegaProductosUncheckedUpdateManyInput>
    /**
     * Filter which BodegaProductos to update
     */
    where?: BodegaProductosWhereInput
  }


  /**
   * BodegaProductos upsert
   */
  export type BodegaProductosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * The filter to search for the BodegaProductos to update in case it exists.
     */
    where: BodegaProductosWhereUniqueInput
    /**
     * In case the BodegaProductos found by the `where` argument doesn't exist, create a new BodegaProductos with this data.
     */
    create: XOR<BodegaProductosCreateInput, BodegaProductosUncheckedCreateInput>
    /**
     * In case the BodegaProductos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BodegaProductosUpdateInput, BodegaProductosUncheckedUpdateInput>
  }


  /**
   * BodegaProductos delete
   */
  export type BodegaProductosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
    /**
     * Filter which BodegaProductos to delete.
     */
    where: BodegaProductosWhereUniqueInput
  }


  /**
   * BodegaProductos deleteMany
   */
  export type BodegaProductosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodegaProductos to delete
     */
    where?: BodegaProductosWhereInput
  }


  /**
   * BodegaProductos without action
   */
  export type BodegaProductosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaProductos
     */
    select?: BodegaProductosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaProductosInclude<ExtArgs> | null
  }



  /**
   * Model EncabezadoCompra
   */

  export type AggregateEncabezadoCompra = {
    _count: EncabezadoCompraCountAggregateOutputType | null
    _avg: EncabezadoCompraAvgAggregateOutputType | null
    _sum: EncabezadoCompraSumAggregateOutputType | null
    _min: EncabezadoCompraMinAggregateOutputType | null
    _max: EncabezadoCompraMaxAggregateOutputType | null
  }

  export type EncabezadoCompraAvgAggregateOutputType = {
    id: number | null
    idUsuarioProveedor: number | null
    idUsuarioRegistro: number | null
  }

  export type EncabezadoCompraSumAggregateOutputType = {
    id: number | null
    idUsuarioProveedor: number | null
    idUsuarioRegistro: number | null
  }

  export type EncabezadoCompraMinAggregateOutputType = {
    id: number | null
    fechaCompra: Date | null
    idUsuarioProveedor: number | null
    idUsuarioRegistro: number | null
  }

  export type EncabezadoCompraMaxAggregateOutputType = {
    id: number | null
    fechaCompra: Date | null
    idUsuarioProveedor: number | null
    idUsuarioRegistro: number | null
  }

  export type EncabezadoCompraCountAggregateOutputType = {
    id: number
    fechaCompra: number
    idUsuarioProveedor: number
    idUsuarioRegistro: number
    _all: number
  }


  export type EncabezadoCompraAvgAggregateInputType = {
    id?: true
    idUsuarioProveedor?: true
    idUsuarioRegistro?: true
  }

  export type EncabezadoCompraSumAggregateInputType = {
    id?: true
    idUsuarioProveedor?: true
    idUsuarioRegistro?: true
  }

  export type EncabezadoCompraMinAggregateInputType = {
    id?: true
    fechaCompra?: true
    idUsuarioProveedor?: true
    idUsuarioRegistro?: true
  }

  export type EncabezadoCompraMaxAggregateInputType = {
    id?: true
    fechaCompra?: true
    idUsuarioProveedor?: true
    idUsuarioRegistro?: true
  }

  export type EncabezadoCompraCountAggregateInputType = {
    id?: true
    fechaCompra?: true
    idUsuarioProveedor?: true
    idUsuarioRegistro?: true
    _all?: true
  }

  export type EncabezadoCompraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncabezadoCompra to aggregate.
     */
    where?: EncabezadoCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoCompras to fetch.
     */
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncabezadoCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncabezadoCompras
    **/
    _count?: true | EncabezadoCompraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncabezadoCompraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncabezadoCompraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncabezadoCompraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncabezadoCompraMaxAggregateInputType
  }

  export type GetEncabezadoCompraAggregateType<T extends EncabezadoCompraAggregateArgs> = {
        [P in keyof T & keyof AggregateEncabezadoCompra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncabezadoCompra[P]>
      : GetScalarType<T[P], AggregateEncabezadoCompra[P]>
  }




  export type EncabezadoCompraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoCompraWhereInput
    orderBy?: EncabezadoCompraOrderByWithAggregationInput | EncabezadoCompraOrderByWithAggregationInput[]
    by: EncabezadoCompraScalarFieldEnum[] | EncabezadoCompraScalarFieldEnum
    having?: EncabezadoCompraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncabezadoCompraCountAggregateInputType | true
    _avg?: EncabezadoCompraAvgAggregateInputType
    _sum?: EncabezadoCompraSumAggregateInputType
    _min?: EncabezadoCompraMinAggregateInputType
    _max?: EncabezadoCompraMaxAggregateInputType
  }

  export type EncabezadoCompraGroupByOutputType = {
    id: number
    fechaCompra: Date
    idUsuarioProveedor: number
    idUsuarioRegistro: number
    _count: EncabezadoCompraCountAggregateOutputType | null
    _avg: EncabezadoCompraAvgAggregateOutputType | null
    _sum: EncabezadoCompraSumAggregateOutputType | null
    _min: EncabezadoCompraMinAggregateOutputType | null
    _max: EncabezadoCompraMaxAggregateOutputType | null
  }

  type GetEncabezadoCompraGroupByPayload<T extends EncabezadoCompraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncabezadoCompraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncabezadoCompraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncabezadoCompraGroupByOutputType[P]>
            : GetScalarType<T[P], EncabezadoCompraGroupByOutputType[P]>
        }
      >
    >


  export type EncabezadoCompraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fechaCompra?: boolean
    idUsuarioProveedor?: boolean
    idUsuarioRegistro?: boolean
    usuarioProveedor?: boolean | UsuarioDefaultArgs<ExtArgs>
    detalleCompras?: boolean | EncabezadoCompra$detalleComprasArgs<ExtArgs>
    pedidos?: boolean | EncabezadoCompra$pedidosArgs<ExtArgs>
    _count?: boolean | EncabezadoCompraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encabezadoCompra"]>

  export type EncabezadoCompraSelectScalar = {
    id?: boolean
    fechaCompra?: boolean
    idUsuarioProveedor?: boolean
    idUsuarioRegistro?: boolean
  }

  export type EncabezadoCompraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarioProveedor?: boolean | UsuarioDefaultArgs<ExtArgs>
    detalleCompras?: boolean | EncabezadoCompra$detalleComprasArgs<ExtArgs>
    pedidos?: boolean | EncabezadoCompra$pedidosArgs<ExtArgs>
    _count?: boolean | EncabezadoCompraCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EncabezadoCompraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncabezadoCompra"
    objects: {
      usuarioProveedor: Prisma.$UsuarioPayload<ExtArgs>
      detalleCompras: Prisma.$DetalleCompraPayload<ExtArgs>[]
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fechaCompra: Date
      idUsuarioProveedor: number
      idUsuarioRegistro: number
    }, ExtArgs["result"]["encabezadoCompra"]>
    composites: {}
  }


  type EncabezadoCompraGetPayload<S extends boolean | null | undefined | EncabezadoCompraDefaultArgs> = $Result.GetResult<Prisma.$EncabezadoCompraPayload, S>

  type EncabezadoCompraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncabezadoCompraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncabezadoCompraCountAggregateInputType | true
    }

  export interface EncabezadoCompraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncabezadoCompra'], meta: { name: 'EncabezadoCompra' } }
    /**
     * Find zero or one EncabezadoCompra that matches the filter.
     * @param {EncabezadoCompraFindUniqueArgs} args - Arguments to find a EncabezadoCompra
     * @example
     * // Get one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EncabezadoCompraFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraFindUniqueArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EncabezadoCompra that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EncabezadoCompraFindUniqueOrThrowArgs} args - Arguments to find a EncabezadoCompra
     * @example
     * // Get one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EncabezadoCompraFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EncabezadoCompra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraFindFirstArgs} args - Arguments to find a EncabezadoCompra
     * @example
     * // Get one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EncabezadoCompraFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraFindFirstArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EncabezadoCompra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraFindFirstOrThrowArgs} args - Arguments to find a EncabezadoCompra
     * @example
     * // Get one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EncabezadoCompraFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EncabezadoCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncabezadoCompras
     * const encabezadoCompras = await prisma.encabezadoCompra.findMany()
     * 
     * // Get first 10 EncabezadoCompras
     * const encabezadoCompras = await prisma.encabezadoCompra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encabezadoCompraWithIdOnly = await prisma.encabezadoCompra.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EncabezadoCompraFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EncabezadoCompra.
     * @param {EncabezadoCompraCreateArgs} args - Arguments to create a EncabezadoCompra.
     * @example
     * // Create one EncabezadoCompra
     * const EncabezadoCompra = await prisma.encabezadoCompra.create({
     *   data: {
     *     // ... data to create a EncabezadoCompra
     *   }
     * })
     * 
    **/
    create<T extends EncabezadoCompraCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraCreateArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EncabezadoCompras.
     *     @param {EncabezadoCompraCreateManyArgs} args - Arguments to create many EncabezadoCompras.
     *     @example
     *     // Create many EncabezadoCompras
     *     const encabezadoCompra = await prisma.encabezadoCompra.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EncabezadoCompraCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EncabezadoCompra.
     * @param {EncabezadoCompraDeleteArgs} args - Arguments to delete one EncabezadoCompra.
     * @example
     * // Delete one EncabezadoCompra
     * const EncabezadoCompra = await prisma.encabezadoCompra.delete({
     *   where: {
     *     // ... filter to delete one EncabezadoCompra
     *   }
     * })
     * 
    **/
    delete<T extends EncabezadoCompraDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraDeleteArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EncabezadoCompra.
     * @param {EncabezadoCompraUpdateArgs} args - Arguments to update one EncabezadoCompra.
     * @example
     * // Update one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EncabezadoCompraUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraUpdateArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EncabezadoCompras.
     * @param {EncabezadoCompraDeleteManyArgs} args - Arguments to filter EncabezadoCompras to delete.
     * @example
     * // Delete a few EncabezadoCompras
     * const { count } = await prisma.encabezadoCompra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EncabezadoCompraDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncabezadoCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncabezadoCompras
     * const encabezadoCompra = await prisma.encabezadoCompra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EncabezadoCompraUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncabezadoCompra.
     * @param {EncabezadoCompraUpsertArgs} args - Arguments to update or create a EncabezadoCompra.
     * @example
     * // Update or create a EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.upsert({
     *   create: {
     *     // ... data to create a EncabezadoCompra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncabezadoCompra we want to update
     *   }
     * })
    **/
    upsert<T extends EncabezadoCompraUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraUpsertArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EncabezadoCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraCountArgs} args - Arguments to filter EncabezadoCompras to count.
     * @example
     * // Count the number of EncabezadoCompras
     * const count = await prisma.encabezadoCompra.count({
     *   where: {
     *     // ... the filter for the EncabezadoCompras we want to count
     *   }
     * })
    **/
    count<T extends EncabezadoCompraCountArgs>(
      args?: Subset<T, EncabezadoCompraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncabezadoCompraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncabezadoCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncabezadoCompraAggregateArgs>(args: Subset<T, EncabezadoCompraAggregateArgs>): Prisma.PrismaPromise<GetEncabezadoCompraAggregateType<T>>

    /**
     * Group by EncabezadoCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncabezadoCompraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncabezadoCompraGroupByArgs['orderBy'] }
        : { orderBy?: EncabezadoCompraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncabezadoCompraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncabezadoCompraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncabezadoCompra model
   */
  readonly fields: EncabezadoCompraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncabezadoCompra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncabezadoCompraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuarioProveedor<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    detalleCompras<T extends EncabezadoCompra$detalleComprasArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoCompra$detalleComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    pedidos<T extends EncabezadoCompra$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoCompra$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EncabezadoCompra model
   */ 
  interface EncabezadoCompraFieldRefs {
    readonly id: FieldRef<"EncabezadoCompra", 'Int'>
    readonly fechaCompra: FieldRef<"EncabezadoCompra", 'DateTime'>
    readonly idUsuarioProveedor: FieldRef<"EncabezadoCompra", 'Int'>
    readonly idUsuarioRegistro: FieldRef<"EncabezadoCompra", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EncabezadoCompra findUnique
   */
  export type EncabezadoCompraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompra to fetch.
     */
    where: EncabezadoCompraWhereUniqueInput
  }


  /**
   * EncabezadoCompra findUniqueOrThrow
   */
  export type EncabezadoCompraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompra to fetch.
     */
    where: EncabezadoCompraWhereUniqueInput
  }


  /**
   * EncabezadoCompra findFirst
   */
  export type EncabezadoCompraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompra to fetch.
     */
    where?: EncabezadoCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoCompras to fetch.
     */
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncabezadoCompras.
     */
    cursor?: EncabezadoCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncabezadoCompras.
     */
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra findFirstOrThrow
   */
  export type EncabezadoCompraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompra to fetch.
     */
    where?: EncabezadoCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoCompras to fetch.
     */
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncabezadoCompras.
     */
    cursor?: EncabezadoCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncabezadoCompras.
     */
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra findMany
   */
  export type EncabezadoCompraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompras to fetch.
     */
    where?: EncabezadoCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoCompras to fetch.
     */
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncabezadoCompras.
     */
    cursor?: EncabezadoCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoCompras.
     */
    skip?: number
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra create
   */
  export type EncabezadoCompraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * The data needed to create a EncabezadoCompra.
     */
    data: XOR<EncabezadoCompraCreateInput, EncabezadoCompraUncheckedCreateInput>
  }


  /**
   * EncabezadoCompra createMany
   */
  export type EncabezadoCompraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncabezadoCompras.
     */
    data: EncabezadoCompraCreateManyInput | EncabezadoCompraCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EncabezadoCompra update
   */
  export type EncabezadoCompraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * The data needed to update a EncabezadoCompra.
     */
    data: XOR<EncabezadoCompraUpdateInput, EncabezadoCompraUncheckedUpdateInput>
    /**
     * Choose, which EncabezadoCompra to update.
     */
    where: EncabezadoCompraWhereUniqueInput
  }


  /**
   * EncabezadoCompra updateMany
   */
  export type EncabezadoCompraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncabezadoCompras.
     */
    data: XOR<EncabezadoCompraUpdateManyMutationInput, EncabezadoCompraUncheckedUpdateManyInput>
    /**
     * Filter which EncabezadoCompras to update
     */
    where?: EncabezadoCompraWhereInput
  }


  /**
   * EncabezadoCompra upsert
   */
  export type EncabezadoCompraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * The filter to search for the EncabezadoCompra to update in case it exists.
     */
    where: EncabezadoCompraWhereUniqueInput
    /**
     * In case the EncabezadoCompra found by the `where` argument doesn't exist, create a new EncabezadoCompra with this data.
     */
    create: XOR<EncabezadoCompraCreateInput, EncabezadoCompraUncheckedCreateInput>
    /**
     * In case the EncabezadoCompra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncabezadoCompraUpdateInput, EncabezadoCompraUncheckedUpdateInput>
  }


  /**
   * EncabezadoCompra delete
   */
  export type EncabezadoCompraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter which EncabezadoCompra to delete.
     */
    where: EncabezadoCompraWhereUniqueInput
  }


  /**
   * EncabezadoCompra deleteMany
   */
  export type EncabezadoCompraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncabezadoCompras to delete
     */
    where?: EncabezadoCompraWhereInput
  }


  /**
   * EncabezadoCompra.detalleCompras
   */
  export type EncabezadoCompra$detalleComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    where?: DetalleCompraWhereInput
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    cursor?: DetalleCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra.pedidos
   */
  export type EncabezadoCompra$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra without action
   */
  export type EncabezadoCompraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
  }



  /**
   * Model DetalleCompra
   */

  export type AggregateDetalleCompra = {
    _count: DetalleCompraCountAggregateOutputType | null
    _avg: DetalleCompraAvgAggregateOutputType | null
    _sum: DetalleCompraSumAggregateOutputType | null
    _min: DetalleCompraMinAggregateOutputType | null
    _max: DetalleCompraMaxAggregateOutputType | null
  }

  export type DetalleCompraAvgAggregateOutputType = {
    id: number | null
    idEncabezadoCompra: number | null
    idProducto: number | null
    idBodega: number | null
    cantidad: number | null
  }

  export type DetalleCompraSumAggregateOutputType = {
    id: number | null
    idEncabezadoCompra: number | null
    idProducto: number | null
    idBodega: number | null
    cantidad: number | null
  }

  export type DetalleCompraMinAggregateOutputType = {
    id: number | null
    idEncabezadoCompra: number | null
    idProducto: number | null
    idBodega: number | null
    cantidad: number | null
  }

  export type DetalleCompraMaxAggregateOutputType = {
    id: number | null
    idEncabezadoCompra: number | null
    idProducto: number | null
    idBodega: number | null
    cantidad: number | null
  }

  export type DetalleCompraCountAggregateOutputType = {
    id: number
    idEncabezadoCompra: number
    idProducto: number
    idBodega: number
    cantidad: number
    _all: number
  }


  export type DetalleCompraAvgAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
  }

  export type DetalleCompraSumAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
  }

  export type DetalleCompraMinAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
  }

  export type DetalleCompraMaxAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
  }

  export type DetalleCompraCountAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
    _all?: true
  }

  export type DetalleCompraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetalleCompra to aggregate.
     */
    where?: DetalleCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     */
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetalleCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetalleCompras
    **/
    _count?: true | DetalleCompraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetalleCompraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetalleCompraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetalleCompraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetalleCompraMaxAggregateInputType
  }

  export type GetDetalleCompraAggregateType<T extends DetalleCompraAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalleCompra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalleCompra[P]>
      : GetScalarType<T[P], AggregateDetalleCompra[P]>
  }




  export type DetalleCompraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleCompraWhereInput
    orderBy?: DetalleCompraOrderByWithAggregationInput | DetalleCompraOrderByWithAggregationInput[]
    by: DetalleCompraScalarFieldEnum[] | DetalleCompraScalarFieldEnum
    having?: DetalleCompraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetalleCompraCountAggregateInputType | true
    _avg?: DetalleCompraAvgAggregateInputType
    _sum?: DetalleCompraSumAggregateInputType
    _min?: DetalleCompraMinAggregateInputType
    _max?: DetalleCompraMaxAggregateInputType
  }

  export type DetalleCompraGroupByOutputType = {
    id: number
    idEncabezadoCompra: number
    idProducto: number
    idBodega: number
    cantidad: number
    _count: DetalleCompraCountAggregateOutputType | null
    _avg: DetalleCompraAvgAggregateOutputType | null
    _sum: DetalleCompraSumAggregateOutputType | null
    _min: DetalleCompraMinAggregateOutputType | null
    _max: DetalleCompraMaxAggregateOutputType | null
  }

  type GetDetalleCompraGroupByPayload<T extends DetalleCompraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetalleCompraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetalleCompraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetalleCompraGroupByOutputType[P]>
            : GetScalarType<T[P], DetalleCompraGroupByOutputType[P]>
        }
      >
    >


  export type DetalleCompraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idEncabezadoCompra?: boolean
    idProducto?: boolean
    idBodega?: boolean
    cantidad?: boolean
    productos?: boolean | ProductoDefaultArgs<ExtArgs>
    encabezadoCompras?: boolean | EncabezadoCompraDefaultArgs<ExtArgs>
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalleCompra"]>

  export type DetalleCompraSelectScalar = {
    id?: boolean
    idEncabezadoCompra?: boolean
    idProducto?: boolean
    idBodega?: boolean
    cantidad?: boolean
  }

  export type DetalleCompraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | ProductoDefaultArgs<ExtArgs>
    encabezadoCompras?: boolean | EncabezadoCompraDefaultArgs<ExtArgs>
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
  }


  export type $DetalleCompraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetalleCompra"
    objects: {
      productos: Prisma.$ProductoPayload<ExtArgs>
      encabezadoCompras: Prisma.$EncabezadoCompraPayload<ExtArgs>
      bodegas: Prisma.$BodegaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idEncabezadoCompra: number
      idProducto: number
      idBodega: number
      cantidad: number
    }, ExtArgs["result"]["detalleCompra"]>
    composites: {}
  }


  type DetalleCompraGetPayload<S extends boolean | null | undefined | DetalleCompraDefaultArgs> = $Result.GetResult<Prisma.$DetalleCompraPayload, S>

  type DetalleCompraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DetalleCompraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DetalleCompraCountAggregateInputType | true
    }

  export interface DetalleCompraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetalleCompra'], meta: { name: 'DetalleCompra' } }
    /**
     * Find zero or one DetalleCompra that matches the filter.
     * @param {DetalleCompraFindUniqueArgs} args - Arguments to find a DetalleCompra
     * @example
     * // Get one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DetalleCompraFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraFindUniqueArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DetalleCompra that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DetalleCompraFindUniqueOrThrowArgs} args - Arguments to find a DetalleCompra
     * @example
     * // Get one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DetalleCompraFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DetalleCompra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraFindFirstArgs} args - Arguments to find a DetalleCompra
     * @example
     * // Get one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DetalleCompraFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraFindFirstArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DetalleCompra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraFindFirstOrThrowArgs} args - Arguments to find a DetalleCompra
     * @example
     * // Get one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DetalleCompraFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DetalleCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetalleCompras
     * const detalleCompras = await prisma.detalleCompra.findMany()
     * 
     * // Get first 10 DetalleCompras
     * const detalleCompras = await prisma.detalleCompra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detalleCompraWithIdOnly = await prisma.detalleCompra.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DetalleCompraFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DetalleCompra.
     * @param {DetalleCompraCreateArgs} args - Arguments to create a DetalleCompra.
     * @example
     * // Create one DetalleCompra
     * const DetalleCompra = await prisma.detalleCompra.create({
     *   data: {
     *     // ... data to create a DetalleCompra
     *   }
     * })
     * 
    **/
    create<T extends DetalleCompraCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraCreateArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DetalleCompras.
     *     @param {DetalleCompraCreateManyArgs} args - Arguments to create many DetalleCompras.
     *     @example
     *     // Create many DetalleCompras
     *     const detalleCompra = await prisma.detalleCompra.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DetalleCompraCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DetalleCompra.
     * @param {DetalleCompraDeleteArgs} args - Arguments to delete one DetalleCompra.
     * @example
     * // Delete one DetalleCompra
     * const DetalleCompra = await prisma.detalleCompra.delete({
     *   where: {
     *     // ... filter to delete one DetalleCompra
     *   }
     * })
     * 
    **/
    delete<T extends DetalleCompraDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraDeleteArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DetalleCompra.
     * @param {DetalleCompraUpdateArgs} args - Arguments to update one DetalleCompra.
     * @example
     * // Update one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DetalleCompraUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraUpdateArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DetalleCompras.
     * @param {DetalleCompraDeleteManyArgs} args - Arguments to filter DetalleCompras to delete.
     * @example
     * // Delete a few DetalleCompras
     * const { count } = await prisma.detalleCompra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DetalleCompraDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetalleCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetalleCompras
     * const detalleCompra = await prisma.detalleCompra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DetalleCompraUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetalleCompra.
     * @param {DetalleCompraUpsertArgs} args - Arguments to update or create a DetalleCompra.
     * @example
     * // Update or create a DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.upsert({
     *   create: {
     *     // ... data to create a DetalleCompra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetalleCompra we want to update
     *   }
     * })
    **/
    upsert<T extends DetalleCompraUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraUpsertArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DetalleCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraCountArgs} args - Arguments to filter DetalleCompras to count.
     * @example
     * // Count the number of DetalleCompras
     * const count = await prisma.detalleCompra.count({
     *   where: {
     *     // ... the filter for the DetalleCompras we want to count
     *   }
     * })
    **/
    count<T extends DetalleCompraCountArgs>(
      args?: Subset<T, DetalleCompraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetalleCompraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetalleCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetalleCompraAggregateArgs>(args: Subset<T, DetalleCompraAggregateArgs>): Prisma.PrismaPromise<GetDetalleCompraAggregateType<T>>

    /**
     * Group by DetalleCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetalleCompraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetalleCompraGroupByArgs['orderBy'] }
        : { orderBy?: DetalleCompraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetalleCompraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalleCompraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetalleCompra model
   */
  readonly fields: DetalleCompraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetalleCompra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetalleCompraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    productos<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    encabezadoCompras<T extends EncabezadoCompraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoCompraDefaultArgs<ExtArgs>>): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bodegas<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DetalleCompra model
   */ 
  interface DetalleCompraFieldRefs {
    readonly id: FieldRef<"DetalleCompra", 'Int'>
    readonly idEncabezadoCompra: FieldRef<"DetalleCompra", 'Int'>
    readonly idProducto: FieldRef<"DetalleCompra", 'Int'>
    readonly idBodega: FieldRef<"DetalleCompra", 'Int'>
    readonly cantidad: FieldRef<"DetalleCompra", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * DetalleCompra findUnique
   */
  export type DetalleCompraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompra to fetch.
     */
    where: DetalleCompraWhereUniqueInput
  }


  /**
   * DetalleCompra findUniqueOrThrow
   */
  export type DetalleCompraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompra to fetch.
     */
    where: DetalleCompraWhereUniqueInput
  }


  /**
   * DetalleCompra findFirst
   */
  export type DetalleCompraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompra to fetch.
     */
    where?: DetalleCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     */
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleCompras.
     */
    cursor?: DetalleCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleCompras.
     */
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * DetalleCompra findFirstOrThrow
   */
  export type DetalleCompraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompra to fetch.
     */
    where?: DetalleCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     */
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleCompras.
     */
    cursor?: DetalleCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleCompras.
     */
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * DetalleCompra findMany
   */
  export type DetalleCompraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompras to fetch.
     */
    where?: DetalleCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     */
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetalleCompras.
     */
    cursor?: DetalleCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     */
    skip?: number
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * DetalleCompra create
   */
  export type DetalleCompraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * The data needed to create a DetalleCompra.
     */
    data: XOR<DetalleCompraCreateInput, DetalleCompraUncheckedCreateInput>
  }


  /**
   * DetalleCompra createMany
   */
  export type DetalleCompraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetalleCompras.
     */
    data: DetalleCompraCreateManyInput | DetalleCompraCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DetalleCompra update
   */
  export type DetalleCompraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * The data needed to update a DetalleCompra.
     */
    data: XOR<DetalleCompraUpdateInput, DetalleCompraUncheckedUpdateInput>
    /**
     * Choose, which DetalleCompra to update.
     */
    where: DetalleCompraWhereUniqueInput
  }


  /**
   * DetalleCompra updateMany
   */
  export type DetalleCompraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetalleCompras.
     */
    data: XOR<DetalleCompraUpdateManyMutationInput, DetalleCompraUncheckedUpdateManyInput>
    /**
     * Filter which DetalleCompras to update
     */
    where?: DetalleCompraWhereInput
  }


  /**
   * DetalleCompra upsert
   */
  export type DetalleCompraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * The filter to search for the DetalleCompra to update in case it exists.
     */
    where: DetalleCompraWhereUniqueInput
    /**
     * In case the DetalleCompra found by the `where` argument doesn't exist, create a new DetalleCompra with this data.
     */
    create: XOR<DetalleCompraCreateInput, DetalleCompraUncheckedCreateInput>
    /**
     * In case the DetalleCompra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetalleCompraUpdateInput, DetalleCompraUncheckedUpdateInput>
  }


  /**
   * DetalleCompra delete
   */
  export type DetalleCompraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter which DetalleCompra to delete.
     */
    where: DetalleCompraWhereUniqueInput
  }


  /**
   * DetalleCompra deleteMany
   */
  export type DetalleCompraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetalleCompras to delete
     */
    where?: DetalleCompraWhereInput
  }


  /**
   * DetalleCompra without action
   */
  export type DetalleCompraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
  }



  /**
   * Model Pedido
   */

  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    idEncabezadoCompra: number | null
    idEstado: number | null
  }

  export type PedidoSumAggregateOutputType = {
    idEncabezadoCompra: number | null
    idEstado: number | null
  }

  export type PedidoMinAggregateOutputType = {
    idEncabezadoCompra: number | null
    fechaPedido: Date | null
    idEstado: number | null
    observaciones: string | null
  }

  export type PedidoMaxAggregateOutputType = {
    idEncabezadoCompra: number | null
    fechaPedido: Date | null
    idEstado: number | null
    observaciones: string | null
  }

  export type PedidoCountAggregateOutputType = {
    idEncabezadoCompra: number
    fechaPedido: number
    idEstado: number
    observaciones: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    idEncabezadoCompra?: true
    idEstado?: true
  }

  export type PedidoSumAggregateInputType = {
    idEncabezadoCompra?: true
    idEstado?: true
  }

  export type PedidoMinAggregateInputType = {
    idEncabezadoCompra?: true
    fechaPedido?: true
    idEstado?: true
    observaciones?: true
  }

  export type PedidoMaxAggregateInputType = {
    idEncabezadoCompra?: true
    fechaPedido?: true
    idEstado?: true
    observaciones?: true
  }

  export type PedidoCountAggregateInputType = {
    idEncabezadoCompra?: true
    fechaPedido?: true
    idEstado?: true
    observaciones?: true
    _all?: true
  }

  export type PedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedido to aggregate.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithAggregationInput | PedidoOrderByWithAggregationInput[]
    by: PedidoScalarFieldEnum[] | PedidoScalarFieldEnum
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }

  export type PedidoGroupByOutputType = {
    idEncabezadoCompra: number
    fechaPedido: Date
    idEstado: number
    observaciones: string | null
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEncabezadoCompra?: boolean
    fechaPedido?: boolean
    idEstado?: boolean
    observaciones?: boolean
    estadoPedido?: boolean | EstadoDefaultArgs<ExtArgs>
    encabezadoCompras?: boolean | EncabezadoCompraDefaultArgs<ExtArgs>
    TrasladoBodegas?: boolean | Pedido$TrasladoBodegasArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectScalar = {
    idEncabezadoCompra?: boolean
    fechaPedido?: boolean
    idEstado?: boolean
    observaciones?: boolean
  }

  export type PedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estadoPedido?: boolean | EstadoDefaultArgs<ExtArgs>
    encabezadoCompras?: boolean | EncabezadoCompraDefaultArgs<ExtArgs>
    TrasladoBodegas?: boolean | Pedido$TrasladoBodegasArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pedido"
    objects: {
      estadoPedido: Prisma.$EstadoPayload<ExtArgs>
      encabezadoCompras: Prisma.$EncabezadoCompraPayload<ExtArgs>
      TrasladoBodegas: Prisma.$TrasladoBodegasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idEncabezadoCompra: number
      fechaPedido: Date
      idEstado: number
      observaciones: string | null
    }, ExtArgs["result"]["pedido"]>
    composites: {}
  }


  type PedidoGetPayload<S extends boolean | null | undefined | PedidoDefaultArgs> = $Result.GetResult<Prisma.$PedidoPayload, S>

  type PedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PedidoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface PedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pedido'], meta: { name: 'Pedido' } }
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoFindUniqueArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pedido that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindFirstArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `idEncabezadoCompra`
     * const pedidoWithIdEncabezadoCompraOnly = await prisma.pedido.findMany({ select: { idEncabezadoCompra: true } })
     * 
    **/
    findMany<T extends PedidoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
    **/
    create<T extends PedidoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoCreateArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pedidos.
     *     @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     *     @example
     *     // Create many Pedidos
     *     const pedido = await prisma.pedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
    **/
    delete<T extends PedidoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeleteArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpdateArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpsertArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pedido model
   */
  readonly fields: PedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    estadoPedido<T extends EstadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstadoDefaultArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    encabezadoCompras<T extends EncabezadoCompraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoCompraDefaultArgs<ExtArgs>>): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    TrasladoBodegas<T extends Pedido$TrasladoBodegasArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$TrasladoBodegasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Pedido model
   */ 
  interface PedidoFieldRefs {
    readonly idEncabezadoCompra: FieldRef<"Pedido", 'Int'>
    readonly fechaPedido: FieldRef<"Pedido", 'DateTime'>
    readonly idEstado: FieldRef<"Pedido", 'Int'>
    readonly observaciones: FieldRef<"Pedido", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Pedido findUnique
   */
  export type PedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido findFirst
   */
  export type PedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedidos to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido create
   */
  export type PedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pedido.
     */
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }


  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Pedido update
   */
  export type PedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pedido.
     */
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
  }


  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     */
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     */
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }


  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter which Pedido to delete.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedidos to delete
     */
    where?: PedidoWhereInput
  }


  /**
   * Pedido.TrasladoBodegas
   */
  export type Pedido$TrasladoBodegasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    where?: TrasladoBodegasWhereInput
    orderBy?: TrasladoBodegasOrderByWithRelationInput | TrasladoBodegasOrderByWithRelationInput[]
    cursor?: TrasladoBodegasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoBodegasScalarFieldEnum | TrasladoBodegasScalarFieldEnum[]
  }


  /**
   * Pedido without action
   */
  export type PedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
  }



  /**
   * Model TrasladoBodegas
   */

  export type AggregateTrasladoBodegas = {
    _count: TrasladoBodegasCountAggregateOutputType | null
    _avg: TrasladoBodegasAvgAggregateOutputType | null
    _sum: TrasladoBodegasSumAggregateOutputType | null
    _min: TrasladoBodegasMinAggregateOutputType | null
    _max: TrasladoBodegasMaxAggregateOutputType | null
  }

  export type TrasladoBodegasAvgAggregateOutputType = {
    idPedido: number | null
    idDestino: number | null
  }

  export type TrasladoBodegasSumAggregateOutputType = {
    idPedido: number | null
    idDestino: number | null
  }

  export type TrasladoBodegasMinAggregateOutputType = {
    idPedido: number | null
    idDestino: number | null
  }

  export type TrasladoBodegasMaxAggregateOutputType = {
    idPedido: number | null
    idDestino: number | null
  }

  export type TrasladoBodegasCountAggregateOutputType = {
    idPedido: number
    idDestino: number
    _all: number
  }


  export type TrasladoBodegasAvgAggregateInputType = {
    idPedido?: true
    idDestino?: true
  }

  export type TrasladoBodegasSumAggregateInputType = {
    idPedido?: true
    idDestino?: true
  }

  export type TrasladoBodegasMinAggregateInputType = {
    idPedido?: true
    idDestino?: true
  }

  export type TrasladoBodegasMaxAggregateInputType = {
    idPedido?: true
    idDestino?: true
  }

  export type TrasladoBodegasCountAggregateInputType = {
    idPedido?: true
    idDestino?: true
    _all?: true
  }

  export type TrasladoBodegasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrasladoBodegas to aggregate.
     */
    where?: TrasladoBodegasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrasladoBodegases to fetch.
     */
    orderBy?: TrasladoBodegasOrderByWithRelationInput | TrasladoBodegasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrasladoBodegasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrasladoBodegases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrasladoBodegases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrasladoBodegases
    **/
    _count?: true | TrasladoBodegasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrasladoBodegasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrasladoBodegasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrasladoBodegasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrasladoBodegasMaxAggregateInputType
  }

  export type GetTrasladoBodegasAggregateType<T extends TrasladoBodegasAggregateArgs> = {
        [P in keyof T & keyof AggregateTrasladoBodegas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrasladoBodegas[P]>
      : GetScalarType<T[P], AggregateTrasladoBodegas[P]>
  }




  export type TrasladoBodegasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoBodegasWhereInput
    orderBy?: TrasladoBodegasOrderByWithAggregationInput | TrasladoBodegasOrderByWithAggregationInput[]
    by: TrasladoBodegasScalarFieldEnum[] | TrasladoBodegasScalarFieldEnum
    having?: TrasladoBodegasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrasladoBodegasCountAggregateInputType | true
    _avg?: TrasladoBodegasAvgAggregateInputType
    _sum?: TrasladoBodegasSumAggregateInputType
    _min?: TrasladoBodegasMinAggregateInputType
    _max?: TrasladoBodegasMaxAggregateInputType
  }

  export type TrasladoBodegasGroupByOutputType = {
    idPedido: number
    idDestino: number
    _count: TrasladoBodegasCountAggregateOutputType | null
    _avg: TrasladoBodegasAvgAggregateOutputType | null
    _sum: TrasladoBodegasSumAggregateOutputType | null
    _min: TrasladoBodegasMinAggregateOutputType | null
    _max: TrasladoBodegasMaxAggregateOutputType | null
  }

  type GetTrasladoBodegasGroupByPayload<T extends TrasladoBodegasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrasladoBodegasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrasladoBodegasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrasladoBodegasGroupByOutputType[P]>
            : GetScalarType<T[P], TrasladoBodegasGroupByOutputType[P]>
        }
      >
    >


  export type TrasladoBodegasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPedido?: boolean
    idDestino?: boolean
    pedidos?: boolean | PedidoDefaultArgs<ExtArgs>
    destinos?: boolean | TrasladoDestinoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trasladoBodegas"]>

  export type TrasladoBodegasSelectScalar = {
    idPedido?: boolean
    idDestino?: boolean
  }

  export type TrasladoBodegasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | PedidoDefaultArgs<ExtArgs>
    destinos?: boolean | TrasladoDestinoDefaultArgs<ExtArgs>
  }


  export type $TrasladoBodegasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrasladoBodegas"
    objects: {
      pedidos: Prisma.$PedidoPayload<ExtArgs>
      destinos: Prisma.$TrasladoDestinoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPedido: number
      idDestino: number
    }, ExtArgs["result"]["trasladoBodegas"]>
    composites: {}
  }


  type TrasladoBodegasGetPayload<S extends boolean | null | undefined | TrasladoBodegasDefaultArgs> = $Result.GetResult<Prisma.$TrasladoBodegasPayload, S>

  type TrasladoBodegasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrasladoBodegasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrasladoBodegasCountAggregateInputType | true
    }

  export interface TrasladoBodegasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrasladoBodegas'], meta: { name: 'TrasladoBodegas' } }
    /**
     * Find zero or one TrasladoBodegas that matches the filter.
     * @param {TrasladoBodegasFindUniqueArgs} args - Arguments to find a TrasladoBodegas
     * @example
     * // Get one TrasladoBodegas
     * const trasladoBodegas = await prisma.trasladoBodegas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrasladoBodegasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoBodegasFindUniqueArgs<ExtArgs>>
    ): Prisma__TrasladoBodegasClient<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TrasladoBodegas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrasladoBodegasFindUniqueOrThrowArgs} args - Arguments to find a TrasladoBodegas
     * @example
     * // Get one TrasladoBodegas
     * const trasladoBodegas = await prisma.trasladoBodegas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrasladoBodegasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoBodegasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrasladoBodegasClient<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TrasladoBodegas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoBodegasFindFirstArgs} args - Arguments to find a TrasladoBodegas
     * @example
     * // Get one TrasladoBodegas
     * const trasladoBodegas = await prisma.trasladoBodegas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrasladoBodegasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoBodegasFindFirstArgs<ExtArgs>>
    ): Prisma__TrasladoBodegasClient<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TrasladoBodegas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoBodegasFindFirstOrThrowArgs} args - Arguments to find a TrasladoBodegas
     * @example
     * // Get one TrasladoBodegas
     * const trasladoBodegas = await prisma.trasladoBodegas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrasladoBodegasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoBodegasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrasladoBodegasClient<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TrasladoBodegases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoBodegasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrasladoBodegases
     * const trasladoBodegases = await prisma.trasladoBodegas.findMany()
     * 
     * // Get first 10 TrasladoBodegases
     * const trasladoBodegases = await prisma.trasladoBodegas.findMany({ take: 10 })
     * 
     * // Only select the `idPedido`
     * const trasladoBodegasWithIdPedidoOnly = await prisma.trasladoBodegas.findMany({ select: { idPedido: true } })
     * 
    **/
    findMany<T extends TrasladoBodegasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoBodegasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TrasladoBodegas.
     * @param {TrasladoBodegasCreateArgs} args - Arguments to create a TrasladoBodegas.
     * @example
     * // Create one TrasladoBodegas
     * const TrasladoBodegas = await prisma.trasladoBodegas.create({
     *   data: {
     *     // ... data to create a TrasladoBodegas
     *   }
     * })
     * 
    **/
    create<T extends TrasladoBodegasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoBodegasCreateArgs<ExtArgs>>
    ): Prisma__TrasladoBodegasClient<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TrasladoBodegases.
     *     @param {TrasladoBodegasCreateManyArgs} args - Arguments to create many TrasladoBodegases.
     *     @example
     *     // Create many TrasladoBodegases
     *     const trasladoBodegas = await prisma.trasladoBodegas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrasladoBodegasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoBodegasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrasladoBodegas.
     * @param {TrasladoBodegasDeleteArgs} args - Arguments to delete one TrasladoBodegas.
     * @example
     * // Delete one TrasladoBodegas
     * const TrasladoBodegas = await prisma.trasladoBodegas.delete({
     *   where: {
     *     // ... filter to delete one TrasladoBodegas
     *   }
     * })
     * 
    **/
    delete<T extends TrasladoBodegasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoBodegasDeleteArgs<ExtArgs>>
    ): Prisma__TrasladoBodegasClient<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TrasladoBodegas.
     * @param {TrasladoBodegasUpdateArgs} args - Arguments to update one TrasladoBodegas.
     * @example
     * // Update one TrasladoBodegas
     * const trasladoBodegas = await prisma.trasladoBodegas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrasladoBodegasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoBodegasUpdateArgs<ExtArgs>>
    ): Prisma__TrasladoBodegasClient<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TrasladoBodegases.
     * @param {TrasladoBodegasDeleteManyArgs} args - Arguments to filter TrasladoBodegases to delete.
     * @example
     * // Delete a few TrasladoBodegases
     * const { count } = await prisma.trasladoBodegas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrasladoBodegasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoBodegasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrasladoBodegases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoBodegasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrasladoBodegases
     * const trasladoBodegas = await prisma.trasladoBodegas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrasladoBodegasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoBodegasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrasladoBodegas.
     * @param {TrasladoBodegasUpsertArgs} args - Arguments to update or create a TrasladoBodegas.
     * @example
     * // Update or create a TrasladoBodegas
     * const trasladoBodegas = await prisma.trasladoBodegas.upsert({
     *   create: {
     *     // ... data to create a TrasladoBodegas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrasladoBodegas we want to update
     *   }
     * })
    **/
    upsert<T extends TrasladoBodegasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoBodegasUpsertArgs<ExtArgs>>
    ): Prisma__TrasladoBodegasClient<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TrasladoBodegases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoBodegasCountArgs} args - Arguments to filter TrasladoBodegases to count.
     * @example
     * // Count the number of TrasladoBodegases
     * const count = await prisma.trasladoBodegas.count({
     *   where: {
     *     // ... the filter for the TrasladoBodegases we want to count
     *   }
     * })
    **/
    count<T extends TrasladoBodegasCountArgs>(
      args?: Subset<T, TrasladoBodegasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrasladoBodegasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrasladoBodegas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoBodegasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrasladoBodegasAggregateArgs>(args: Subset<T, TrasladoBodegasAggregateArgs>): Prisma.PrismaPromise<GetTrasladoBodegasAggregateType<T>>

    /**
     * Group by TrasladoBodegas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoBodegasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrasladoBodegasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrasladoBodegasGroupByArgs['orderBy'] }
        : { orderBy?: TrasladoBodegasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrasladoBodegasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrasladoBodegasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrasladoBodegas model
   */
  readonly fields: TrasladoBodegasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrasladoBodegas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrasladoBodegasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pedidos<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    destinos<T extends TrasladoDestinoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrasladoDestinoDefaultArgs<ExtArgs>>): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TrasladoBodegas model
   */ 
  interface TrasladoBodegasFieldRefs {
    readonly idPedido: FieldRef<"TrasladoBodegas", 'Int'>
    readonly idDestino: FieldRef<"TrasladoBodegas", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TrasladoBodegas findUnique
   */
  export type TrasladoBodegasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoBodegas to fetch.
     */
    where: TrasladoBodegasWhereUniqueInput
  }


  /**
   * TrasladoBodegas findUniqueOrThrow
   */
  export type TrasladoBodegasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoBodegas to fetch.
     */
    where: TrasladoBodegasWhereUniqueInput
  }


  /**
   * TrasladoBodegas findFirst
   */
  export type TrasladoBodegasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoBodegas to fetch.
     */
    where?: TrasladoBodegasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrasladoBodegases to fetch.
     */
    orderBy?: TrasladoBodegasOrderByWithRelationInput | TrasladoBodegasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrasladoBodegases.
     */
    cursor?: TrasladoBodegasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrasladoBodegases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrasladoBodegases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrasladoBodegases.
     */
    distinct?: TrasladoBodegasScalarFieldEnum | TrasladoBodegasScalarFieldEnum[]
  }


  /**
   * TrasladoBodegas findFirstOrThrow
   */
  export type TrasladoBodegasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoBodegas to fetch.
     */
    where?: TrasladoBodegasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrasladoBodegases to fetch.
     */
    orderBy?: TrasladoBodegasOrderByWithRelationInput | TrasladoBodegasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrasladoBodegases.
     */
    cursor?: TrasladoBodegasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrasladoBodegases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrasladoBodegases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrasladoBodegases.
     */
    distinct?: TrasladoBodegasScalarFieldEnum | TrasladoBodegasScalarFieldEnum[]
  }


  /**
   * TrasladoBodegas findMany
   */
  export type TrasladoBodegasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoBodegases to fetch.
     */
    where?: TrasladoBodegasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrasladoBodegases to fetch.
     */
    orderBy?: TrasladoBodegasOrderByWithRelationInput | TrasladoBodegasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrasladoBodegases.
     */
    cursor?: TrasladoBodegasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrasladoBodegases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrasladoBodegases.
     */
    skip?: number
    distinct?: TrasladoBodegasScalarFieldEnum | TrasladoBodegasScalarFieldEnum[]
  }


  /**
   * TrasladoBodegas create
   */
  export type TrasladoBodegasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * The data needed to create a TrasladoBodegas.
     */
    data: XOR<TrasladoBodegasCreateInput, TrasladoBodegasUncheckedCreateInput>
  }


  /**
   * TrasladoBodegas createMany
   */
  export type TrasladoBodegasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrasladoBodegases.
     */
    data: TrasladoBodegasCreateManyInput | TrasladoBodegasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TrasladoBodegas update
   */
  export type TrasladoBodegasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * The data needed to update a TrasladoBodegas.
     */
    data: XOR<TrasladoBodegasUpdateInput, TrasladoBodegasUncheckedUpdateInput>
    /**
     * Choose, which TrasladoBodegas to update.
     */
    where: TrasladoBodegasWhereUniqueInput
  }


  /**
   * TrasladoBodegas updateMany
   */
  export type TrasladoBodegasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrasladoBodegases.
     */
    data: XOR<TrasladoBodegasUpdateManyMutationInput, TrasladoBodegasUncheckedUpdateManyInput>
    /**
     * Filter which TrasladoBodegases to update
     */
    where?: TrasladoBodegasWhereInput
  }


  /**
   * TrasladoBodegas upsert
   */
  export type TrasladoBodegasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * The filter to search for the TrasladoBodegas to update in case it exists.
     */
    where: TrasladoBodegasWhereUniqueInput
    /**
     * In case the TrasladoBodegas found by the `where` argument doesn't exist, create a new TrasladoBodegas with this data.
     */
    create: XOR<TrasladoBodegasCreateInput, TrasladoBodegasUncheckedCreateInput>
    /**
     * In case the TrasladoBodegas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrasladoBodegasUpdateInput, TrasladoBodegasUncheckedUpdateInput>
  }


  /**
   * TrasladoBodegas delete
   */
  export type TrasladoBodegasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    /**
     * Filter which TrasladoBodegas to delete.
     */
    where: TrasladoBodegasWhereUniqueInput
  }


  /**
   * TrasladoBodegas deleteMany
   */
  export type TrasladoBodegasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrasladoBodegases to delete
     */
    where?: TrasladoBodegasWhereInput
  }


  /**
   * TrasladoBodegas without action
   */
  export type TrasladoBodegasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
  }



  /**
   * Model TrasladoDestino
   */

  export type AggregateTrasladoDestino = {
    _count: TrasladoDestinoCountAggregateOutputType | null
    _avg: TrasladoDestinoAvgAggregateOutputType | null
    _sum: TrasladoDestinoSumAggregateOutputType | null
    _min: TrasladoDestinoMinAggregateOutputType | null
    _max: TrasladoDestinoMaxAggregateOutputType | null
  }

  export type TrasladoDestinoAvgAggregateOutputType = {
    id: number | null
    idBodegaDestino: number | null
    idEstado: number | null
  }

  export type TrasladoDestinoSumAggregateOutputType = {
    id: number | null
    idBodegaDestino: number | null
    idEstado: number | null
  }

  export type TrasladoDestinoMinAggregateOutputType = {
    id: number | null
    idBodegaDestino: number | null
    fechaRecibido: Date | null
    idEstado: number | null
  }

  export type TrasladoDestinoMaxAggregateOutputType = {
    id: number | null
    idBodegaDestino: number | null
    fechaRecibido: Date | null
    idEstado: number | null
  }

  export type TrasladoDestinoCountAggregateOutputType = {
    id: number
    idBodegaDestino: number
    fechaRecibido: number
    idEstado: number
    _all: number
  }


  export type TrasladoDestinoAvgAggregateInputType = {
    id?: true
    idBodegaDestino?: true
    idEstado?: true
  }

  export type TrasladoDestinoSumAggregateInputType = {
    id?: true
    idBodegaDestino?: true
    idEstado?: true
  }

  export type TrasladoDestinoMinAggregateInputType = {
    id?: true
    idBodegaDestino?: true
    fechaRecibido?: true
    idEstado?: true
  }

  export type TrasladoDestinoMaxAggregateInputType = {
    id?: true
    idBodegaDestino?: true
    fechaRecibido?: true
    idEstado?: true
  }

  export type TrasladoDestinoCountAggregateInputType = {
    id?: true
    idBodegaDestino?: true
    fechaRecibido?: true
    idEstado?: true
    _all?: true
  }

  export type TrasladoDestinoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrasladoDestino to aggregate.
     */
    where?: TrasladoDestinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrasladoDestinos to fetch.
     */
    orderBy?: TrasladoDestinoOrderByWithRelationInput | TrasladoDestinoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrasladoDestinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrasladoDestinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrasladoDestinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrasladoDestinos
    **/
    _count?: true | TrasladoDestinoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrasladoDestinoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrasladoDestinoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrasladoDestinoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrasladoDestinoMaxAggregateInputType
  }

  export type GetTrasladoDestinoAggregateType<T extends TrasladoDestinoAggregateArgs> = {
        [P in keyof T & keyof AggregateTrasladoDestino]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrasladoDestino[P]>
      : GetScalarType<T[P], AggregateTrasladoDestino[P]>
  }




  export type TrasladoDestinoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoDestinoWhereInput
    orderBy?: TrasladoDestinoOrderByWithAggregationInput | TrasladoDestinoOrderByWithAggregationInput[]
    by: TrasladoDestinoScalarFieldEnum[] | TrasladoDestinoScalarFieldEnum
    having?: TrasladoDestinoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrasladoDestinoCountAggregateInputType | true
    _avg?: TrasladoDestinoAvgAggregateInputType
    _sum?: TrasladoDestinoSumAggregateInputType
    _min?: TrasladoDestinoMinAggregateInputType
    _max?: TrasladoDestinoMaxAggregateInputType
  }

  export type TrasladoDestinoGroupByOutputType = {
    id: number
    idBodegaDestino: number
    fechaRecibido: Date
    idEstado: number
    _count: TrasladoDestinoCountAggregateOutputType | null
    _avg: TrasladoDestinoAvgAggregateOutputType | null
    _sum: TrasladoDestinoSumAggregateOutputType | null
    _min: TrasladoDestinoMinAggregateOutputType | null
    _max: TrasladoDestinoMaxAggregateOutputType | null
  }

  type GetTrasladoDestinoGroupByPayload<T extends TrasladoDestinoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrasladoDestinoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrasladoDestinoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrasladoDestinoGroupByOutputType[P]>
            : GetScalarType<T[P], TrasladoDestinoGroupByOutputType[P]>
        }
      >
    >


  export type TrasladoDestinoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idBodegaDestino?: boolean
    fechaRecibido?: boolean
    idEstado?: boolean
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
    estadoDestino?: boolean | EstadoDefaultArgs<ExtArgs>
    TrasladoBodegas?: boolean | TrasladoDestino$TrasladoBodegasArgs<ExtArgs>
    _count?: boolean | TrasladoDestinoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trasladoDestino"]>

  export type TrasladoDestinoSelectScalar = {
    id?: boolean
    idBodegaDestino?: boolean
    fechaRecibido?: boolean
    idEstado?: boolean
  }

  export type TrasladoDestinoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
    estadoDestino?: boolean | EstadoDefaultArgs<ExtArgs>
    TrasladoBodegas?: boolean | TrasladoDestino$TrasladoBodegasArgs<ExtArgs>
    _count?: boolean | TrasladoDestinoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TrasladoDestinoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrasladoDestino"
    objects: {
      bodegas: Prisma.$BodegaPayload<ExtArgs>
      estadoDestino: Prisma.$EstadoPayload<ExtArgs>
      TrasladoBodegas: Prisma.$TrasladoBodegasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idBodegaDestino: number
      fechaRecibido: Date
      idEstado: number
    }, ExtArgs["result"]["trasladoDestino"]>
    composites: {}
  }


  type TrasladoDestinoGetPayload<S extends boolean | null | undefined | TrasladoDestinoDefaultArgs> = $Result.GetResult<Prisma.$TrasladoDestinoPayload, S>

  type TrasladoDestinoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrasladoDestinoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrasladoDestinoCountAggregateInputType | true
    }

  export interface TrasladoDestinoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrasladoDestino'], meta: { name: 'TrasladoDestino' } }
    /**
     * Find zero or one TrasladoDestino that matches the filter.
     * @param {TrasladoDestinoFindUniqueArgs} args - Arguments to find a TrasladoDestino
     * @example
     * // Get one TrasladoDestino
     * const trasladoDestino = await prisma.trasladoDestino.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrasladoDestinoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoDestinoFindUniqueArgs<ExtArgs>>
    ): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TrasladoDestino that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrasladoDestinoFindUniqueOrThrowArgs} args - Arguments to find a TrasladoDestino
     * @example
     * // Get one TrasladoDestino
     * const trasladoDestino = await prisma.trasladoDestino.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrasladoDestinoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoDestinoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TrasladoDestino that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoDestinoFindFirstArgs} args - Arguments to find a TrasladoDestino
     * @example
     * // Get one TrasladoDestino
     * const trasladoDestino = await prisma.trasladoDestino.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrasladoDestinoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoDestinoFindFirstArgs<ExtArgs>>
    ): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TrasladoDestino that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoDestinoFindFirstOrThrowArgs} args - Arguments to find a TrasladoDestino
     * @example
     * // Get one TrasladoDestino
     * const trasladoDestino = await prisma.trasladoDestino.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrasladoDestinoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoDestinoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TrasladoDestinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoDestinoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrasladoDestinos
     * const trasladoDestinos = await prisma.trasladoDestino.findMany()
     * 
     * // Get first 10 TrasladoDestinos
     * const trasladoDestinos = await prisma.trasladoDestino.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trasladoDestinoWithIdOnly = await prisma.trasladoDestino.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrasladoDestinoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoDestinoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TrasladoDestino.
     * @param {TrasladoDestinoCreateArgs} args - Arguments to create a TrasladoDestino.
     * @example
     * // Create one TrasladoDestino
     * const TrasladoDestino = await prisma.trasladoDestino.create({
     *   data: {
     *     // ... data to create a TrasladoDestino
     *   }
     * })
     * 
    **/
    create<T extends TrasladoDestinoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoDestinoCreateArgs<ExtArgs>>
    ): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TrasladoDestinos.
     *     @param {TrasladoDestinoCreateManyArgs} args - Arguments to create many TrasladoDestinos.
     *     @example
     *     // Create many TrasladoDestinos
     *     const trasladoDestino = await prisma.trasladoDestino.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrasladoDestinoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoDestinoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrasladoDestino.
     * @param {TrasladoDestinoDeleteArgs} args - Arguments to delete one TrasladoDestino.
     * @example
     * // Delete one TrasladoDestino
     * const TrasladoDestino = await prisma.trasladoDestino.delete({
     *   where: {
     *     // ... filter to delete one TrasladoDestino
     *   }
     * })
     * 
    **/
    delete<T extends TrasladoDestinoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoDestinoDeleteArgs<ExtArgs>>
    ): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TrasladoDestino.
     * @param {TrasladoDestinoUpdateArgs} args - Arguments to update one TrasladoDestino.
     * @example
     * // Update one TrasladoDestino
     * const trasladoDestino = await prisma.trasladoDestino.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrasladoDestinoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoDestinoUpdateArgs<ExtArgs>>
    ): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TrasladoDestinos.
     * @param {TrasladoDestinoDeleteManyArgs} args - Arguments to filter TrasladoDestinos to delete.
     * @example
     * // Delete a few TrasladoDestinos
     * const { count } = await prisma.trasladoDestino.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrasladoDestinoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoDestinoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrasladoDestinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoDestinoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrasladoDestinos
     * const trasladoDestino = await prisma.trasladoDestino.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrasladoDestinoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoDestinoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrasladoDestino.
     * @param {TrasladoDestinoUpsertArgs} args - Arguments to update or create a TrasladoDestino.
     * @example
     * // Update or create a TrasladoDestino
     * const trasladoDestino = await prisma.trasladoDestino.upsert({
     *   create: {
     *     // ... data to create a TrasladoDestino
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrasladoDestino we want to update
     *   }
     * })
    **/
    upsert<T extends TrasladoDestinoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoDestinoUpsertArgs<ExtArgs>>
    ): Prisma__TrasladoDestinoClient<$Result.GetResult<Prisma.$TrasladoDestinoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TrasladoDestinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoDestinoCountArgs} args - Arguments to filter TrasladoDestinos to count.
     * @example
     * // Count the number of TrasladoDestinos
     * const count = await prisma.trasladoDestino.count({
     *   where: {
     *     // ... the filter for the TrasladoDestinos we want to count
     *   }
     * })
    **/
    count<T extends TrasladoDestinoCountArgs>(
      args?: Subset<T, TrasladoDestinoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrasladoDestinoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrasladoDestino.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoDestinoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrasladoDestinoAggregateArgs>(args: Subset<T, TrasladoDestinoAggregateArgs>): Prisma.PrismaPromise<GetTrasladoDestinoAggregateType<T>>

    /**
     * Group by TrasladoDestino.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoDestinoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrasladoDestinoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrasladoDestinoGroupByArgs['orderBy'] }
        : { orderBy?: TrasladoDestinoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrasladoDestinoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrasladoDestinoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrasladoDestino model
   */
  readonly fields: TrasladoDestinoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrasladoDestino.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrasladoDestinoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bodegas<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    estadoDestino<T extends EstadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstadoDefaultArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    TrasladoBodegas<T extends TrasladoDestino$TrasladoBodegasArgs<ExtArgs> = {}>(args?: Subset<T, TrasladoDestino$TrasladoBodegasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoBodegasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TrasladoDestino model
   */ 
  interface TrasladoDestinoFieldRefs {
    readonly id: FieldRef<"TrasladoDestino", 'Int'>
    readonly idBodegaDestino: FieldRef<"TrasladoDestino", 'Int'>
    readonly fechaRecibido: FieldRef<"TrasladoDestino", 'DateTime'>
    readonly idEstado: FieldRef<"TrasladoDestino", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TrasladoDestino findUnique
   */
  export type TrasladoDestinoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoDestino to fetch.
     */
    where: TrasladoDestinoWhereUniqueInput
  }


  /**
   * TrasladoDestino findUniqueOrThrow
   */
  export type TrasladoDestinoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoDestino to fetch.
     */
    where: TrasladoDestinoWhereUniqueInput
  }


  /**
   * TrasladoDestino findFirst
   */
  export type TrasladoDestinoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoDestino to fetch.
     */
    where?: TrasladoDestinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrasladoDestinos to fetch.
     */
    orderBy?: TrasladoDestinoOrderByWithRelationInput | TrasladoDestinoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrasladoDestinos.
     */
    cursor?: TrasladoDestinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrasladoDestinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrasladoDestinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrasladoDestinos.
     */
    distinct?: TrasladoDestinoScalarFieldEnum | TrasladoDestinoScalarFieldEnum[]
  }


  /**
   * TrasladoDestino findFirstOrThrow
   */
  export type TrasladoDestinoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoDestino to fetch.
     */
    where?: TrasladoDestinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrasladoDestinos to fetch.
     */
    orderBy?: TrasladoDestinoOrderByWithRelationInput | TrasladoDestinoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrasladoDestinos.
     */
    cursor?: TrasladoDestinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrasladoDestinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrasladoDestinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrasladoDestinos.
     */
    distinct?: TrasladoDestinoScalarFieldEnum | TrasladoDestinoScalarFieldEnum[]
  }


  /**
   * TrasladoDestino findMany
   */
  export type TrasladoDestinoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * Filter, which TrasladoDestinos to fetch.
     */
    where?: TrasladoDestinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrasladoDestinos to fetch.
     */
    orderBy?: TrasladoDestinoOrderByWithRelationInput | TrasladoDestinoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrasladoDestinos.
     */
    cursor?: TrasladoDestinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrasladoDestinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrasladoDestinos.
     */
    skip?: number
    distinct?: TrasladoDestinoScalarFieldEnum | TrasladoDestinoScalarFieldEnum[]
  }


  /**
   * TrasladoDestino create
   */
  export type TrasladoDestinoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * The data needed to create a TrasladoDestino.
     */
    data: XOR<TrasladoDestinoCreateInput, TrasladoDestinoUncheckedCreateInput>
  }


  /**
   * TrasladoDestino createMany
   */
  export type TrasladoDestinoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrasladoDestinos.
     */
    data: TrasladoDestinoCreateManyInput | TrasladoDestinoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TrasladoDestino update
   */
  export type TrasladoDestinoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * The data needed to update a TrasladoDestino.
     */
    data: XOR<TrasladoDestinoUpdateInput, TrasladoDestinoUncheckedUpdateInput>
    /**
     * Choose, which TrasladoDestino to update.
     */
    where: TrasladoDestinoWhereUniqueInput
  }


  /**
   * TrasladoDestino updateMany
   */
  export type TrasladoDestinoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrasladoDestinos.
     */
    data: XOR<TrasladoDestinoUpdateManyMutationInput, TrasladoDestinoUncheckedUpdateManyInput>
    /**
     * Filter which TrasladoDestinos to update
     */
    where?: TrasladoDestinoWhereInput
  }


  /**
   * TrasladoDestino upsert
   */
  export type TrasladoDestinoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * The filter to search for the TrasladoDestino to update in case it exists.
     */
    where: TrasladoDestinoWhereUniqueInput
    /**
     * In case the TrasladoDestino found by the `where` argument doesn't exist, create a new TrasladoDestino with this data.
     */
    create: XOR<TrasladoDestinoCreateInput, TrasladoDestinoUncheckedCreateInput>
    /**
     * In case the TrasladoDestino was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrasladoDestinoUpdateInput, TrasladoDestinoUncheckedUpdateInput>
  }


  /**
   * TrasladoDestino delete
   */
  export type TrasladoDestinoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
    /**
     * Filter which TrasladoDestino to delete.
     */
    where: TrasladoDestinoWhereUniqueInput
  }


  /**
   * TrasladoDestino deleteMany
   */
  export type TrasladoDestinoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrasladoDestinos to delete
     */
    where?: TrasladoDestinoWhereInput
  }


  /**
   * TrasladoDestino.TrasladoBodegas
   */
  export type TrasladoDestino$TrasladoBodegasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoBodegas
     */
    select?: TrasladoBodegasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoBodegasInclude<ExtArgs> | null
    where?: TrasladoBodegasWhereInput
    orderBy?: TrasladoBodegasOrderByWithRelationInput | TrasladoBodegasOrderByWithRelationInput[]
    cursor?: TrasladoBodegasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoBodegasScalarFieldEnum | TrasladoBodegasScalarFieldEnum[]
  }


  /**
   * TrasladoDestino without action
   */
  export type TrasladoDestinoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrasladoDestino
     */
    select?: TrasladoDestinoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoDestinoInclude<ExtArgs> | null
  }



  /**
   * Model Historial
   */

  export type AggregateHistorial = {
    _count: HistorialCountAggregateOutputType | null
    _avg: HistorialAvgAggregateOutputType | null
    _sum: HistorialSumAggregateOutputType | null
    _min: HistorialMinAggregateOutputType | null
    _max: HistorialMaxAggregateOutputType | null
  }

  export type HistorialAvgAggregateOutputType = {
    id: number | null
    idBodega: number | null
    idUsuarioRegistro: number | null
    idProducto: number | null
  }

  export type HistorialSumAggregateOutputType = {
    id: number | null
    idBodega: number | null
    idUsuarioRegistro: number | null
    idProducto: number | null
  }

  export type HistorialMinAggregateOutputType = {
    id: number | null
    idBodega: number | null
    idUsuarioRegistro: number | null
    idProducto: number | null
    fechaAjuste: Date | null
    justificacion: string | null
  }

  export type HistorialMaxAggregateOutputType = {
    id: number | null
    idBodega: number | null
    idUsuarioRegistro: number | null
    idProducto: number | null
    fechaAjuste: Date | null
    justificacion: string | null
  }

  export type HistorialCountAggregateOutputType = {
    id: number
    idBodega: number
    idUsuarioRegistro: number
    idProducto: number
    fechaAjuste: number
    justificacion: number
    _all: number
  }


  export type HistorialAvgAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
  }

  export type HistorialSumAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
  }

  export type HistorialMinAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
    fechaAjuste?: true
    justificacion?: true
  }

  export type HistorialMaxAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
    fechaAjuste?: true
    justificacion?: true
  }

  export type HistorialCountAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
    fechaAjuste?: true
    justificacion?: true
    _all?: true
  }

  export type HistorialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Historial to aggregate.
     */
    where?: HistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historials to fetch.
     */
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Historials
    **/
    _count?: true | HistorialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorialMaxAggregateInputType
  }

  export type GetHistorialAggregateType<T extends HistorialAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial[P]>
      : GetScalarType<T[P], AggregateHistorial[P]>
  }




  export type HistorialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialWhereInput
    orderBy?: HistorialOrderByWithAggregationInput | HistorialOrderByWithAggregationInput[]
    by: HistorialScalarFieldEnum[] | HistorialScalarFieldEnum
    having?: HistorialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorialCountAggregateInputType | true
    _avg?: HistorialAvgAggregateInputType
    _sum?: HistorialSumAggregateInputType
    _min?: HistorialMinAggregateInputType
    _max?: HistorialMaxAggregateInputType
  }

  export type HistorialGroupByOutputType = {
    id: number
    idBodega: number
    idUsuarioRegistro: number
    idProducto: number
    fechaAjuste: Date
    justificacion: string
    _count: HistorialCountAggregateOutputType | null
    _avg: HistorialAvgAggregateOutputType | null
    _sum: HistorialSumAggregateOutputType | null
    _min: HistorialMinAggregateOutputType | null
    _max: HistorialMaxAggregateOutputType | null
  }

  type GetHistorialGroupByPayload<T extends HistorialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorialGroupByOutputType[P]>
            : GetScalarType<T[P], HistorialGroupByOutputType[P]>
        }
      >
    >


  export type HistorialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idBodega?: boolean
    idUsuarioRegistro?: boolean
    idProducto?: boolean
    fechaAjuste?: boolean
    justificacion?: boolean
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
    UsuarioRegistro?: boolean | UsuarioDefaultArgs<ExtArgs>
    productos?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historial"]>

  export type HistorialSelectScalar = {
    id?: boolean
    idBodega?: boolean
    idUsuarioRegistro?: boolean
    idProducto?: boolean
    fechaAjuste?: boolean
    justificacion?: boolean
  }

  export type HistorialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
    UsuarioRegistro?: boolean | UsuarioDefaultArgs<ExtArgs>
    productos?: boolean | ProductoDefaultArgs<ExtArgs>
  }


  export type $HistorialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Historial"
    objects: {
      bodegas: Prisma.$BodegaPayload<ExtArgs>
      UsuarioRegistro: Prisma.$UsuarioPayload<ExtArgs>
      productos: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idBodega: number
      idUsuarioRegistro: number
      idProducto: number
      fechaAjuste: Date
      justificacion: string
    }, ExtArgs["result"]["historial"]>
    composites: {}
  }


  type HistorialGetPayload<S extends boolean | null | undefined | HistorialDefaultArgs> = $Result.GetResult<Prisma.$HistorialPayload, S>

  type HistorialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistorialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistorialCountAggregateInputType | true
    }

  export interface HistorialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Historial'], meta: { name: 'Historial' } }
    /**
     * Find zero or one Historial that matches the filter.
     * @param {HistorialFindUniqueArgs} args - Arguments to find a Historial
     * @example
     * // Get one Historial
     * const historial = await prisma.historial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HistorialFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialFindUniqueArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Historial that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HistorialFindUniqueOrThrowArgs} args - Arguments to find a Historial
     * @example
     * // Get one Historial
     * const historial = await prisma.historial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HistorialFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Historial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialFindFirstArgs} args - Arguments to find a Historial
     * @example
     * // Get one Historial
     * const historial = await prisma.historial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HistorialFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialFindFirstArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Historial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialFindFirstOrThrowArgs} args - Arguments to find a Historial
     * @example
     * // Get one Historial
     * const historial = await prisma.historial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HistorialFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Historials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historials
     * const historials = await prisma.historial.findMany()
     * 
     * // Get first 10 Historials
     * const historials = await prisma.historial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historialWithIdOnly = await prisma.historial.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HistorialFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Historial.
     * @param {HistorialCreateArgs} args - Arguments to create a Historial.
     * @example
     * // Create one Historial
     * const Historial = await prisma.historial.create({
     *   data: {
     *     // ... data to create a Historial
     *   }
     * })
     * 
    **/
    create<T extends HistorialCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialCreateArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Historials.
     *     @param {HistorialCreateManyArgs} args - Arguments to create many Historials.
     *     @example
     *     // Create many Historials
     *     const historial = await prisma.historial.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HistorialCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial.
     * @param {HistorialDeleteArgs} args - Arguments to delete one Historial.
     * @example
     * // Delete one Historial
     * const Historial = await prisma.historial.delete({
     *   where: {
     *     // ... filter to delete one Historial
     *   }
     * })
     * 
    **/
    delete<T extends HistorialDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialDeleteArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Historial.
     * @param {HistorialUpdateArgs} args - Arguments to update one Historial.
     * @example
     * // Update one Historial
     * const historial = await prisma.historial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HistorialUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialUpdateArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Historials.
     * @param {HistorialDeleteManyArgs} args - Arguments to filter Historials to delete.
     * @example
     * // Delete a few Historials
     * const { count } = await prisma.historial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HistorialDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historials
     * const historial = await prisma.historial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HistorialUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial.
     * @param {HistorialUpsertArgs} args - Arguments to update or create a Historial.
     * @example
     * // Update or create a Historial
     * const historial = await prisma.historial.upsert({
     *   create: {
     *     // ... data to create a Historial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial we want to update
     *   }
     * })
    **/
    upsert<T extends HistorialUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialUpsertArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Historials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCountArgs} args - Arguments to filter Historials to count.
     * @example
     * // Count the number of Historials
     * const count = await prisma.historial.count({
     *   where: {
     *     // ... the filter for the Historials we want to count
     *   }
     * })
    **/
    count<T extends HistorialCountArgs>(
      args?: Subset<T, HistorialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorialAggregateArgs>(args: Subset<T, HistorialAggregateArgs>): Prisma.PrismaPromise<GetHistorialAggregateType<T>>

    /**
     * Group by Historial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistorialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistorialGroupByArgs['orderBy'] }
        : { orderBy?: HistorialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistorialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Historial model
   */
  readonly fields: HistorialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Historial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistorialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bodegas<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    UsuarioRegistro<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    productos<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Historial model
   */ 
  interface HistorialFieldRefs {
    readonly id: FieldRef<"Historial", 'Int'>
    readonly idBodega: FieldRef<"Historial", 'Int'>
    readonly idUsuarioRegistro: FieldRef<"Historial", 'Int'>
    readonly idProducto: FieldRef<"Historial", 'Int'>
    readonly fechaAjuste: FieldRef<"Historial", 'DateTime'>
    readonly justificacion: FieldRef<"Historial", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Historial findUnique
   */
  export type HistorialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historial to fetch.
     */
    where: HistorialWhereUniqueInput
  }


  /**
   * Historial findUniqueOrThrow
   */
  export type HistorialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historial to fetch.
     */
    where: HistorialWhereUniqueInput
  }


  /**
   * Historial findFirst
   */
  export type HistorialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historial to fetch.
     */
    where?: HistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historials to fetch.
     */
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Historials.
     */
    cursor?: HistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Historials.
     */
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Historial findFirstOrThrow
   */
  export type HistorialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historial to fetch.
     */
    where?: HistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historials to fetch.
     */
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Historials.
     */
    cursor?: HistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Historials.
     */
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Historial findMany
   */
  export type HistorialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historials to fetch.
     */
    where?: HistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historials to fetch.
     */
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Historials.
     */
    cursor?: HistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historials.
     */
    skip?: number
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Historial create
   */
  export type HistorialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * The data needed to create a Historial.
     */
    data: XOR<HistorialCreateInput, HistorialUncheckedCreateInput>
  }


  /**
   * Historial createMany
   */
  export type HistorialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Historials.
     */
    data: HistorialCreateManyInput | HistorialCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Historial update
   */
  export type HistorialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * The data needed to update a Historial.
     */
    data: XOR<HistorialUpdateInput, HistorialUncheckedUpdateInput>
    /**
     * Choose, which Historial to update.
     */
    where: HistorialWhereUniqueInput
  }


  /**
   * Historial updateMany
   */
  export type HistorialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Historials.
     */
    data: XOR<HistorialUpdateManyMutationInput, HistorialUncheckedUpdateManyInput>
    /**
     * Filter which Historials to update
     */
    where?: HistorialWhereInput
  }


  /**
   * Historial upsert
   */
  export type HistorialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * The filter to search for the Historial to update in case it exists.
     */
    where: HistorialWhereUniqueInput
    /**
     * In case the Historial found by the `where` argument doesn't exist, create a new Historial with this data.
     */
    create: XOR<HistorialCreateInput, HistorialUncheckedCreateInput>
    /**
     * In case the Historial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistorialUpdateInput, HistorialUncheckedUpdateInput>
  }


  /**
   * Historial delete
   */
  export type HistorialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter which Historial to delete.
     */
    where: HistorialWhereUniqueInput
  }


  /**
   * Historial deleteMany
   */
  export type HistorialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Historials to delete
     */
    where?: HistorialWhereInput
  }


  /**
   * Historial without action
   */
  export type HistorialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellidos: 'apellidos',
    nombreProveedor: 'nombreProveedor',
    correo: 'correo',
    contrasenna: 'contrasenna',
    fechaRegistro: 'fechaRegistro',
    rol: 'rol',
    idUbicacion: 'idUbicacion'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const EstadoScalarFieldEnum: {
    id: 'id',
    estado: 'estado'
  };

  export type EstadoScalarFieldEnum = (typeof EstadoScalarFieldEnum)[keyof typeof EstadoScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const SubCategoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type SubCategoriaScalarFieldEnum = (typeof SubCategoriaScalarFieldEnum)[keyof typeof SubCategoriaScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id: 'id',
    codigoProducto: 'codigoProducto',
    nombre: 'nombre',
    descripcion: 'descripcion',
    idSubCategoria: 'idSubCategoria',
    stock: 'stock',
    precio: 'precio'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const FotoScalarFieldEnum: {
    id: 'id',
    idProducto: 'idProducto',
    foto: 'foto'
  };

  export type FotoScalarFieldEnum = (typeof FotoScalarFieldEnum)[keyof typeof FotoScalarFieldEnum]


  export const UbicacionScalarFieldEnum: {
    id: 'id',
    idProvincia: 'idProvincia',
    idCanton: 'idCanton',
    idDistrito: 'idDistrito',
    idBarrio: 'idBarrio'
  };

  export type UbicacionScalarFieldEnum = (typeof UbicacionScalarFieldEnum)[keyof typeof UbicacionScalarFieldEnum]


  export const ProvinciaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type ProvinciaScalarFieldEnum = (typeof ProvinciaScalarFieldEnum)[keyof typeof ProvinciaScalarFieldEnum]


  export const CantonScalarFieldEnum: {
    id: 'id',
    idProvincia: 'idProvincia',
    nombre: 'nombre'
  };

  export type CantonScalarFieldEnum = (typeof CantonScalarFieldEnum)[keyof typeof CantonScalarFieldEnum]


  export const DistritoScalarFieldEnum: {
    id: 'id',
    idProvincia: 'idProvincia',
    idCanton: 'idCanton',
    nombre: 'nombre'
  };

  export type DistritoScalarFieldEnum = (typeof DistritoScalarFieldEnum)[keyof typeof DistritoScalarFieldEnum]


  export const BarrioScalarFieldEnum: {
    id: 'id',
    idProvincia: 'idProvincia',
    idCanton: 'idCanton',
    idDistrito: 'idDistrito',
    nombre: 'nombre'
  };

  export type BarrioScalarFieldEnum = (typeof BarrioScalarFieldEnum)[keyof typeof BarrioScalarFieldEnum]


  export const BodegaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    idUbicacion: 'idUbicacion',
    tamanno: 'tamanno',
    capacidad: 'capacidad',
    seguridad: 'seguridad'
  };

  export type BodegaScalarFieldEnum = (typeof BodegaScalarFieldEnum)[keyof typeof BodegaScalarFieldEnum]


  export const BodegaProductosScalarFieldEnum: {
    idBodega: 'idBodega',
    idProducto: 'idProducto',
    idUsuario: 'idUsuario',
    fechaRegistro: 'fechaRegistro',
    cantidad: 'cantidad'
  };

  export type BodegaProductosScalarFieldEnum = (typeof BodegaProductosScalarFieldEnum)[keyof typeof BodegaProductosScalarFieldEnum]


  export const EncabezadoCompraScalarFieldEnum: {
    id: 'id',
    fechaCompra: 'fechaCompra',
    idUsuarioProveedor: 'idUsuarioProveedor',
    idUsuarioRegistro: 'idUsuarioRegistro'
  };

  export type EncabezadoCompraScalarFieldEnum = (typeof EncabezadoCompraScalarFieldEnum)[keyof typeof EncabezadoCompraScalarFieldEnum]


  export const DetalleCompraScalarFieldEnum: {
    id: 'id',
    idEncabezadoCompra: 'idEncabezadoCompra',
    idProducto: 'idProducto',
    idBodega: 'idBodega',
    cantidad: 'cantidad'
  };

  export type DetalleCompraScalarFieldEnum = (typeof DetalleCompraScalarFieldEnum)[keyof typeof DetalleCompraScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    idEncabezadoCompra: 'idEncabezadoCompra',
    fechaPedido: 'fechaPedido',
    idEstado: 'idEstado',
    observaciones: 'observaciones'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const TrasladoBodegasScalarFieldEnum: {
    idPedido: 'idPedido',
    idDestino: 'idDestino'
  };

  export type TrasladoBodegasScalarFieldEnum = (typeof TrasladoBodegasScalarFieldEnum)[keyof typeof TrasladoBodegasScalarFieldEnum]


  export const TrasladoDestinoScalarFieldEnum: {
    id: 'id',
    idBodegaDestino: 'idBodegaDestino',
    fechaRecibido: 'fechaRecibido',
    idEstado: 'idEstado'
  };

  export type TrasladoDestinoScalarFieldEnum = (typeof TrasladoDestinoScalarFieldEnum)[keyof typeof TrasladoDestinoScalarFieldEnum]


  export const HistorialScalarFieldEnum: {
    id: 'id',
    idBodega: 'idBodega',
    idUsuarioRegistro: 'idUsuarioRegistro',
    idProducto: 'idProducto',
    fechaAjuste: 'fechaAjuste',
    justificacion: 'justificacion'
  };

  export type HistorialScalarFieldEnum = (typeof HistorialScalarFieldEnum)[keyof typeof HistorialScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    nombreProveedor?: StringNullableFilter<"Usuario"> | string | null
    correo?: StringFilter<"Usuario"> | string
    contrasenna?: StringFilter<"Usuario"> | string
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    idUbicacion?: IntFilter<"Usuario"> | number
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
    bodegaProductos?: BodegaProductosListRelationFilter
    encabezadoCompras?: EncabezadoCompraListRelationFilter
    Historial?: HistorialListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    nombreProveedor?: SortOrderInput | SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idUbicacion?: SortOrder
    ubicacion?: UbicacionOrderByWithRelationInput
    bodegaProductos?: BodegaProductosOrderByRelationAggregateInput
    encabezadoCompras?: EncabezadoCompraOrderByRelationAggregateInput
    Historial?: HistorialOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    correo?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    nombreProveedor?: StringNullableFilter<"Usuario"> | string | null
    contrasenna?: StringFilter<"Usuario"> | string
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    idUbicacion?: IntFilter<"Usuario"> | number
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
    bodegaProductos?: BodegaProductosListRelationFilter
    encabezadoCompras?: EncabezadoCompraListRelationFilter
    Historial?: HistorialListRelationFilter
  }, "id" | "correo">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    nombreProveedor?: SortOrderInput | SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idUbicacion?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellidos?: StringWithAggregatesFilter<"Usuario"> | string
    nombreProveedor?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    correo?: StringWithAggregatesFilter<"Usuario"> | string
    contrasenna?: StringWithAggregatesFilter<"Usuario"> | string
    fechaRegistro?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    idUbicacion?: IntWithAggregatesFilter<"Usuario"> | number
  }

  export type EstadoWhereInput = {
    AND?: EstadoWhereInput | EstadoWhereInput[]
    OR?: EstadoWhereInput[]
    NOT?: EstadoWhereInput | EstadoWhereInput[]
    id?: IntFilter<"Estado"> | number
    estado?: StringFilter<"Estado"> | string
    pedidos?: PedidoListRelationFilter
    TrasladoDestino?: TrasladoDestinoListRelationFilter
  }

  export type EstadoOrderByWithRelationInput = {
    id?: SortOrder
    estado?: SortOrder
    pedidos?: PedidoOrderByRelationAggregateInput
    TrasladoDestino?: TrasladoDestinoOrderByRelationAggregateInput
  }

  export type EstadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EstadoWhereInput | EstadoWhereInput[]
    OR?: EstadoWhereInput[]
    NOT?: EstadoWhereInput | EstadoWhereInput[]
    estado?: StringFilter<"Estado"> | string
    pedidos?: PedidoListRelationFilter
    TrasladoDestino?: TrasladoDestinoListRelationFilter
  }, "id">

  export type EstadoOrderByWithAggregationInput = {
    id?: SortOrder
    estado?: SortOrder
    _count?: EstadoCountOrderByAggregateInput
    _avg?: EstadoAvgOrderByAggregateInput
    _max?: EstadoMaxOrderByAggregateInput
    _min?: EstadoMinOrderByAggregateInput
    _sum?: EstadoSumOrderByAggregateInput
  }

  export type EstadoScalarWhereWithAggregatesInput = {
    AND?: EstadoScalarWhereWithAggregatesInput | EstadoScalarWhereWithAggregatesInput[]
    OR?: EstadoScalarWhereWithAggregatesInput[]
    NOT?: EstadoScalarWhereWithAggregatesInput | EstadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Estado"> | number
    estado?: StringWithAggregatesFilter<"Estado"> | string
  }

  export type CategoriaWhereInput = {
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nombre?: StringFilter<"Categoria"> | string
    subCategoria?: SubCategoriaListRelationFilter
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    subCategoria?: SubCategoriaOrderByRelationAggregateInput
  }

  export type CategoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    nombre?: StringFilter<"Categoria"> | string
    subCategoria?: SubCategoriaListRelationFilter
  }, "id">

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    OR?: CategoriaScalarWhereWithAggregatesInput[]
    NOT?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categoria"> | number
    nombre?: StringWithAggregatesFilter<"Categoria"> | string
  }

  export type SubCategoriaWhereInput = {
    AND?: SubCategoriaWhereInput | SubCategoriaWhereInput[]
    OR?: SubCategoriaWhereInput[]
    NOT?: SubCategoriaWhereInput | SubCategoriaWhereInput[]
    id?: IntFilter<"SubCategoria"> | number
    nombre?: StringFilter<"SubCategoria"> | string
    producto?: ProductoListRelationFilter
    categorias?: CategoriaListRelationFilter
  }

  export type SubCategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    producto?: ProductoOrderByRelationAggregateInput
    categorias?: CategoriaOrderByRelationAggregateInput
  }

  export type SubCategoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubCategoriaWhereInput | SubCategoriaWhereInput[]
    OR?: SubCategoriaWhereInput[]
    NOT?: SubCategoriaWhereInput | SubCategoriaWhereInput[]
    nombre?: StringFilter<"SubCategoria"> | string
    producto?: ProductoListRelationFilter
    categorias?: CategoriaListRelationFilter
  }, "id">

  export type SubCategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: SubCategoriaCountOrderByAggregateInput
    _avg?: SubCategoriaAvgOrderByAggregateInput
    _max?: SubCategoriaMaxOrderByAggregateInput
    _min?: SubCategoriaMinOrderByAggregateInput
    _sum?: SubCategoriaSumOrderByAggregateInput
  }

  export type SubCategoriaScalarWhereWithAggregatesInput = {
    AND?: SubCategoriaScalarWhereWithAggregatesInput | SubCategoriaScalarWhereWithAggregatesInput[]
    OR?: SubCategoriaScalarWhereWithAggregatesInput[]
    NOT?: SubCategoriaScalarWhereWithAggregatesInput | SubCategoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubCategoria"> | number
    nombre?: StringWithAggregatesFilter<"SubCategoria"> | string
  }

  export type ProductoWhereInput = {
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    id?: IntFilter<"Producto"> | number
    codigoProducto?: StringFilter<"Producto"> | string
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    idSubCategoria?: IntFilter<"Producto"> | number
    stock?: IntFilter<"Producto"> | number
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    subCategorias?: XOR<SubCategoriaRelationFilter, SubCategoriaWhereInput>
    foto?: FotoListRelationFilter
    bodegaProductos?: BodegaProductosListRelationFilter
    detalleCompras?: DetalleCompraListRelationFilter
    Historial?: HistorialListRelationFilter
  }

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder
    codigoProducto?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    idSubCategoria?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    subCategorias?: SubCategoriaOrderByWithRelationInput
    foto?: FotoOrderByRelationAggregateInput
    bodegaProductos?: BodegaProductosOrderByRelationAggregateInput
    detalleCompras?: DetalleCompraOrderByRelationAggregateInput
    Historial?: HistorialOrderByRelationAggregateInput
  }

  export type ProductoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    codigoProducto?: StringFilter<"Producto"> | string
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    idSubCategoria?: IntFilter<"Producto"> | number
    stock?: IntFilter<"Producto"> | number
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    subCategorias?: XOR<SubCategoriaRelationFilter, SubCategoriaWhereInput>
    foto?: FotoListRelationFilter
    bodegaProductos?: BodegaProductosListRelationFilter
    detalleCompras?: DetalleCompraListRelationFilter
    Historial?: HistorialListRelationFilter
  }, "id">

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    codigoProducto?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    idSubCategoria?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _avg?: ProductoAvgOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
    _sum?: ProductoSumOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    OR?: ProductoScalarWhereWithAggregatesInput[]
    NOT?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Producto"> | number
    codigoProducto?: StringWithAggregatesFilter<"Producto"> | string
    nombre?: StringWithAggregatesFilter<"Producto"> | string
    descripcion?: StringWithAggregatesFilter<"Producto"> | string
    idSubCategoria?: IntWithAggregatesFilter<"Producto"> | number
    stock?: IntWithAggregatesFilter<"Producto"> | number
    precio?: DecimalWithAggregatesFilter<"Producto"> | Decimal | DecimalJsLike | number | string
  }

  export type FotoWhereInput = {
    AND?: FotoWhereInput | FotoWhereInput[]
    OR?: FotoWhereInput[]
    NOT?: FotoWhereInput | FotoWhereInput[]
    id?: IntFilter<"Foto"> | number
    idProducto?: IntFilter<"Foto"> | number
    foto?: BytesFilter<"Foto"> | Buffer
    productos?: XOR<ProductoRelationFilter, ProductoWhereInput>
  }

  export type FotoOrderByWithRelationInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
    productos?: ProductoOrderByWithRelationInput
  }

  export type FotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FotoWhereInput | FotoWhereInput[]
    OR?: FotoWhereInput[]
    NOT?: FotoWhereInput | FotoWhereInput[]
    idProducto?: IntFilter<"Foto"> | number
    foto?: BytesFilter<"Foto"> | Buffer
    productos?: XOR<ProductoRelationFilter, ProductoWhereInput>
  }, "id">

  export type FotoOrderByWithAggregationInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
    _count?: FotoCountOrderByAggregateInput
    _avg?: FotoAvgOrderByAggregateInput
    _max?: FotoMaxOrderByAggregateInput
    _min?: FotoMinOrderByAggregateInput
    _sum?: FotoSumOrderByAggregateInput
  }

  export type FotoScalarWhereWithAggregatesInput = {
    AND?: FotoScalarWhereWithAggregatesInput | FotoScalarWhereWithAggregatesInput[]
    OR?: FotoScalarWhereWithAggregatesInput[]
    NOT?: FotoScalarWhereWithAggregatesInput | FotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Foto"> | number
    idProducto?: IntWithAggregatesFilter<"Foto"> | number
    foto?: BytesWithAggregatesFilter<"Foto"> | Buffer
  }

  export type UbicacionWhereInput = {
    AND?: UbicacionWhereInput | UbicacionWhereInput[]
    OR?: UbicacionWhereInput[]
    NOT?: UbicacionWhereInput | UbicacionWhereInput[]
    id?: IntFilter<"Ubicacion"> | number
    idProvincia?: IntFilter<"Ubicacion"> | number
    idCanton?: IntFilter<"Ubicacion"> | number
    idDistrito?: IntFilter<"Ubicacion"> | number
    idBarrio?: IntFilter<"Ubicacion"> | number
    usuario?: UsuarioListRelationFilter
    bodega?: BodegaListRelationFilter
    provincia?: ProvinciaListRelationFilter
    cantones?: CantonListRelationFilter
    distritos?: DistritoListRelationFilter
    barrios?: BarrioListRelationFilter
  }

  export type UbicacionOrderByWithRelationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    idBarrio?: SortOrder
    usuario?: UsuarioOrderByRelationAggregateInput
    bodega?: BodegaOrderByRelationAggregateInput
    provincia?: ProvinciaOrderByRelationAggregateInput
    cantones?: CantonOrderByRelationAggregateInput
    distritos?: DistritoOrderByRelationAggregateInput
    barrios?: BarrioOrderByRelationAggregateInput
  }

  export type UbicacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    idProvincia?: number
    idCanton?: number
    idDistrito?: number
    idBarrio?: number
    AND?: UbicacionWhereInput | UbicacionWhereInput[]
    OR?: UbicacionWhereInput[]
    NOT?: UbicacionWhereInput | UbicacionWhereInput[]
    usuario?: UsuarioListRelationFilter
    bodega?: BodegaListRelationFilter
    provincia?: ProvinciaListRelationFilter
    cantones?: CantonListRelationFilter
    distritos?: DistritoListRelationFilter
    barrios?: BarrioListRelationFilter
  }, "id" | "idProvincia" | "idCanton" | "idDistrito" | "idBarrio">

  export type UbicacionOrderByWithAggregationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    idBarrio?: SortOrder
    _count?: UbicacionCountOrderByAggregateInput
    _avg?: UbicacionAvgOrderByAggregateInput
    _max?: UbicacionMaxOrderByAggregateInput
    _min?: UbicacionMinOrderByAggregateInput
    _sum?: UbicacionSumOrderByAggregateInput
  }

  export type UbicacionScalarWhereWithAggregatesInput = {
    AND?: UbicacionScalarWhereWithAggregatesInput | UbicacionScalarWhereWithAggregatesInput[]
    OR?: UbicacionScalarWhereWithAggregatesInput[]
    NOT?: UbicacionScalarWhereWithAggregatesInput | UbicacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ubicacion"> | number
    idProvincia?: IntWithAggregatesFilter<"Ubicacion"> | number
    idCanton?: IntWithAggregatesFilter<"Ubicacion"> | number
    idDistrito?: IntWithAggregatesFilter<"Ubicacion"> | number
    idBarrio?: IntWithAggregatesFilter<"Ubicacion"> | number
  }

  export type ProvinciaWhereInput = {
    AND?: ProvinciaWhereInput | ProvinciaWhereInput[]
    OR?: ProvinciaWhereInput[]
    NOT?: ProvinciaWhereInput | ProvinciaWhereInput[]
    id?: IntFilter<"Provincia"> | number
    nombre?: StringFilter<"Provincia"> | string
    cantones?: CantonListRelationFilter
    distritos?: DistritoListRelationFilter
    barrios?: BarrioListRelationFilter
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
  }

  export type ProvinciaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    cantones?: CantonOrderByRelationAggregateInput
    distritos?: DistritoOrderByRelationAggregateInput
    barrios?: BarrioOrderByRelationAggregateInput
    ubicacion?: UbicacionOrderByWithRelationInput
  }

  export type ProvinciaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProvinciaWhereInput | ProvinciaWhereInput[]
    OR?: ProvinciaWhereInput[]
    NOT?: ProvinciaWhereInput | ProvinciaWhereInput[]
    nombre?: StringFilter<"Provincia"> | string
    cantones?: CantonListRelationFilter
    distritos?: DistritoListRelationFilter
    barrios?: BarrioListRelationFilter
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
  }, "id">

  export type ProvinciaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: ProvinciaCountOrderByAggregateInput
    _avg?: ProvinciaAvgOrderByAggregateInput
    _max?: ProvinciaMaxOrderByAggregateInput
    _min?: ProvinciaMinOrderByAggregateInput
    _sum?: ProvinciaSumOrderByAggregateInput
  }

  export type ProvinciaScalarWhereWithAggregatesInput = {
    AND?: ProvinciaScalarWhereWithAggregatesInput | ProvinciaScalarWhereWithAggregatesInput[]
    OR?: ProvinciaScalarWhereWithAggregatesInput[]
    NOT?: ProvinciaScalarWhereWithAggregatesInput | ProvinciaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Provincia"> | number
    nombre?: StringWithAggregatesFilter<"Provincia"> | string
  }

  export type CantonWhereInput = {
    AND?: CantonWhereInput | CantonWhereInput[]
    OR?: CantonWhereInput[]
    NOT?: CantonWhereInput | CantonWhereInput[]
    id?: IntFilter<"Canton"> | number
    idProvincia?: IntFilter<"Canton"> | number
    nombre?: StringFilter<"Canton"> | string
    provincias?: XOR<ProvinciaRelationFilter, ProvinciaWhereInput>
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
    distritos?: DistritoListRelationFilter
    barrios?: BarrioListRelationFilter
  }

  export type CantonOrderByWithRelationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    nombre?: SortOrder
    provincias?: ProvinciaOrderByWithRelationInput
    ubicacion?: UbicacionOrderByWithRelationInput
    distritos?: DistritoOrderByRelationAggregateInput
    barrios?: BarrioOrderByRelationAggregateInput
  }

  export type CantonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CantonWhereInput | CantonWhereInput[]
    OR?: CantonWhereInput[]
    NOT?: CantonWhereInput | CantonWhereInput[]
    idProvincia?: IntFilter<"Canton"> | number
    nombre?: StringFilter<"Canton"> | string
    provincias?: XOR<ProvinciaRelationFilter, ProvinciaWhereInput>
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
    distritos?: DistritoListRelationFilter
    barrios?: BarrioListRelationFilter
  }, "id">

  export type CantonOrderByWithAggregationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    nombre?: SortOrder
    _count?: CantonCountOrderByAggregateInput
    _avg?: CantonAvgOrderByAggregateInput
    _max?: CantonMaxOrderByAggregateInput
    _min?: CantonMinOrderByAggregateInput
    _sum?: CantonSumOrderByAggregateInput
  }

  export type CantonScalarWhereWithAggregatesInput = {
    AND?: CantonScalarWhereWithAggregatesInput | CantonScalarWhereWithAggregatesInput[]
    OR?: CantonScalarWhereWithAggregatesInput[]
    NOT?: CantonScalarWhereWithAggregatesInput | CantonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Canton"> | number
    idProvincia?: IntWithAggregatesFilter<"Canton"> | number
    nombre?: StringWithAggregatesFilter<"Canton"> | string
  }

  export type DistritoWhereInput = {
    AND?: DistritoWhereInput | DistritoWhereInput[]
    OR?: DistritoWhereInput[]
    NOT?: DistritoWhereInput | DistritoWhereInput[]
    id?: IntFilter<"Distrito"> | number
    idProvincia?: IntFilter<"Distrito"> | number
    idCanton?: IntFilter<"Distrito"> | number
    nombre?: StringFilter<"Distrito"> | string
    provincias?: XOR<ProvinciaRelationFilter, ProvinciaWhereInput>
    cantones?: XOR<CantonRelationFilter, CantonWhereInput>
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
    barrios?: BarrioListRelationFilter
  }

  export type DistritoOrderByWithRelationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    nombre?: SortOrder
    provincias?: ProvinciaOrderByWithRelationInput
    cantones?: CantonOrderByWithRelationInput
    ubicacion?: UbicacionOrderByWithRelationInput
    barrios?: BarrioOrderByRelationAggregateInput
  }

  export type DistritoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DistritoWhereInput | DistritoWhereInput[]
    OR?: DistritoWhereInput[]
    NOT?: DistritoWhereInput | DistritoWhereInput[]
    idProvincia?: IntFilter<"Distrito"> | number
    idCanton?: IntFilter<"Distrito"> | number
    nombre?: StringFilter<"Distrito"> | string
    provincias?: XOR<ProvinciaRelationFilter, ProvinciaWhereInput>
    cantones?: XOR<CantonRelationFilter, CantonWhereInput>
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
    barrios?: BarrioListRelationFilter
  }, "id">

  export type DistritoOrderByWithAggregationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    nombre?: SortOrder
    _count?: DistritoCountOrderByAggregateInput
    _avg?: DistritoAvgOrderByAggregateInput
    _max?: DistritoMaxOrderByAggregateInput
    _min?: DistritoMinOrderByAggregateInput
    _sum?: DistritoSumOrderByAggregateInput
  }

  export type DistritoScalarWhereWithAggregatesInput = {
    AND?: DistritoScalarWhereWithAggregatesInput | DistritoScalarWhereWithAggregatesInput[]
    OR?: DistritoScalarWhereWithAggregatesInput[]
    NOT?: DistritoScalarWhereWithAggregatesInput | DistritoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Distrito"> | number
    idProvincia?: IntWithAggregatesFilter<"Distrito"> | number
    idCanton?: IntWithAggregatesFilter<"Distrito"> | number
    nombre?: StringWithAggregatesFilter<"Distrito"> | string
  }

  export type BarrioWhereInput = {
    AND?: BarrioWhereInput | BarrioWhereInput[]
    OR?: BarrioWhereInput[]
    NOT?: BarrioWhereInput | BarrioWhereInput[]
    id?: IntFilter<"Barrio"> | number
    idProvincia?: IntFilter<"Barrio"> | number
    idCanton?: IntFilter<"Barrio"> | number
    idDistrito?: IntFilter<"Barrio"> | number
    nombre?: StringFilter<"Barrio"> | string
    provincias?: XOR<ProvinciaRelationFilter, ProvinciaWhereInput>
    cantones?: XOR<CantonRelationFilter, CantonWhereInput>
    distritos?: XOR<DistritoRelationFilter, DistritoWhereInput>
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
  }

  export type BarrioOrderByWithRelationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    nombre?: SortOrder
    provincias?: ProvinciaOrderByWithRelationInput
    cantones?: CantonOrderByWithRelationInput
    distritos?: DistritoOrderByWithRelationInput
    ubicacion?: UbicacionOrderByWithRelationInput
  }

  export type BarrioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BarrioWhereInput | BarrioWhereInput[]
    OR?: BarrioWhereInput[]
    NOT?: BarrioWhereInput | BarrioWhereInput[]
    idProvincia?: IntFilter<"Barrio"> | number
    idCanton?: IntFilter<"Barrio"> | number
    idDistrito?: IntFilter<"Barrio"> | number
    nombre?: StringFilter<"Barrio"> | string
    provincias?: XOR<ProvinciaRelationFilter, ProvinciaWhereInput>
    cantones?: XOR<CantonRelationFilter, CantonWhereInput>
    distritos?: XOR<DistritoRelationFilter, DistritoWhereInput>
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
  }, "id">

  export type BarrioOrderByWithAggregationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    nombre?: SortOrder
    _count?: BarrioCountOrderByAggregateInput
    _avg?: BarrioAvgOrderByAggregateInput
    _max?: BarrioMaxOrderByAggregateInput
    _min?: BarrioMinOrderByAggregateInput
    _sum?: BarrioSumOrderByAggregateInput
  }

  export type BarrioScalarWhereWithAggregatesInput = {
    AND?: BarrioScalarWhereWithAggregatesInput | BarrioScalarWhereWithAggregatesInput[]
    OR?: BarrioScalarWhereWithAggregatesInput[]
    NOT?: BarrioScalarWhereWithAggregatesInput | BarrioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Barrio"> | number
    idProvincia?: IntWithAggregatesFilter<"Barrio"> | number
    idCanton?: IntWithAggregatesFilter<"Barrio"> | number
    idDistrito?: IntWithAggregatesFilter<"Barrio"> | number
    nombre?: StringWithAggregatesFilter<"Barrio"> | string
  }

  export type BodegaWhereInput = {
    AND?: BodegaWhereInput | BodegaWhereInput[]
    OR?: BodegaWhereInput[]
    NOT?: BodegaWhereInput | BodegaWhereInput[]
    id?: IntFilter<"Bodega"> | number
    nombre?: StringFilter<"Bodega"> | string
    idUbicacion?: IntFilter<"Bodega"> | number
    tamanno?: FloatFilter<"Bodega"> | number
    capacidad?: FloatFilter<"Bodega"> | number
    seguridad?: BoolFilter<"Bodega"> | boolean
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
    bodegaProductos?: BodegaProductosListRelationFilter
    detalleCompras?: DetalleCompraListRelationFilter
    Historial?: HistorialListRelationFilter
    TrasladoDestino?: TrasladoDestinoListRelationFilter
  }

  export type BodegaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
    ubicacion?: UbicacionOrderByWithRelationInput
    bodegaProductos?: BodegaProductosOrderByRelationAggregateInput
    detalleCompras?: DetalleCompraOrderByRelationAggregateInput
    Historial?: HistorialOrderByRelationAggregateInput
    TrasladoDestino?: TrasladoDestinoOrderByRelationAggregateInput
  }

  export type BodegaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BodegaWhereInput | BodegaWhereInput[]
    OR?: BodegaWhereInput[]
    NOT?: BodegaWhereInput | BodegaWhereInput[]
    nombre?: StringFilter<"Bodega"> | string
    idUbicacion?: IntFilter<"Bodega"> | number
    tamanno?: FloatFilter<"Bodega"> | number
    capacidad?: FloatFilter<"Bodega"> | number
    seguridad?: BoolFilter<"Bodega"> | boolean
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
    bodegaProductos?: BodegaProductosListRelationFilter
    detalleCompras?: DetalleCompraListRelationFilter
    Historial?: HistorialListRelationFilter
    TrasladoDestino?: TrasladoDestinoListRelationFilter
  }, "id">

  export type BodegaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
    _count?: BodegaCountOrderByAggregateInput
    _avg?: BodegaAvgOrderByAggregateInput
    _max?: BodegaMaxOrderByAggregateInput
    _min?: BodegaMinOrderByAggregateInput
    _sum?: BodegaSumOrderByAggregateInput
  }

  export type BodegaScalarWhereWithAggregatesInput = {
    AND?: BodegaScalarWhereWithAggregatesInput | BodegaScalarWhereWithAggregatesInput[]
    OR?: BodegaScalarWhereWithAggregatesInput[]
    NOT?: BodegaScalarWhereWithAggregatesInput | BodegaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bodega"> | number
    nombre?: StringWithAggregatesFilter<"Bodega"> | string
    idUbicacion?: IntWithAggregatesFilter<"Bodega"> | number
    tamanno?: FloatWithAggregatesFilter<"Bodega"> | number
    capacidad?: FloatWithAggregatesFilter<"Bodega"> | number
    seguridad?: BoolWithAggregatesFilter<"Bodega"> | boolean
  }

  export type BodegaProductosWhereInput = {
    AND?: BodegaProductosWhereInput | BodegaProductosWhereInput[]
    OR?: BodegaProductosWhereInput[]
    NOT?: BodegaProductosWhereInput | BodegaProductosWhereInput[]
    idBodega?: IntFilter<"BodegaProductos"> | number
    idProducto?: IntFilter<"BodegaProductos"> | number
    idUsuario?: IntFilter<"BodegaProductos"> | number
    fechaRegistro?: DateTimeFilter<"BodegaProductos"> | Date | string
    cantidad?: IntFilter<"BodegaProductos"> | number
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type BodegaProductosOrderByWithRelationInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    cantidad?: SortOrder
    bodegas?: BodegaOrderByWithRelationInput
    producto?: ProductoOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type BodegaProductosWhereUniqueInput = Prisma.AtLeast<{
    idBodega_idProducto_idUsuario?: BodegaProductosIdBodegaIdProductoIdUsuarioCompoundUniqueInput
    AND?: BodegaProductosWhereInput | BodegaProductosWhereInput[]
    OR?: BodegaProductosWhereInput[]
    NOT?: BodegaProductosWhereInput | BodegaProductosWhereInput[]
    idBodega?: IntFilter<"BodegaProductos"> | number
    idProducto?: IntFilter<"BodegaProductos"> | number
    idUsuario?: IntFilter<"BodegaProductos"> | number
    fechaRegistro?: DateTimeFilter<"BodegaProductos"> | Date | string
    cantidad?: IntFilter<"BodegaProductos"> | number
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "idBodega_idProducto_idUsuario">

  export type BodegaProductosOrderByWithAggregationInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    cantidad?: SortOrder
    _count?: BodegaProductosCountOrderByAggregateInput
    _avg?: BodegaProductosAvgOrderByAggregateInput
    _max?: BodegaProductosMaxOrderByAggregateInput
    _min?: BodegaProductosMinOrderByAggregateInput
    _sum?: BodegaProductosSumOrderByAggregateInput
  }

  export type BodegaProductosScalarWhereWithAggregatesInput = {
    AND?: BodegaProductosScalarWhereWithAggregatesInput | BodegaProductosScalarWhereWithAggregatesInput[]
    OR?: BodegaProductosScalarWhereWithAggregatesInput[]
    NOT?: BodegaProductosScalarWhereWithAggregatesInput | BodegaProductosScalarWhereWithAggregatesInput[]
    idBodega?: IntWithAggregatesFilter<"BodegaProductos"> | number
    idProducto?: IntWithAggregatesFilter<"BodegaProductos"> | number
    idUsuario?: IntWithAggregatesFilter<"BodegaProductos"> | number
    fechaRegistro?: DateTimeWithAggregatesFilter<"BodegaProductos"> | Date | string
    cantidad?: IntWithAggregatesFilter<"BodegaProductos"> | number
  }

  export type EncabezadoCompraWhereInput = {
    AND?: EncabezadoCompraWhereInput | EncabezadoCompraWhereInput[]
    OR?: EncabezadoCompraWhereInput[]
    NOT?: EncabezadoCompraWhereInput | EncabezadoCompraWhereInput[]
    id?: IntFilter<"EncabezadoCompra"> | number
    fechaCompra?: DateTimeFilter<"EncabezadoCompra"> | Date | string
    idUsuarioProveedor?: IntFilter<"EncabezadoCompra"> | number
    idUsuarioRegistro?: IntFilter<"EncabezadoCompra"> | number
    usuarioProveedor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    detalleCompras?: DetalleCompraListRelationFilter
    pedidos?: PedidoListRelationFilter
  }

  export type EncabezadoCompraOrderByWithRelationInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idUsuarioProveedor?: SortOrder
    idUsuarioRegistro?: SortOrder
    usuarioProveedor?: UsuarioOrderByWithRelationInput
    detalleCompras?: DetalleCompraOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type EncabezadoCompraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncabezadoCompraWhereInput | EncabezadoCompraWhereInput[]
    OR?: EncabezadoCompraWhereInput[]
    NOT?: EncabezadoCompraWhereInput | EncabezadoCompraWhereInput[]
    fechaCompra?: DateTimeFilter<"EncabezadoCompra"> | Date | string
    idUsuarioProveedor?: IntFilter<"EncabezadoCompra"> | number
    idUsuarioRegistro?: IntFilter<"EncabezadoCompra"> | number
    usuarioProveedor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    detalleCompras?: DetalleCompraListRelationFilter
    pedidos?: PedidoListRelationFilter
  }, "id">

  export type EncabezadoCompraOrderByWithAggregationInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idUsuarioProveedor?: SortOrder
    idUsuarioRegistro?: SortOrder
    _count?: EncabezadoCompraCountOrderByAggregateInput
    _avg?: EncabezadoCompraAvgOrderByAggregateInput
    _max?: EncabezadoCompraMaxOrderByAggregateInput
    _min?: EncabezadoCompraMinOrderByAggregateInput
    _sum?: EncabezadoCompraSumOrderByAggregateInput
  }

  export type EncabezadoCompraScalarWhereWithAggregatesInput = {
    AND?: EncabezadoCompraScalarWhereWithAggregatesInput | EncabezadoCompraScalarWhereWithAggregatesInput[]
    OR?: EncabezadoCompraScalarWhereWithAggregatesInput[]
    NOT?: EncabezadoCompraScalarWhereWithAggregatesInput | EncabezadoCompraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncabezadoCompra"> | number
    fechaCompra?: DateTimeWithAggregatesFilter<"EncabezadoCompra"> | Date | string
    idUsuarioProveedor?: IntWithAggregatesFilter<"EncabezadoCompra"> | number
    idUsuarioRegistro?: IntWithAggregatesFilter<"EncabezadoCompra"> | number
  }

  export type DetalleCompraWhereInput = {
    AND?: DetalleCompraWhereInput | DetalleCompraWhereInput[]
    OR?: DetalleCompraWhereInput[]
    NOT?: DetalleCompraWhereInput | DetalleCompraWhereInput[]
    id?: IntFilter<"DetalleCompra"> | number
    idEncabezadoCompra?: IntFilter<"DetalleCompra"> | number
    idProducto?: IntFilter<"DetalleCompra"> | number
    idBodega?: IntFilter<"DetalleCompra"> | number
    cantidad?: IntFilter<"DetalleCompra"> | number
    productos?: XOR<ProductoRelationFilter, ProductoWhereInput>
    encabezadoCompras?: XOR<EncabezadoCompraRelationFilter, EncabezadoCompraWhereInput>
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
  }

  export type DetalleCompraOrderByWithRelationInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
    productos?: ProductoOrderByWithRelationInput
    encabezadoCompras?: EncabezadoCompraOrderByWithRelationInput
    bodegas?: BodegaOrderByWithRelationInput
  }

  export type DetalleCompraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DetalleCompraWhereInput | DetalleCompraWhereInput[]
    OR?: DetalleCompraWhereInput[]
    NOT?: DetalleCompraWhereInput | DetalleCompraWhereInput[]
    idEncabezadoCompra?: IntFilter<"DetalleCompra"> | number
    idProducto?: IntFilter<"DetalleCompra"> | number
    idBodega?: IntFilter<"DetalleCompra"> | number
    cantidad?: IntFilter<"DetalleCompra"> | number
    productos?: XOR<ProductoRelationFilter, ProductoWhereInput>
    encabezadoCompras?: XOR<EncabezadoCompraRelationFilter, EncabezadoCompraWhereInput>
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
  }, "id">

  export type DetalleCompraOrderByWithAggregationInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
    _count?: DetalleCompraCountOrderByAggregateInput
    _avg?: DetalleCompraAvgOrderByAggregateInput
    _max?: DetalleCompraMaxOrderByAggregateInput
    _min?: DetalleCompraMinOrderByAggregateInput
    _sum?: DetalleCompraSumOrderByAggregateInput
  }

  export type DetalleCompraScalarWhereWithAggregatesInput = {
    AND?: DetalleCompraScalarWhereWithAggregatesInput | DetalleCompraScalarWhereWithAggregatesInput[]
    OR?: DetalleCompraScalarWhereWithAggregatesInput[]
    NOT?: DetalleCompraScalarWhereWithAggregatesInput | DetalleCompraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DetalleCompra"> | number
    idEncabezadoCompra?: IntWithAggregatesFilter<"DetalleCompra"> | number
    idProducto?: IntWithAggregatesFilter<"DetalleCompra"> | number
    idBodega?: IntWithAggregatesFilter<"DetalleCompra"> | number
    cantidad?: IntWithAggregatesFilter<"DetalleCompra"> | number
  }

  export type PedidoWhereInput = {
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    idEncabezadoCompra?: IntFilter<"Pedido"> | number
    fechaPedido?: DateTimeFilter<"Pedido"> | Date | string
    idEstado?: IntFilter<"Pedido"> | number
    observaciones?: StringNullableFilter<"Pedido"> | string | null
    estadoPedido?: XOR<EstadoRelationFilter, EstadoWhereInput>
    encabezadoCompras?: XOR<EncabezadoCompraRelationFilter, EncabezadoCompraWhereInput>
    TrasladoBodegas?: TrasladoBodegasListRelationFilter
  }

  export type PedidoOrderByWithRelationInput = {
    idEncabezadoCompra?: SortOrder
    fechaPedido?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    estadoPedido?: EstadoOrderByWithRelationInput
    encabezadoCompras?: EncabezadoCompraOrderByWithRelationInput
    TrasladoBodegas?: TrasladoBodegasOrderByRelationAggregateInput
  }

  export type PedidoWhereUniqueInput = Prisma.AtLeast<{
    idEncabezadoCompra?: number
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    fechaPedido?: DateTimeFilter<"Pedido"> | Date | string
    idEstado?: IntFilter<"Pedido"> | number
    observaciones?: StringNullableFilter<"Pedido"> | string | null
    estadoPedido?: XOR<EstadoRelationFilter, EstadoWhereInput>
    encabezadoCompras?: XOR<EncabezadoCompraRelationFilter, EncabezadoCompraWhereInput>
    TrasladoBodegas?: TrasladoBodegasListRelationFilter
  }, "idEncabezadoCompra">

  export type PedidoOrderByWithAggregationInput = {
    idEncabezadoCompra?: SortOrder
    fechaPedido?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    OR?: PedidoScalarWhereWithAggregatesInput[]
    NOT?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    idEncabezadoCompra?: IntWithAggregatesFilter<"Pedido"> | number
    fechaPedido?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
    idEstado?: IntWithAggregatesFilter<"Pedido"> | number
    observaciones?: StringNullableWithAggregatesFilter<"Pedido"> | string | null
  }

  export type TrasladoBodegasWhereInput = {
    AND?: TrasladoBodegasWhereInput | TrasladoBodegasWhereInput[]
    OR?: TrasladoBodegasWhereInput[]
    NOT?: TrasladoBodegasWhereInput | TrasladoBodegasWhereInput[]
    idPedido?: IntFilter<"TrasladoBodegas"> | number
    idDestino?: IntFilter<"TrasladoBodegas"> | number
    pedidos?: XOR<PedidoRelationFilter, PedidoWhereInput>
    destinos?: XOR<TrasladoDestinoRelationFilter, TrasladoDestinoWhereInput>
  }

  export type TrasladoBodegasOrderByWithRelationInput = {
    idPedido?: SortOrder
    idDestino?: SortOrder
    pedidos?: PedidoOrderByWithRelationInput
    destinos?: TrasladoDestinoOrderByWithRelationInput
  }

  export type TrasladoBodegasWhereUniqueInput = Prisma.AtLeast<{
    idPedido_idDestino?: TrasladoBodegasIdPedidoIdDestinoCompoundUniqueInput
    AND?: TrasladoBodegasWhereInput | TrasladoBodegasWhereInput[]
    OR?: TrasladoBodegasWhereInput[]
    NOT?: TrasladoBodegasWhereInput | TrasladoBodegasWhereInput[]
    idPedido?: IntFilter<"TrasladoBodegas"> | number
    idDestino?: IntFilter<"TrasladoBodegas"> | number
    pedidos?: XOR<PedidoRelationFilter, PedidoWhereInput>
    destinos?: XOR<TrasladoDestinoRelationFilter, TrasladoDestinoWhereInput>
  }, "idPedido_idDestino">

  export type TrasladoBodegasOrderByWithAggregationInput = {
    idPedido?: SortOrder
    idDestino?: SortOrder
    _count?: TrasladoBodegasCountOrderByAggregateInput
    _avg?: TrasladoBodegasAvgOrderByAggregateInput
    _max?: TrasladoBodegasMaxOrderByAggregateInput
    _min?: TrasladoBodegasMinOrderByAggregateInput
    _sum?: TrasladoBodegasSumOrderByAggregateInput
  }

  export type TrasladoBodegasScalarWhereWithAggregatesInput = {
    AND?: TrasladoBodegasScalarWhereWithAggregatesInput | TrasladoBodegasScalarWhereWithAggregatesInput[]
    OR?: TrasladoBodegasScalarWhereWithAggregatesInput[]
    NOT?: TrasladoBodegasScalarWhereWithAggregatesInput | TrasladoBodegasScalarWhereWithAggregatesInput[]
    idPedido?: IntWithAggregatesFilter<"TrasladoBodegas"> | number
    idDestino?: IntWithAggregatesFilter<"TrasladoBodegas"> | number
  }

  export type TrasladoDestinoWhereInput = {
    AND?: TrasladoDestinoWhereInput | TrasladoDestinoWhereInput[]
    OR?: TrasladoDestinoWhereInput[]
    NOT?: TrasladoDestinoWhereInput | TrasladoDestinoWhereInput[]
    id?: IntFilter<"TrasladoDestino"> | number
    idBodegaDestino?: IntFilter<"TrasladoDestino"> | number
    fechaRecibido?: DateTimeFilter<"TrasladoDestino"> | Date | string
    idEstado?: IntFilter<"TrasladoDestino"> | number
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
    estadoDestino?: XOR<EstadoRelationFilter, EstadoWhereInput>
    TrasladoBodegas?: TrasladoBodegasListRelationFilter
  }

  export type TrasladoDestinoOrderByWithRelationInput = {
    id?: SortOrder
    idBodegaDestino?: SortOrder
    fechaRecibido?: SortOrder
    idEstado?: SortOrder
    bodegas?: BodegaOrderByWithRelationInput
    estadoDestino?: EstadoOrderByWithRelationInput
    TrasladoBodegas?: TrasladoBodegasOrderByRelationAggregateInput
  }

  export type TrasladoDestinoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TrasladoDestinoWhereInput | TrasladoDestinoWhereInput[]
    OR?: TrasladoDestinoWhereInput[]
    NOT?: TrasladoDestinoWhereInput | TrasladoDestinoWhereInput[]
    idBodegaDestino?: IntFilter<"TrasladoDestino"> | number
    fechaRecibido?: DateTimeFilter<"TrasladoDestino"> | Date | string
    idEstado?: IntFilter<"TrasladoDestino"> | number
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
    estadoDestino?: XOR<EstadoRelationFilter, EstadoWhereInput>
    TrasladoBodegas?: TrasladoBodegasListRelationFilter
  }, "id">

  export type TrasladoDestinoOrderByWithAggregationInput = {
    id?: SortOrder
    idBodegaDestino?: SortOrder
    fechaRecibido?: SortOrder
    idEstado?: SortOrder
    _count?: TrasladoDestinoCountOrderByAggregateInput
    _avg?: TrasladoDestinoAvgOrderByAggregateInput
    _max?: TrasladoDestinoMaxOrderByAggregateInput
    _min?: TrasladoDestinoMinOrderByAggregateInput
    _sum?: TrasladoDestinoSumOrderByAggregateInput
  }

  export type TrasladoDestinoScalarWhereWithAggregatesInput = {
    AND?: TrasladoDestinoScalarWhereWithAggregatesInput | TrasladoDestinoScalarWhereWithAggregatesInput[]
    OR?: TrasladoDestinoScalarWhereWithAggregatesInput[]
    NOT?: TrasladoDestinoScalarWhereWithAggregatesInput | TrasladoDestinoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TrasladoDestino"> | number
    idBodegaDestino?: IntWithAggregatesFilter<"TrasladoDestino"> | number
    fechaRecibido?: DateTimeWithAggregatesFilter<"TrasladoDestino"> | Date | string
    idEstado?: IntWithAggregatesFilter<"TrasladoDestino"> | number
  }

  export type HistorialWhereInput = {
    AND?: HistorialWhereInput | HistorialWhereInput[]
    OR?: HistorialWhereInput[]
    NOT?: HistorialWhereInput | HistorialWhereInput[]
    id?: IntFilter<"Historial"> | number
    idBodega?: IntFilter<"Historial"> | number
    idUsuarioRegistro?: IntFilter<"Historial"> | number
    idProducto?: IntFilter<"Historial"> | number
    fechaAjuste?: DateTimeFilter<"Historial"> | Date | string
    justificacion?: StringFilter<"Historial"> | string
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
    UsuarioRegistro?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    productos?: XOR<ProductoRelationFilter, ProductoWhereInput>
  }

  export type HistorialOrderByWithRelationInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    fechaAjuste?: SortOrder
    justificacion?: SortOrder
    bodegas?: BodegaOrderByWithRelationInput
    UsuarioRegistro?: UsuarioOrderByWithRelationInput
    productos?: ProductoOrderByWithRelationInput
  }

  export type HistorialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistorialWhereInput | HistorialWhereInput[]
    OR?: HistorialWhereInput[]
    NOT?: HistorialWhereInput | HistorialWhereInput[]
    idBodega?: IntFilter<"Historial"> | number
    idUsuarioRegistro?: IntFilter<"Historial"> | number
    idProducto?: IntFilter<"Historial"> | number
    fechaAjuste?: DateTimeFilter<"Historial"> | Date | string
    justificacion?: StringFilter<"Historial"> | string
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
    UsuarioRegistro?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    productos?: XOR<ProductoRelationFilter, ProductoWhereInput>
  }, "id">

  export type HistorialOrderByWithAggregationInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    fechaAjuste?: SortOrder
    justificacion?: SortOrder
    _count?: HistorialCountOrderByAggregateInput
    _avg?: HistorialAvgOrderByAggregateInput
    _max?: HistorialMaxOrderByAggregateInput
    _min?: HistorialMinOrderByAggregateInput
    _sum?: HistorialSumOrderByAggregateInput
  }

  export type HistorialScalarWhereWithAggregatesInput = {
    AND?: HistorialScalarWhereWithAggregatesInput | HistorialScalarWhereWithAggregatesInput[]
    OR?: HistorialScalarWhereWithAggregatesInput[]
    NOT?: HistorialScalarWhereWithAggregatesInput | HistorialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Historial"> | number
    idBodega?: IntWithAggregatesFilter<"Historial"> | number
    idUsuarioRegistro?: IntWithAggregatesFilter<"Historial"> | number
    idProducto?: IntWithAggregatesFilter<"Historial"> | number
    fechaAjuste?: DateTimeWithAggregatesFilter<"Historial"> | Date | string
    justificacion?: StringWithAggregatesFilter<"Historial"> | string
  }

  export type UsuarioCreateInput = {
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    ubicacion: UbicacionCreateNestedOneWithoutUsuarioInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutUsuarioInput
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioProveedorInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    idUbicacion: number
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutUsuarioInput
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioProveedorInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ubicacion?: UbicacionUpdateOneRequiredWithoutUsuarioNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutUsuarioNestedInput
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioProveedorNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idUbicacion?: IntFieldUpdateOperationsInput | number
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutUsuarioNestedInput
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioProveedorNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    idUbicacion: number
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idUbicacion?: IntFieldUpdateOperationsInput | number
  }

  export type EstadoCreateInput = {
    estado: string
    pedidos?: PedidoCreateNestedManyWithoutEstadoPedidoInput
    TrasladoDestino?: TrasladoDestinoCreateNestedManyWithoutEstadoDestinoInput
  }

  export type EstadoUncheckedCreateInput = {
    id?: number
    estado: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutEstadoPedidoInput
    TrasladoDestino?: TrasladoDestinoUncheckedCreateNestedManyWithoutEstadoDestinoInput
  }

  export type EstadoUpdateInput = {
    estado?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutEstadoPedidoNestedInput
    TrasladoDestino?: TrasladoDestinoUpdateManyWithoutEstadoDestinoNestedInput
  }

  export type EstadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutEstadoPedidoNestedInput
    TrasladoDestino?: TrasladoDestinoUncheckedUpdateManyWithoutEstadoDestinoNestedInput
  }

  export type EstadoCreateManyInput = {
    id?: number
    estado: string
  }

  export type EstadoUpdateManyMutationInput = {
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaCreateInput = {
    nombre: string
    subCategoria?: SubCategoriaCreateNestedManyWithoutCategoriasInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    subCategoria?: SubCategoriaUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type CategoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    subCategoria?: SubCategoriaUpdateManyWithoutCategoriasNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    subCategoria?: SubCategoriaUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type CategoriaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type CategoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoriaCreateInput = {
    nombre: string
    producto?: ProductoCreateNestedManyWithoutSubCategoriasInput
    categorias?: CategoriaCreateNestedManyWithoutSubCategoriaInput
  }

  export type SubCategoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    producto?: ProductoUncheckedCreateNestedManyWithoutSubCategoriasInput
    categorias?: CategoriaUncheckedCreateNestedManyWithoutSubCategoriaInput
  }

  export type SubCategoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUpdateManyWithoutSubCategoriasNestedInput
    categorias?: CategoriaUpdateManyWithoutSubCategoriaNestedInput
  }

  export type SubCategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUncheckedUpdateManyWithoutSubCategoriasNestedInput
    categorias?: CategoriaUncheckedUpdateManyWithoutSubCategoriaNestedInput
  }

  export type SubCategoriaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type SubCategoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoCreateInput = {
    codigoProducto: string
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductosInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductosInput
    Historial?: HistorialCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateInput = {
    id?: number
    codigoProducto: string
    nombre: string
    descripcion: string
    idSubCategoria: number
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedCreateNestedManyWithoutProductosInput
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductosInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoUpdateInput = {
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductosNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductosNestedInput
    Historial?: HistorialUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedUpdateManyWithoutProductosNestedInput
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductosNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type ProductoCreateManyInput = {
    id?: number
    codigoProducto: string
    nombre: string
    descripcion: string
    idSubCategoria: number
    stock: number
    precio: Decimal | DecimalJsLike | number | string
  }

  export type ProductoUpdateManyMutationInput = {
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FotoCreateInput = {
    foto: Buffer
    productos: ProductoCreateNestedOneWithoutFotoInput
  }

  export type FotoUncheckedCreateInput = {
    id?: number
    idProducto: number
    foto: Buffer
  }

  export type FotoUpdateInput = {
    foto?: BytesFieldUpdateOperationsInput | Buffer
    productos?: ProductoUpdateOneRequiredWithoutFotoNestedInput
  }

  export type FotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type FotoCreateManyInput = {
    id?: number
    idProducto: number
    foto: Buffer
  }

  export type FotoUpdateManyMutationInput = {
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type FotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type UbicacionCreateInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaCreateNestedManyWithoutUbicacionInput
    cantones?: CantonCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioUncheckedCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaUncheckedCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaUncheckedCreateNestedManyWithoutUbicacionInput
    cantones?: CantonUncheckedCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUpdateInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUncheckedUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUncheckedUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUncheckedUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUncheckedUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionCreateManyInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
  }

  export type UbicacionUpdateManyMutationInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
  }

  export type UbicacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
  }

  export type ProvinciaCreateInput = {
    nombre: string
    cantones?: CantonCreateNestedManyWithoutProvinciasInput
    distritos?: DistritoCreateNestedManyWithoutProvinciasInput
    barrios?: BarrioCreateNestedManyWithoutProvinciasInput
    ubicacion?: UbicacionCreateNestedOneWithoutProvinciaInput
  }

  export type ProvinciaUncheckedCreateInput = {
    id?: number
    nombre: string
    cantones?: CantonUncheckedCreateNestedManyWithoutProvinciasInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutProvinciasInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutProvinciasInput
  }

  export type ProvinciaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUpdateManyWithoutProvinciasNestedInput
    distritos?: DistritoUpdateManyWithoutProvinciasNestedInput
    barrios?: BarrioUpdateManyWithoutProvinciasNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUncheckedUpdateManyWithoutProvinciasNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutProvinciasNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutProvinciasNestedInput
  }

  export type ProvinciaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type ProvinciaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinciaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CantonCreateInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutCantonesInput
    ubicacion?: UbicacionCreateNestedOneWithoutCantonesInput
    distritos?: DistritoCreateNestedManyWithoutCantonesInput
    barrios?: BarrioCreateNestedManyWithoutCantonesInput
  }

  export type CantonUncheckedCreateInput = {
    id?: number
    idProvincia: number
    nombre: string
    distritos?: DistritoUncheckedCreateNestedManyWithoutCantonesInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutCantonesInput
  }

  export type CantonUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutCantonesNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutCantonesNestedInput
    distritos?: DistritoUpdateManyWithoutCantonesNestedInput
    barrios?: BarrioUpdateManyWithoutCantonesNestedInput
  }

  export type CantonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    distritos?: DistritoUncheckedUpdateManyWithoutCantonesNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutCantonesNestedInput
  }

  export type CantonCreateManyInput = {
    id?: number
    idProvincia: number
    nombre: string
  }

  export type CantonUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CantonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DistritoCreateInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutDistritosInput
    cantones: CantonCreateNestedOneWithoutDistritosInput
    ubicacion?: UbicacionCreateNestedOneWithoutDistritosInput
    barrios?: BarrioCreateNestedManyWithoutDistritosInput
  }

  export type DistritoUncheckedCreateInput = {
    id?: number
    idProvincia: number
    idCanton: number
    nombre: string
    barrios?: BarrioUncheckedCreateNestedManyWithoutDistritosInput
  }

  export type DistritoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutDistritosNestedInput
    cantones?: CantonUpdateOneRequiredWithoutDistritosNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutDistritosNestedInput
    barrios?: BarrioUpdateManyWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    barrios?: BarrioUncheckedUpdateManyWithoutDistritosNestedInput
  }

  export type DistritoCreateManyInput = {
    id?: number
    idProvincia: number
    idCanton: number
    nombre: string
  }

  export type DistritoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DistritoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioCreateInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutBarriosInput
    cantones: CantonCreateNestedOneWithoutBarriosInput
    distritos: DistritoCreateNestedOneWithoutBarriosInput
    ubicacion?: UbicacionCreateNestedOneWithoutBarriosInput
  }

  export type BarrioUncheckedCreateInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    nombre: string
  }

  export type BarrioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutBarriosNestedInput
    cantones?: CantonUpdateOneRequiredWithoutBarriosNestedInput
    distritos?: DistritoUpdateOneRequiredWithoutBarriosNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBarriosNestedInput
  }

  export type BarrioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioCreateManyInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    nombre: string
  }

  export type BarrioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BodegaCreateInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutBodegasInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutBodegasInput
    Historial?: HistorialCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoCreateNestedManyWithoutBodegasInput
  }

  export type BodegaUncheckedCreateInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutBodegasInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoUncheckedCreateNestedManyWithoutBodegasInput
  }

  export type BodegaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutBodegasNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUpdateManyWithoutBodegasNestedInput
  }

  export type BodegaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUncheckedUpdateManyWithoutBodegasNestedInput
  }

  export type BodegaCreateManyInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
  }

  export type BodegaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BodegaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BodegaProductosCreateInput = {
    fechaRegistro?: Date | string
    cantidad: number
    bodegas: BodegaCreateNestedOneWithoutBodegaProductosInput
    producto: ProductoCreateNestedOneWithoutBodegaProductosInput
    usuario: UsuarioCreateNestedOneWithoutBodegaProductosInput
  }

  export type BodegaProductosUncheckedCreateInput = {
    idBodega: number
    idProducto: number
    idUsuario: number
    fechaRegistro?: Date | string
    cantidad: number
  }

  export type BodegaProductosUpdateInput = {
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    bodegas?: BodegaUpdateOneRequiredWithoutBodegaProductosNestedInput
    producto?: ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutBodegaProductosNestedInput
  }

  export type BodegaProductosUncheckedUpdateInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type BodegaProductosCreateManyInput = {
    idBodega: number
    idProducto: number
    idUsuario: number
    fechaRegistro?: Date | string
    cantidad: number
  }

  export type BodegaProductosUpdateManyMutationInput = {
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type BodegaProductosUncheckedUpdateManyInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type EncabezadoCompraCreateInput = {
    fechaCompra?: Date | string
    idUsuarioRegistro: number
    usuarioProveedor: UsuarioCreateNestedOneWithoutEncabezadoComprasInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutEncabezadoComprasInput
    pedidos?: PedidoCreateNestedManyWithoutEncabezadoComprasInput
  }

  export type EncabezadoCompraUncheckedCreateInput = {
    id?: number
    fechaCompra?: Date | string
    idUsuarioProveedor: number
    idUsuarioRegistro: number
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoComprasInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutEncabezadoComprasInput
  }

  export type EncabezadoCompraUpdateInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    usuarioProveedor?: UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutEncabezadoComprasNestedInput
    pedidos?: PedidoUpdateManyWithoutEncabezadoComprasNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioProveedor?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutEncabezadoComprasNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutEncabezadoComprasNestedInput
  }

  export type EncabezadoCompraCreateManyInput = {
    id?: number
    fechaCompra?: Date | string
    idUsuarioProveedor: number
    idUsuarioRegistro: number
  }

  export type EncabezadoCompraUpdateManyMutationInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
  }

  export type EncabezadoCompraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioProveedor?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraCreateInput = {
    cantidad: number
    productos: ProductoCreateNestedOneWithoutDetalleComprasInput
    encabezadoCompras: EncabezadoCompraCreateNestedOneWithoutDetalleComprasInput
    bodegas: BodegaCreateNestedOneWithoutDetalleComprasInput
  }

  export type DetalleCompraUncheckedCreateInput = {
    id?: number
    idEncabezadoCompra: number
    idProducto: number
    idBodega: number
    cantidad: number
  }

  export type DetalleCompraUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUpdateOneRequiredWithoutDetalleComprasNestedInput
    encabezadoCompras?: EncabezadoCompraUpdateOneRequiredWithoutDetalleComprasNestedInput
    bodegas?: BodegaUpdateOneRequiredWithoutDetalleComprasNestedInput
  }

  export type DetalleCompraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraCreateManyInput = {
    id?: number
    idEncabezadoCompra: number
    idProducto: number
    idBodega: number
    cantidad: number
  }

  export type DetalleCompraUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoCreateInput = {
    fechaPedido?: Date | string
    observaciones?: string | null
    estadoPedido: EstadoCreateNestedOneWithoutPedidosInput
    encabezadoCompras: EncabezadoCompraCreateNestedOneWithoutPedidosInput
    TrasladoBodegas?: TrasladoBodegasCreateNestedManyWithoutPedidosInput
  }

  export type PedidoUncheckedCreateInput = {
    idEncabezadoCompra: number
    fechaPedido?: Date | string
    idEstado: number
    observaciones?: string | null
    TrasladoBodegas?: TrasladoBodegasUncheckedCreateNestedManyWithoutPedidosInput
  }

  export type PedidoUpdateInput = {
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estadoPedido?: EstadoUpdateOneRequiredWithoutPedidosNestedInput
    encabezadoCompras?: EncabezadoCompraUpdateOneRequiredWithoutPedidosNestedInput
    TrasladoBodegas?: TrasladoBodegasUpdateManyWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    TrasladoBodegas?: TrasladoBodegasUncheckedUpdateManyWithoutPedidosNestedInput
  }

  export type PedidoCreateManyInput = {
    idEncabezadoCompra: number
    fechaPedido?: Date | string
    idEstado: number
    observaciones?: string | null
  }

  export type PedidoUpdateManyMutationInput = {
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PedidoUncheckedUpdateManyInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrasladoBodegasCreateInput = {
    pedidos: PedidoCreateNestedOneWithoutTrasladoBodegasInput
    destinos: TrasladoDestinoCreateNestedOneWithoutTrasladoBodegasInput
  }

  export type TrasladoBodegasUncheckedCreateInput = {
    idPedido: number
    idDestino: number
  }

  export type TrasladoBodegasUpdateInput = {
    pedidos?: PedidoUpdateOneRequiredWithoutTrasladoBodegasNestedInput
    destinos?: TrasladoDestinoUpdateOneRequiredWithoutTrasladoBodegasNestedInput
  }

  export type TrasladoBodegasUncheckedUpdateInput = {
    idPedido?: IntFieldUpdateOperationsInput | number
    idDestino?: IntFieldUpdateOperationsInput | number
  }

  export type TrasladoBodegasCreateManyInput = {
    idPedido: number
    idDestino: number
  }

  export type TrasladoBodegasUpdateManyMutationInput = {

  }

  export type TrasladoBodegasUncheckedUpdateManyInput = {
    idPedido?: IntFieldUpdateOperationsInput | number
    idDestino?: IntFieldUpdateOperationsInput | number
  }

  export type TrasladoDestinoCreateInput = {
    fechaRecibido?: Date | string
    bodegas: BodegaCreateNestedOneWithoutTrasladoDestinoInput
    estadoDestino: EstadoCreateNestedOneWithoutTrasladoDestinoInput
    TrasladoBodegas?: TrasladoBodegasCreateNestedManyWithoutDestinosInput
  }

  export type TrasladoDestinoUncheckedCreateInput = {
    id?: number
    idBodegaDestino: number
    fechaRecibido?: Date | string
    idEstado: number
    TrasladoBodegas?: TrasladoBodegasUncheckedCreateNestedManyWithoutDestinosInput
  }

  export type TrasladoDestinoUpdateInput = {
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegas?: BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    estadoDestino?: EstadoUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    TrasladoBodegas?: TrasladoBodegasUpdateManyWithoutDestinosNestedInput
  }

  export type TrasladoDestinoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    TrasladoBodegas?: TrasladoBodegasUncheckedUpdateManyWithoutDestinosNestedInput
  }

  export type TrasladoDestinoCreateManyInput = {
    id?: number
    idBodegaDestino: number
    fechaRecibido?: Date | string
    idEstado: number
  }

  export type TrasladoDestinoUpdateManyMutationInput = {
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoDestinoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
  }

  export type HistorialCreateInput = {
    fechaAjuste?: Date | string
    justificacion: string
    bodegas: BodegaCreateNestedOneWithoutHistorialInput
    UsuarioRegistro: UsuarioCreateNestedOneWithoutHistorialInput
    productos: ProductoCreateNestedOneWithoutHistorialInput
  }

  export type HistorialUncheckedCreateInput = {
    id?: number
    idBodega: number
    idUsuarioRegistro: number
    idProducto: number
    fechaAjuste?: Date | string
    justificacion: string
  }

  export type HistorialUpdateInput = {
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
    bodegas?: BodegaUpdateOneRequiredWithoutHistorialNestedInput
    UsuarioRegistro?: UsuarioUpdateOneRequiredWithoutHistorialNestedInput
    productos?: ProductoUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type HistorialCreateManyInput = {
    id?: number
    idBodega: number
    idUsuarioRegistro: number
    idProducto: number
    fechaAjuste?: Date | string
    justificacion: string
  }

  export type HistorialUpdateManyMutationInput = {
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type HistorialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type UbicacionRelationFilter = {
    is?: UbicacionWhereInput
    isNot?: UbicacionWhereInput
  }

  export type BodegaProductosListRelationFilter = {
    every?: BodegaProductosWhereInput
    some?: BodegaProductosWhereInput
    none?: BodegaProductosWhereInput
  }

  export type EncabezadoCompraListRelationFilter = {
    every?: EncabezadoCompraWhereInput
    some?: EncabezadoCompraWhereInput
    none?: EncabezadoCompraWhereInput
  }

  export type HistorialListRelationFilter = {
    every?: HistorialWhereInput
    some?: HistorialWhereInput
    none?: HistorialWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BodegaProductosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncabezadoCompraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HistorialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    nombreProveedor?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idUbicacion?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    idUbicacion?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    nombreProveedor?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idUbicacion?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    nombreProveedor?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idUbicacion?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
    idUbicacion?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type TrasladoDestinoListRelationFilter = {
    every?: TrasladoDestinoWhereInput
    some?: TrasladoDestinoWhereInput
    none?: TrasladoDestinoWhereInput
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrasladoDestinoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstadoCountOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
  }

  export type EstadoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EstadoMaxOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
  }

  export type EstadoMinOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
  }

  export type EstadoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubCategoriaListRelationFilter = {
    every?: SubCategoriaWhereInput
    some?: SubCategoriaWhereInput
    none?: SubCategoriaWhereInput
  }

  export type SubCategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput
    some?: ProductoWhereInput
    none?: ProductoWhereInput
  }

  export type CategoriaListRelationFilter = {
    every?: CategoriaWhereInput
    some?: CategoriaWhereInput
    none?: CategoriaWhereInput
  }

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubCategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SubCategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubCategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SubCategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SubCategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type SubCategoriaRelationFilter = {
    is?: SubCategoriaWhereInput
    isNot?: SubCategoriaWhereInput
  }

  export type FotoListRelationFilter = {
    every?: FotoWhereInput
    some?: FotoWhereInput
    none?: FotoWhereInput
  }

  export type DetalleCompraListRelationFilter = {
    every?: DetalleCompraWhereInput
    some?: DetalleCompraWhereInput
    none?: DetalleCompraWhereInput
  }

  export type FotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DetalleCompraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    codigoProducto?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    idSubCategoria?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
  }

  export type ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
    idSubCategoria?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigoProducto?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    idSubCategoria?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    codigoProducto?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    idSubCategoria?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
  }

  export type ProductoSumOrderByAggregateInput = {
    id?: SortOrder
    idSubCategoria?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type ProductoRelationFilter = {
    is?: ProductoWhereInput
    isNot?: ProductoWhereInput
  }

  export type FotoCountOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
  }

  export type FotoAvgOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
  }

  export type FotoMaxOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
  }

  export type FotoMinOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
  }

  export type FotoSumOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type BodegaListRelationFilter = {
    every?: BodegaWhereInput
    some?: BodegaWhereInput
    none?: BodegaWhereInput
  }

  export type ProvinciaListRelationFilter = {
    every?: ProvinciaWhereInput
    some?: ProvinciaWhereInput
    none?: ProvinciaWhereInput
  }

  export type CantonListRelationFilter = {
    every?: CantonWhereInput
    some?: CantonWhereInput
    none?: CantonWhereInput
  }

  export type DistritoListRelationFilter = {
    every?: DistritoWhereInput
    some?: DistritoWhereInput
    none?: DistritoWhereInput
  }

  export type BarrioListRelationFilter = {
    every?: BarrioWhereInput
    some?: BarrioWhereInput
    none?: BarrioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BodegaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvinciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CantonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistritoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarrioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UbicacionCountOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    idBarrio?: SortOrder
  }

  export type UbicacionAvgOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    idBarrio?: SortOrder
  }

  export type UbicacionMaxOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    idBarrio?: SortOrder
  }

  export type UbicacionMinOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    idBarrio?: SortOrder
  }

  export type UbicacionSumOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    idBarrio?: SortOrder
  }

  export type ProvinciaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type ProvinciaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProvinciaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type ProvinciaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type ProvinciaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProvinciaRelationFilter = {
    is?: ProvinciaWhereInput
    isNot?: ProvinciaWhereInput
  }

  export type CantonCountOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    nombre?: SortOrder
  }

  export type CantonAvgOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
  }

  export type CantonMaxOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    nombre?: SortOrder
  }

  export type CantonMinOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    nombre?: SortOrder
  }

  export type CantonSumOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
  }

  export type CantonRelationFilter = {
    is?: CantonWhereInput
    isNot?: CantonWhereInput
  }

  export type DistritoCountOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    nombre?: SortOrder
  }

  export type DistritoAvgOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
  }

  export type DistritoMaxOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    nombre?: SortOrder
  }

  export type DistritoMinOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    nombre?: SortOrder
  }

  export type DistritoSumOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
  }

  export type DistritoRelationFilter = {
    is?: DistritoWhereInput
    isNot?: DistritoWhereInput
  }

  export type BarrioCountOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    nombre?: SortOrder
  }

  export type BarrioAvgOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
  }

  export type BarrioMaxOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    nombre?: SortOrder
  }

  export type BarrioMinOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    nombre?: SortOrder
  }

  export type BarrioSumOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BodegaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
  }

  export type BodegaAvgOrderByAggregateInput = {
    id?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
  }

  export type BodegaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
  }

  export type BodegaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
  }

  export type BodegaSumOrderByAggregateInput = {
    id?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BodegaRelationFilter = {
    is?: BodegaWhereInput
    isNot?: BodegaWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type BodegaProductosIdBodegaIdProductoIdUsuarioCompoundUniqueInput = {
    idBodega: number
    idProducto: number
    idUsuario: number
  }

  export type BodegaProductosCountOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    cantidad?: SortOrder
  }

  export type BodegaProductosAvgOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidad?: SortOrder
  }

  export type BodegaProductosMaxOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    cantidad?: SortOrder
  }

  export type BodegaProductosMinOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    cantidad?: SortOrder
  }

  export type BodegaProductosSumOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidad?: SortOrder
  }

  export type EncabezadoCompraCountOrderByAggregateInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idUsuarioProveedor?: SortOrder
    idUsuarioRegistro?: SortOrder
  }

  export type EncabezadoCompraAvgOrderByAggregateInput = {
    id?: SortOrder
    idUsuarioProveedor?: SortOrder
    idUsuarioRegistro?: SortOrder
  }

  export type EncabezadoCompraMaxOrderByAggregateInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idUsuarioProveedor?: SortOrder
    idUsuarioRegistro?: SortOrder
  }

  export type EncabezadoCompraMinOrderByAggregateInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idUsuarioProveedor?: SortOrder
    idUsuarioRegistro?: SortOrder
  }

  export type EncabezadoCompraSumOrderByAggregateInput = {
    id?: SortOrder
    idUsuarioProveedor?: SortOrder
    idUsuarioRegistro?: SortOrder
  }

  export type EncabezadoCompraRelationFilter = {
    is?: EncabezadoCompraWhereInput
    isNot?: EncabezadoCompraWhereInput
  }

  export type DetalleCompraCountOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleCompraAvgOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleCompraMaxOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleCompraMinOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleCompraSumOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type EstadoRelationFilter = {
    is?: EstadoWhereInput
    isNot?: EstadoWhereInput
  }

  export type TrasladoBodegasListRelationFilter = {
    every?: TrasladoBodegasWhereInput
    some?: TrasladoBodegasWhereInput
    none?: TrasladoBodegasWhereInput
  }

  export type TrasladoBodegasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoCountOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    fechaPedido?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    fechaPedido?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    fechaPedido?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
  }

  export type PedidoRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type TrasladoDestinoRelationFilter = {
    is?: TrasladoDestinoWhereInput
    isNot?: TrasladoDestinoWhereInput
  }

  export type TrasladoBodegasIdPedidoIdDestinoCompoundUniqueInput = {
    idPedido: number
    idDestino: number
  }

  export type TrasladoBodegasCountOrderByAggregateInput = {
    idPedido?: SortOrder
    idDestino?: SortOrder
  }

  export type TrasladoBodegasAvgOrderByAggregateInput = {
    idPedido?: SortOrder
    idDestino?: SortOrder
  }

  export type TrasladoBodegasMaxOrderByAggregateInput = {
    idPedido?: SortOrder
    idDestino?: SortOrder
  }

  export type TrasladoBodegasMinOrderByAggregateInput = {
    idPedido?: SortOrder
    idDestino?: SortOrder
  }

  export type TrasladoBodegasSumOrderByAggregateInput = {
    idPedido?: SortOrder
    idDestino?: SortOrder
  }

  export type TrasladoDestinoCountOrderByAggregateInput = {
    id?: SortOrder
    idBodegaDestino?: SortOrder
    fechaRecibido?: SortOrder
    idEstado?: SortOrder
  }

  export type TrasladoDestinoAvgOrderByAggregateInput = {
    id?: SortOrder
    idBodegaDestino?: SortOrder
    idEstado?: SortOrder
  }

  export type TrasladoDestinoMaxOrderByAggregateInput = {
    id?: SortOrder
    idBodegaDestino?: SortOrder
    fechaRecibido?: SortOrder
    idEstado?: SortOrder
  }

  export type TrasladoDestinoMinOrderByAggregateInput = {
    id?: SortOrder
    idBodegaDestino?: SortOrder
    fechaRecibido?: SortOrder
    idEstado?: SortOrder
  }

  export type TrasladoDestinoSumOrderByAggregateInput = {
    id?: SortOrder
    idBodegaDestino?: SortOrder
    idEstado?: SortOrder
  }

  export type HistorialCountOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    fechaAjuste?: SortOrder
    justificacion?: SortOrder
  }

  export type HistorialAvgOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
  }

  export type HistorialMaxOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    fechaAjuste?: SortOrder
    justificacion?: SortOrder
  }

  export type HistorialMinOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    fechaAjuste?: SortOrder
    justificacion?: SortOrder
  }

  export type HistorialSumOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
  }

  export type UbicacionCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<UbicacionCreateWithoutUsuarioInput, UbicacionUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutUsuarioInput
    connect?: UbicacionWhereUniqueInput
  }

  export type BodegaProductosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<BodegaProductosCreateWithoutUsuarioInput, BodegaProductosUncheckedCreateWithoutUsuarioInput> | BodegaProductosCreateWithoutUsuarioInput[] | BodegaProductosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutUsuarioInput | BodegaProductosCreateOrConnectWithoutUsuarioInput[]
    createMany?: BodegaProductosCreateManyUsuarioInputEnvelope
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
  }

  export type EncabezadoCompraCreateNestedManyWithoutUsuarioProveedorInput = {
    create?: XOR<EncabezadoCompraCreateWithoutUsuarioProveedorInput, EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput> | EncabezadoCompraCreateWithoutUsuarioProveedorInput[] | EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput | EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput[]
    createMany?: EncabezadoCompraCreateManyUsuarioProveedorInputEnvelope
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
  }

  export type HistorialCreateNestedManyWithoutUsuarioRegistroInput = {
    create?: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput> | HistorialCreateWithoutUsuarioRegistroInput[] | HistorialUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutUsuarioRegistroInput | HistorialCreateOrConnectWithoutUsuarioRegistroInput[]
    createMany?: HistorialCreateManyUsuarioRegistroInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type BodegaProductosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<BodegaProductosCreateWithoutUsuarioInput, BodegaProductosUncheckedCreateWithoutUsuarioInput> | BodegaProductosCreateWithoutUsuarioInput[] | BodegaProductosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutUsuarioInput | BodegaProductosCreateOrConnectWithoutUsuarioInput[]
    createMany?: BodegaProductosCreateManyUsuarioInputEnvelope
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
  }

  export type EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioProveedorInput = {
    create?: XOR<EncabezadoCompraCreateWithoutUsuarioProveedorInput, EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput> | EncabezadoCompraCreateWithoutUsuarioProveedorInput[] | EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput | EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput[]
    createMany?: EncabezadoCompraCreateManyUsuarioProveedorInputEnvelope
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
  }

  export type HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput = {
    create?: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput> | HistorialCreateWithoutUsuarioRegistroInput[] | HistorialUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutUsuarioRegistroInput | HistorialCreateOrConnectWithoutUsuarioRegistroInput[]
    createMany?: HistorialCreateManyUsuarioRegistroInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type UbicacionUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<UbicacionCreateWithoutUsuarioInput, UbicacionUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutUsuarioInput
    upsert?: UbicacionUpsertWithoutUsuarioInput
    connect?: UbicacionWhereUniqueInput
    update?: XOR<XOR<UbicacionUpdateToOneWithWhereWithoutUsuarioInput, UbicacionUpdateWithoutUsuarioInput>, UbicacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type BodegaProductosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<BodegaProductosCreateWithoutUsuarioInput, BodegaProductosUncheckedCreateWithoutUsuarioInput> | BodegaProductosCreateWithoutUsuarioInput[] | BodegaProductosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutUsuarioInput | BodegaProductosCreateOrConnectWithoutUsuarioInput[]
    upsert?: BodegaProductosUpsertWithWhereUniqueWithoutUsuarioInput | BodegaProductosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: BodegaProductosCreateManyUsuarioInputEnvelope
    set?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    disconnect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    delete?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    update?: BodegaProductosUpdateWithWhereUniqueWithoutUsuarioInput | BodegaProductosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: BodegaProductosUpdateManyWithWhereWithoutUsuarioInput | BodegaProductosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: BodegaProductosScalarWhereInput | BodegaProductosScalarWhereInput[]
  }

  export type EncabezadoCompraUpdateManyWithoutUsuarioProveedorNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutUsuarioProveedorInput, EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput> | EncabezadoCompraCreateWithoutUsuarioProveedorInput[] | EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput | EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput[]
    upsert?: EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioProveedorInput | EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioProveedorInput[]
    createMany?: EncabezadoCompraCreateManyUsuarioProveedorInputEnvelope
    set?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    disconnect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    delete?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    update?: EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioProveedorInput | EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioProveedorInput[]
    updateMany?: EncabezadoCompraUpdateManyWithWhereWithoutUsuarioProveedorInput | EncabezadoCompraUpdateManyWithWhereWithoutUsuarioProveedorInput[]
    deleteMany?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
  }

  export type HistorialUpdateManyWithoutUsuarioRegistroNestedInput = {
    create?: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput> | HistorialCreateWithoutUsuarioRegistroInput[] | HistorialUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutUsuarioRegistroInput | HistorialCreateOrConnectWithoutUsuarioRegistroInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput | HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput[]
    createMany?: HistorialCreateManyUsuarioRegistroInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput | HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput | HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BodegaProductosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<BodegaProductosCreateWithoutUsuarioInput, BodegaProductosUncheckedCreateWithoutUsuarioInput> | BodegaProductosCreateWithoutUsuarioInput[] | BodegaProductosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutUsuarioInput | BodegaProductosCreateOrConnectWithoutUsuarioInput[]
    upsert?: BodegaProductosUpsertWithWhereUniqueWithoutUsuarioInput | BodegaProductosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: BodegaProductosCreateManyUsuarioInputEnvelope
    set?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    disconnect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    delete?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    update?: BodegaProductosUpdateWithWhereUniqueWithoutUsuarioInput | BodegaProductosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: BodegaProductosUpdateManyWithWhereWithoutUsuarioInput | BodegaProductosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: BodegaProductosScalarWhereInput | BodegaProductosScalarWhereInput[]
  }

  export type EncabezadoCompraUncheckedUpdateManyWithoutUsuarioProveedorNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutUsuarioProveedorInput, EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput> | EncabezadoCompraCreateWithoutUsuarioProveedorInput[] | EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput | EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput[]
    upsert?: EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioProveedorInput | EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioProveedorInput[]
    createMany?: EncabezadoCompraCreateManyUsuarioProveedorInputEnvelope
    set?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    disconnect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    delete?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    update?: EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioProveedorInput | EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioProveedorInput[]
    updateMany?: EncabezadoCompraUpdateManyWithWhereWithoutUsuarioProveedorInput | EncabezadoCompraUpdateManyWithWhereWithoutUsuarioProveedorInput[]
    deleteMany?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
  }

  export type HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput = {
    create?: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput> | HistorialCreateWithoutUsuarioRegistroInput[] | HistorialUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutUsuarioRegistroInput | HistorialCreateOrConnectWithoutUsuarioRegistroInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput | HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput[]
    createMany?: HistorialCreateManyUsuarioRegistroInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput | HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput | HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type PedidoCreateNestedManyWithoutEstadoPedidoInput = {
    create?: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput> | PedidoCreateWithoutEstadoPedidoInput[] | PedidoUncheckedCreateWithoutEstadoPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEstadoPedidoInput | PedidoCreateOrConnectWithoutEstadoPedidoInput[]
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type TrasladoDestinoCreateNestedManyWithoutEstadoDestinoInput = {
    create?: XOR<TrasladoDestinoCreateWithoutEstadoDestinoInput, TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput> | TrasladoDestinoCreateWithoutEstadoDestinoInput[] | TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput[]
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput | TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput[]
    createMany?: TrasladoDestinoCreateManyEstadoDestinoInputEnvelope
    connect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutEstadoPedidoInput = {
    create?: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput> | PedidoCreateWithoutEstadoPedidoInput[] | PedidoUncheckedCreateWithoutEstadoPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEstadoPedidoInput | PedidoCreateOrConnectWithoutEstadoPedidoInput[]
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type TrasladoDestinoUncheckedCreateNestedManyWithoutEstadoDestinoInput = {
    create?: XOR<TrasladoDestinoCreateWithoutEstadoDestinoInput, TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput> | TrasladoDestinoCreateWithoutEstadoDestinoInput[] | TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput[]
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput | TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput[]
    createMany?: TrasladoDestinoCreateManyEstadoDestinoInputEnvelope
    connect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
  }

  export type PedidoUpdateManyWithoutEstadoPedidoNestedInput = {
    create?: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput> | PedidoCreateWithoutEstadoPedidoInput[] | PedidoUncheckedCreateWithoutEstadoPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEstadoPedidoInput | PedidoCreateOrConnectWithoutEstadoPedidoInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput | PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput[]
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput | PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutEstadoPedidoInput | PedidoUpdateManyWithWhereWithoutEstadoPedidoInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type TrasladoDestinoUpdateManyWithoutEstadoDestinoNestedInput = {
    create?: XOR<TrasladoDestinoCreateWithoutEstadoDestinoInput, TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput> | TrasladoDestinoCreateWithoutEstadoDestinoInput[] | TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput[]
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput | TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput[]
    upsert?: TrasladoDestinoUpsertWithWhereUniqueWithoutEstadoDestinoInput | TrasladoDestinoUpsertWithWhereUniqueWithoutEstadoDestinoInput[]
    createMany?: TrasladoDestinoCreateManyEstadoDestinoInputEnvelope
    set?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    disconnect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    delete?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    connect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    update?: TrasladoDestinoUpdateWithWhereUniqueWithoutEstadoDestinoInput | TrasladoDestinoUpdateWithWhereUniqueWithoutEstadoDestinoInput[]
    updateMany?: TrasladoDestinoUpdateManyWithWhereWithoutEstadoDestinoInput | TrasladoDestinoUpdateManyWithWhereWithoutEstadoDestinoInput[]
    deleteMany?: TrasladoDestinoScalarWhereInput | TrasladoDestinoScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutEstadoPedidoNestedInput = {
    create?: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput> | PedidoCreateWithoutEstadoPedidoInput[] | PedidoUncheckedCreateWithoutEstadoPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEstadoPedidoInput | PedidoCreateOrConnectWithoutEstadoPedidoInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput | PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput[]
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput | PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutEstadoPedidoInput | PedidoUpdateManyWithWhereWithoutEstadoPedidoInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type TrasladoDestinoUncheckedUpdateManyWithoutEstadoDestinoNestedInput = {
    create?: XOR<TrasladoDestinoCreateWithoutEstadoDestinoInput, TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput> | TrasladoDestinoCreateWithoutEstadoDestinoInput[] | TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput[]
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput | TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput[]
    upsert?: TrasladoDestinoUpsertWithWhereUniqueWithoutEstadoDestinoInput | TrasladoDestinoUpsertWithWhereUniqueWithoutEstadoDestinoInput[]
    createMany?: TrasladoDestinoCreateManyEstadoDestinoInputEnvelope
    set?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    disconnect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    delete?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    connect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    update?: TrasladoDestinoUpdateWithWhereUniqueWithoutEstadoDestinoInput | TrasladoDestinoUpdateWithWhereUniqueWithoutEstadoDestinoInput[]
    updateMany?: TrasladoDestinoUpdateManyWithWhereWithoutEstadoDestinoInput | TrasladoDestinoUpdateManyWithWhereWithoutEstadoDestinoInput[]
    deleteMany?: TrasladoDestinoScalarWhereInput | TrasladoDestinoScalarWhereInput[]
  }

  export type SubCategoriaCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput> | SubCategoriaCreateWithoutCategoriasInput[] | SubCategoriaUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutCategoriasInput | SubCategoriaCreateOrConnectWithoutCategoriasInput[]
    connect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
  }

  export type SubCategoriaUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput> | SubCategoriaCreateWithoutCategoriasInput[] | SubCategoriaUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutCategoriasInput | SubCategoriaCreateOrConnectWithoutCategoriasInput[]
    connect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
  }

  export type SubCategoriaUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput> | SubCategoriaCreateWithoutCategoriasInput[] | SubCategoriaUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutCategoriasInput | SubCategoriaCreateOrConnectWithoutCategoriasInput[]
    upsert?: SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput | SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput[]
    set?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    disconnect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    delete?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    connect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    update?: SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput | SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: SubCategoriaUpdateManyWithWhereWithoutCategoriasInput | SubCategoriaUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: SubCategoriaScalarWhereInput | SubCategoriaScalarWhereInput[]
  }

  export type SubCategoriaUncheckedUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput> | SubCategoriaCreateWithoutCategoriasInput[] | SubCategoriaUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutCategoriasInput | SubCategoriaCreateOrConnectWithoutCategoriasInput[]
    upsert?: SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput | SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput[]
    set?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    disconnect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    delete?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    connect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    update?: SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput | SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: SubCategoriaUpdateManyWithWhereWithoutCategoriasInput | SubCategoriaUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: SubCategoriaScalarWhereInput | SubCategoriaScalarWhereInput[]
  }

  export type ProductoCreateNestedManyWithoutSubCategoriasInput = {
    create?: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput> | ProductoCreateWithoutSubCategoriasInput[] | ProductoUncheckedCreateWithoutSubCategoriasInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutSubCategoriasInput | ProductoCreateOrConnectWithoutSubCategoriasInput[]
    createMany?: ProductoCreateManySubCategoriasInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type CategoriaCreateNestedManyWithoutSubCategoriaInput = {
    create?: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput> | CategoriaCreateWithoutSubCategoriaInput[] | CategoriaUncheckedCreateWithoutSubCategoriaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutSubCategoriaInput | CategoriaCreateOrConnectWithoutSubCategoriaInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type ProductoUncheckedCreateNestedManyWithoutSubCategoriasInput = {
    create?: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput> | ProductoCreateWithoutSubCategoriasInput[] | ProductoUncheckedCreateWithoutSubCategoriasInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutSubCategoriasInput | ProductoCreateOrConnectWithoutSubCategoriasInput[]
    createMany?: ProductoCreateManySubCategoriasInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type CategoriaUncheckedCreateNestedManyWithoutSubCategoriaInput = {
    create?: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput> | CategoriaCreateWithoutSubCategoriaInput[] | CategoriaUncheckedCreateWithoutSubCategoriaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutSubCategoriaInput | CategoriaCreateOrConnectWithoutSubCategoriaInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type ProductoUpdateManyWithoutSubCategoriasNestedInput = {
    create?: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput> | ProductoCreateWithoutSubCategoriasInput[] | ProductoUncheckedCreateWithoutSubCategoriasInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutSubCategoriasInput | ProductoCreateOrConnectWithoutSubCategoriasInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput | ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput[]
    createMany?: ProductoCreateManySubCategoriasInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput | ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutSubCategoriasInput | ProductoUpdateManyWithWhereWithoutSubCategoriasInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type CategoriaUpdateManyWithoutSubCategoriaNestedInput = {
    create?: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput> | CategoriaCreateWithoutSubCategoriaInput[] | CategoriaUncheckedCreateWithoutSubCategoriaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutSubCategoriaInput | CategoriaCreateOrConnectWithoutSubCategoriaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput | CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput[]
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput | CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutSubCategoriaInput | CategoriaUpdateManyWithWhereWithoutSubCategoriaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type ProductoUncheckedUpdateManyWithoutSubCategoriasNestedInput = {
    create?: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput> | ProductoCreateWithoutSubCategoriasInput[] | ProductoUncheckedCreateWithoutSubCategoriasInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutSubCategoriasInput | ProductoCreateOrConnectWithoutSubCategoriasInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput | ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput[]
    createMany?: ProductoCreateManySubCategoriasInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput | ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutSubCategoriasInput | ProductoUpdateManyWithWhereWithoutSubCategoriasInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type CategoriaUncheckedUpdateManyWithoutSubCategoriaNestedInput = {
    create?: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput> | CategoriaCreateWithoutSubCategoriaInput[] | CategoriaUncheckedCreateWithoutSubCategoriaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutSubCategoriaInput | CategoriaCreateOrConnectWithoutSubCategoriaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput | CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput[]
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput | CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutSubCategoriaInput | CategoriaUpdateManyWithWhereWithoutSubCategoriaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type SubCategoriaCreateNestedOneWithoutProductoInput = {
    create?: XOR<SubCategoriaCreateWithoutProductoInput, SubCategoriaUncheckedCreateWithoutProductoInput>
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutProductoInput
    connect?: SubCategoriaWhereUniqueInput
  }

  export type FotoCreateNestedManyWithoutProductosInput = {
    create?: XOR<FotoCreateWithoutProductosInput, FotoUncheckedCreateWithoutProductosInput> | FotoCreateWithoutProductosInput[] | FotoUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: FotoCreateOrConnectWithoutProductosInput | FotoCreateOrConnectWithoutProductosInput[]
    createMany?: FotoCreateManyProductosInputEnvelope
    connect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
  }

  export type BodegaProductosCreateNestedManyWithoutProductoInput = {
    create?: XOR<BodegaProductosCreateWithoutProductoInput, BodegaProductosUncheckedCreateWithoutProductoInput> | BodegaProductosCreateWithoutProductoInput[] | BodegaProductosUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutProductoInput | BodegaProductosCreateOrConnectWithoutProductoInput[]
    createMany?: BodegaProductosCreateManyProductoInputEnvelope
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
  }

  export type DetalleCompraCreateNestedManyWithoutProductosInput = {
    create?: XOR<DetalleCompraCreateWithoutProductosInput, DetalleCompraUncheckedCreateWithoutProductosInput> | DetalleCompraCreateWithoutProductosInput[] | DetalleCompraUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutProductosInput | DetalleCompraCreateOrConnectWithoutProductosInput[]
    createMany?: DetalleCompraCreateManyProductosInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type HistorialCreateNestedManyWithoutProductosInput = {
    create?: XOR<HistorialCreateWithoutProductosInput, HistorialUncheckedCreateWithoutProductosInput> | HistorialCreateWithoutProductosInput[] | HistorialUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutProductosInput | HistorialCreateOrConnectWithoutProductosInput[]
    createMany?: HistorialCreateManyProductosInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type FotoUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<FotoCreateWithoutProductosInput, FotoUncheckedCreateWithoutProductosInput> | FotoCreateWithoutProductosInput[] | FotoUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: FotoCreateOrConnectWithoutProductosInput | FotoCreateOrConnectWithoutProductosInput[]
    createMany?: FotoCreateManyProductosInputEnvelope
    connect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
  }

  export type BodegaProductosUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<BodegaProductosCreateWithoutProductoInput, BodegaProductosUncheckedCreateWithoutProductoInput> | BodegaProductosCreateWithoutProductoInput[] | BodegaProductosUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutProductoInput | BodegaProductosCreateOrConnectWithoutProductoInput[]
    createMany?: BodegaProductosCreateManyProductoInputEnvelope
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
  }

  export type DetalleCompraUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<DetalleCompraCreateWithoutProductosInput, DetalleCompraUncheckedCreateWithoutProductosInput> | DetalleCompraCreateWithoutProductosInput[] | DetalleCompraUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutProductosInput | DetalleCompraCreateOrConnectWithoutProductosInput[]
    createMany?: DetalleCompraCreateManyProductosInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type HistorialUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<HistorialCreateWithoutProductosInput, HistorialUncheckedCreateWithoutProductosInput> | HistorialCreateWithoutProductosInput[] | HistorialUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutProductosInput | HistorialCreateOrConnectWithoutProductosInput[]
    createMany?: HistorialCreateManyProductosInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SubCategoriaUpdateOneRequiredWithoutProductoNestedInput = {
    create?: XOR<SubCategoriaCreateWithoutProductoInput, SubCategoriaUncheckedCreateWithoutProductoInput>
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutProductoInput
    upsert?: SubCategoriaUpsertWithoutProductoInput
    connect?: SubCategoriaWhereUniqueInput
    update?: XOR<XOR<SubCategoriaUpdateToOneWithWhereWithoutProductoInput, SubCategoriaUpdateWithoutProductoInput>, SubCategoriaUncheckedUpdateWithoutProductoInput>
  }

  export type FotoUpdateManyWithoutProductosNestedInput = {
    create?: XOR<FotoCreateWithoutProductosInput, FotoUncheckedCreateWithoutProductosInput> | FotoCreateWithoutProductosInput[] | FotoUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: FotoCreateOrConnectWithoutProductosInput | FotoCreateOrConnectWithoutProductosInput[]
    upsert?: FotoUpsertWithWhereUniqueWithoutProductosInput | FotoUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: FotoCreateManyProductosInputEnvelope
    set?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    disconnect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    delete?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    connect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    update?: FotoUpdateWithWhereUniqueWithoutProductosInput | FotoUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: FotoUpdateManyWithWhereWithoutProductosInput | FotoUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: FotoScalarWhereInput | FotoScalarWhereInput[]
  }

  export type BodegaProductosUpdateManyWithoutProductoNestedInput = {
    create?: XOR<BodegaProductosCreateWithoutProductoInput, BodegaProductosUncheckedCreateWithoutProductoInput> | BodegaProductosCreateWithoutProductoInput[] | BodegaProductosUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutProductoInput | BodegaProductosCreateOrConnectWithoutProductoInput[]
    upsert?: BodegaProductosUpsertWithWhereUniqueWithoutProductoInput | BodegaProductosUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: BodegaProductosCreateManyProductoInputEnvelope
    set?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    disconnect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    delete?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    update?: BodegaProductosUpdateWithWhereUniqueWithoutProductoInput | BodegaProductosUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: BodegaProductosUpdateManyWithWhereWithoutProductoInput | BodegaProductosUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: BodegaProductosScalarWhereInput | BodegaProductosScalarWhereInput[]
  }

  export type DetalleCompraUpdateManyWithoutProductosNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutProductosInput, DetalleCompraUncheckedCreateWithoutProductosInput> | DetalleCompraCreateWithoutProductosInput[] | DetalleCompraUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutProductosInput | DetalleCompraCreateOrConnectWithoutProductosInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutProductosInput | DetalleCompraUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: DetalleCompraCreateManyProductosInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutProductosInput | DetalleCompraUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutProductosInput | DetalleCompraUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type HistorialUpdateManyWithoutProductosNestedInput = {
    create?: XOR<HistorialCreateWithoutProductosInput, HistorialUncheckedCreateWithoutProductosInput> | HistorialCreateWithoutProductosInput[] | HistorialUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutProductosInput | HistorialCreateOrConnectWithoutProductosInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutProductosInput | HistorialUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: HistorialCreateManyProductosInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutProductosInput | HistorialUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutProductosInput | HistorialUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type FotoUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<FotoCreateWithoutProductosInput, FotoUncheckedCreateWithoutProductosInput> | FotoCreateWithoutProductosInput[] | FotoUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: FotoCreateOrConnectWithoutProductosInput | FotoCreateOrConnectWithoutProductosInput[]
    upsert?: FotoUpsertWithWhereUniqueWithoutProductosInput | FotoUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: FotoCreateManyProductosInputEnvelope
    set?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    disconnect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    delete?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    connect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    update?: FotoUpdateWithWhereUniqueWithoutProductosInput | FotoUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: FotoUpdateManyWithWhereWithoutProductosInput | FotoUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: FotoScalarWhereInput | FotoScalarWhereInput[]
  }

  export type BodegaProductosUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<BodegaProductosCreateWithoutProductoInput, BodegaProductosUncheckedCreateWithoutProductoInput> | BodegaProductosCreateWithoutProductoInput[] | BodegaProductosUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutProductoInput | BodegaProductosCreateOrConnectWithoutProductoInput[]
    upsert?: BodegaProductosUpsertWithWhereUniqueWithoutProductoInput | BodegaProductosUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: BodegaProductosCreateManyProductoInputEnvelope
    set?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    disconnect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    delete?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    update?: BodegaProductosUpdateWithWhereUniqueWithoutProductoInput | BodegaProductosUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: BodegaProductosUpdateManyWithWhereWithoutProductoInput | BodegaProductosUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: BodegaProductosScalarWhereInput | BodegaProductosScalarWhereInput[]
  }

  export type DetalleCompraUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutProductosInput, DetalleCompraUncheckedCreateWithoutProductosInput> | DetalleCompraCreateWithoutProductosInput[] | DetalleCompraUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutProductosInput | DetalleCompraCreateOrConnectWithoutProductosInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutProductosInput | DetalleCompraUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: DetalleCompraCreateManyProductosInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutProductosInput | DetalleCompraUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutProductosInput | DetalleCompraUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type HistorialUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<HistorialCreateWithoutProductosInput, HistorialUncheckedCreateWithoutProductosInput> | HistorialCreateWithoutProductosInput[] | HistorialUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutProductosInput | HistorialCreateOrConnectWithoutProductosInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutProductosInput | HistorialUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: HistorialCreateManyProductosInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutProductosInput | HistorialUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutProductosInput | HistorialUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type ProductoCreateNestedOneWithoutFotoInput = {
    create?: XOR<ProductoCreateWithoutFotoInput, ProductoUncheckedCreateWithoutFotoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutFotoInput
    connect?: ProductoWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type ProductoUpdateOneRequiredWithoutFotoNestedInput = {
    create?: XOR<ProductoCreateWithoutFotoInput, ProductoUncheckedCreateWithoutFotoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutFotoInput
    upsert?: ProductoUpsertWithoutFotoInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutFotoInput, ProductoUpdateWithoutFotoInput>, ProductoUncheckedUpdateWithoutFotoInput>
  }

  export type UsuarioCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<UsuarioCreateWithoutUbicacionInput, UsuarioUncheckedCreateWithoutUbicacionInput> | UsuarioCreateWithoutUbicacionInput[] | UsuarioUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutUbicacionInput | UsuarioCreateOrConnectWithoutUbicacionInput[]
    createMany?: UsuarioCreateManyUbicacionInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type BodegaCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput> | BodegaCreateWithoutUbicacionInput[] | BodegaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BodegaCreateOrConnectWithoutUbicacionInput | BodegaCreateOrConnectWithoutUbicacionInput[]
    createMany?: BodegaCreateManyUbicacionInputEnvelope
    connect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
  }

  export type ProvinciaCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<ProvinciaCreateWithoutUbicacionInput, ProvinciaUncheckedCreateWithoutUbicacionInput> | ProvinciaCreateWithoutUbicacionInput[] | ProvinciaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: ProvinciaCreateOrConnectWithoutUbicacionInput | ProvinciaCreateOrConnectWithoutUbicacionInput[]
    createMany?: ProvinciaCreateManyUbicacionInputEnvelope
    connect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
  }

  export type CantonCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<CantonCreateWithoutUbicacionInput, CantonUncheckedCreateWithoutUbicacionInput> | CantonCreateWithoutUbicacionInput[] | CantonUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: CantonCreateOrConnectWithoutUbicacionInput | CantonCreateOrConnectWithoutUbicacionInput[]
    createMany?: CantonCreateManyUbicacionInputEnvelope
    connect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
  }

  export type DistritoCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<DistritoCreateWithoutUbicacionInput, DistritoUncheckedCreateWithoutUbicacionInput> | DistritoCreateWithoutUbicacionInput[] | DistritoUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutUbicacionInput | DistritoCreateOrConnectWithoutUbicacionInput[]
    createMany?: DistritoCreateManyUbicacionInputEnvelope
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
  }

  export type BarrioCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<BarrioCreateWithoutUbicacionInput, BarrioUncheckedCreateWithoutUbicacionInput> | BarrioCreateWithoutUbicacionInput[] | BarrioUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutUbicacionInput | BarrioCreateOrConnectWithoutUbicacionInput[]
    createMany?: BarrioCreateManyUbicacionInputEnvelope
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<UsuarioCreateWithoutUbicacionInput, UsuarioUncheckedCreateWithoutUbicacionInput> | UsuarioCreateWithoutUbicacionInput[] | UsuarioUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutUbicacionInput | UsuarioCreateOrConnectWithoutUbicacionInput[]
    createMany?: UsuarioCreateManyUbicacionInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type BodegaUncheckedCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput> | BodegaCreateWithoutUbicacionInput[] | BodegaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BodegaCreateOrConnectWithoutUbicacionInput | BodegaCreateOrConnectWithoutUbicacionInput[]
    createMany?: BodegaCreateManyUbicacionInputEnvelope
    connect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
  }

  export type ProvinciaUncheckedCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<ProvinciaCreateWithoutUbicacionInput, ProvinciaUncheckedCreateWithoutUbicacionInput> | ProvinciaCreateWithoutUbicacionInput[] | ProvinciaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: ProvinciaCreateOrConnectWithoutUbicacionInput | ProvinciaCreateOrConnectWithoutUbicacionInput[]
    createMany?: ProvinciaCreateManyUbicacionInputEnvelope
    connect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
  }

  export type CantonUncheckedCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<CantonCreateWithoutUbicacionInput, CantonUncheckedCreateWithoutUbicacionInput> | CantonCreateWithoutUbicacionInput[] | CantonUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: CantonCreateOrConnectWithoutUbicacionInput | CantonCreateOrConnectWithoutUbicacionInput[]
    createMany?: CantonCreateManyUbicacionInputEnvelope
    connect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
  }

  export type DistritoUncheckedCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<DistritoCreateWithoutUbicacionInput, DistritoUncheckedCreateWithoutUbicacionInput> | DistritoCreateWithoutUbicacionInput[] | DistritoUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutUbicacionInput | DistritoCreateOrConnectWithoutUbicacionInput[]
    createMany?: DistritoCreateManyUbicacionInputEnvelope
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
  }

  export type BarrioUncheckedCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<BarrioCreateWithoutUbicacionInput, BarrioUncheckedCreateWithoutUbicacionInput> | BarrioCreateWithoutUbicacionInput[] | BarrioUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutUbicacionInput | BarrioCreateOrConnectWithoutUbicacionInput[]
    createMany?: BarrioCreateManyUbicacionInputEnvelope
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
  }

  export type UsuarioUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<UsuarioCreateWithoutUbicacionInput, UsuarioUncheckedCreateWithoutUbicacionInput> | UsuarioCreateWithoutUbicacionInput[] | UsuarioUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutUbicacionInput | UsuarioCreateOrConnectWithoutUbicacionInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutUbicacionInput | UsuarioUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: UsuarioCreateManyUbicacionInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutUbicacionInput | UsuarioUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutUbicacionInput | UsuarioUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type BodegaUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput> | BodegaCreateWithoutUbicacionInput[] | BodegaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BodegaCreateOrConnectWithoutUbicacionInput | BodegaCreateOrConnectWithoutUbicacionInput[]
    upsert?: BodegaUpsertWithWhereUniqueWithoutUbicacionInput | BodegaUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: BodegaCreateManyUbicacionInputEnvelope
    set?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    disconnect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    delete?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    connect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    update?: BodegaUpdateWithWhereUniqueWithoutUbicacionInput | BodegaUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: BodegaUpdateManyWithWhereWithoutUbicacionInput | BodegaUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: BodegaScalarWhereInput | BodegaScalarWhereInput[]
  }

  export type ProvinciaUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<ProvinciaCreateWithoutUbicacionInput, ProvinciaUncheckedCreateWithoutUbicacionInput> | ProvinciaCreateWithoutUbicacionInput[] | ProvinciaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: ProvinciaCreateOrConnectWithoutUbicacionInput | ProvinciaCreateOrConnectWithoutUbicacionInput[]
    upsert?: ProvinciaUpsertWithWhereUniqueWithoutUbicacionInput | ProvinciaUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: ProvinciaCreateManyUbicacionInputEnvelope
    set?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    disconnect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    delete?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    connect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    update?: ProvinciaUpdateWithWhereUniqueWithoutUbicacionInput | ProvinciaUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: ProvinciaUpdateManyWithWhereWithoutUbicacionInput | ProvinciaUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: ProvinciaScalarWhereInput | ProvinciaScalarWhereInput[]
  }

  export type CantonUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<CantonCreateWithoutUbicacionInput, CantonUncheckedCreateWithoutUbicacionInput> | CantonCreateWithoutUbicacionInput[] | CantonUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: CantonCreateOrConnectWithoutUbicacionInput | CantonCreateOrConnectWithoutUbicacionInput[]
    upsert?: CantonUpsertWithWhereUniqueWithoutUbicacionInput | CantonUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: CantonCreateManyUbicacionInputEnvelope
    set?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    disconnect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    delete?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    connect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    update?: CantonUpdateWithWhereUniqueWithoutUbicacionInput | CantonUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: CantonUpdateManyWithWhereWithoutUbicacionInput | CantonUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: CantonScalarWhereInput | CantonScalarWhereInput[]
  }

  export type DistritoUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<DistritoCreateWithoutUbicacionInput, DistritoUncheckedCreateWithoutUbicacionInput> | DistritoCreateWithoutUbicacionInput[] | DistritoUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutUbicacionInput | DistritoCreateOrConnectWithoutUbicacionInput[]
    upsert?: DistritoUpsertWithWhereUniqueWithoutUbicacionInput | DistritoUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: DistritoCreateManyUbicacionInputEnvelope
    set?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    disconnect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    delete?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    update?: DistritoUpdateWithWhereUniqueWithoutUbicacionInput | DistritoUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: DistritoUpdateManyWithWhereWithoutUbicacionInput | DistritoUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
  }

  export type BarrioUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<BarrioCreateWithoutUbicacionInput, BarrioUncheckedCreateWithoutUbicacionInput> | BarrioCreateWithoutUbicacionInput[] | BarrioUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutUbicacionInput | BarrioCreateOrConnectWithoutUbicacionInput[]
    upsert?: BarrioUpsertWithWhereUniqueWithoutUbicacionInput | BarrioUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: BarrioCreateManyUbicacionInputEnvelope
    set?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    disconnect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    delete?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    update?: BarrioUpdateWithWhereUniqueWithoutUbicacionInput | BarrioUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: BarrioUpdateManyWithWhereWithoutUbicacionInput | BarrioUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<UsuarioCreateWithoutUbicacionInput, UsuarioUncheckedCreateWithoutUbicacionInput> | UsuarioCreateWithoutUbicacionInput[] | UsuarioUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutUbicacionInput | UsuarioCreateOrConnectWithoutUbicacionInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutUbicacionInput | UsuarioUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: UsuarioCreateManyUbicacionInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutUbicacionInput | UsuarioUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutUbicacionInput | UsuarioUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type BodegaUncheckedUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput> | BodegaCreateWithoutUbicacionInput[] | BodegaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BodegaCreateOrConnectWithoutUbicacionInput | BodegaCreateOrConnectWithoutUbicacionInput[]
    upsert?: BodegaUpsertWithWhereUniqueWithoutUbicacionInput | BodegaUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: BodegaCreateManyUbicacionInputEnvelope
    set?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    disconnect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    delete?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    connect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    update?: BodegaUpdateWithWhereUniqueWithoutUbicacionInput | BodegaUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: BodegaUpdateManyWithWhereWithoutUbicacionInput | BodegaUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: BodegaScalarWhereInput | BodegaScalarWhereInput[]
  }

  export type ProvinciaUncheckedUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<ProvinciaCreateWithoutUbicacionInput, ProvinciaUncheckedCreateWithoutUbicacionInput> | ProvinciaCreateWithoutUbicacionInput[] | ProvinciaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: ProvinciaCreateOrConnectWithoutUbicacionInput | ProvinciaCreateOrConnectWithoutUbicacionInput[]
    upsert?: ProvinciaUpsertWithWhereUniqueWithoutUbicacionInput | ProvinciaUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: ProvinciaCreateManyUbicacionInputEnvelope
    set?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    disconnect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    delete?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    connect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    update?: ProvinciaUpdateWithWhereUniqueWithoutUbicacionInput | ProvinciaUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: ProvinciaUpdateManyWithWhereWithoutUbicacionInput | ProvinciaUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: ProvinciaScalarWhereInput | ProvinciaScalarWhereInput[]
  }

  export type CantonUncheckedUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<CantonCreateWithoutUbicacionInput, CantonUncheckedCreateWithoutUbicacionInput> | CantonCreateWithoutUbicacionInput[] | CantonUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: CantonCreateOrConnectWithoutUbicacionInput | CantonCreateOrConnectWithoutUbicacionInput[]
    upsert?: CantonUpsertWithWhereUniqueWithoutUbicacionInput | CantonUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: CantonCreateManyUbicacionInputEnvelope
    set?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    disconnect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    delete?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    connect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    update?: CantonUpdateWithWhereUniqueWithoutUbicacionInput | CantonUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: CantonUpdateManyWithWhereWithoutUbicacionInput | CantonUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: CantonScalarWhereInput | CantonScalarWhereInput[]
  }

  export type DistritoUncheckedUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<DistritoCreateWithoutUbicacionInput, DistritoUncheckedCreateWithoutUbicacionInput> | DistritoCreateWithoutUbicacionInput[] | DistritoUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutUbicacionInput | DistritoCreateOrConnectWithoutUbicacionInput[]
    upsert?: DistritoUpsertWithWhereUniqueWithoutUbicacionInput | DistritoUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: DistritoCreateManyUbicacionInputEnvelope
    set?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    disconnect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    delete?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    update?: DistritoUpdateWithWhereUniqueWithoutUbicacionInput | DistritoUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: DistritoUpdateManyWithWhereWithoutUbicacionInput | DistritoUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
  }

  export type BarrioUncheckedUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<BarrioCreateWithoutUbicacionInput, BarrioUncheckedCreateWithoutUbicacionInput> | BarrioCreateWithoutUbicacionInput[] | BarrioUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutUbicacionInput | BarrioCreateOrConnectWithoutUbicacionInput[]
    upsert?: BarrioUpsertWithWhereUniqueWithoutUbicacionInput | BarrioUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: BarrioCreateManyUbicacionInputEnvelope
    set?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    disconnect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    delete?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    update?: BarrioUpdateWithWhereUniqueWithoutUbicacionInput | BarrioUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: BarrioUpdateManyWithWhereWithoutUbicacionInput | BarrioUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
  }

  export type CantonCreateNestedManyWithoutProvinciasInput = {
    create?: XOR<CantonCreateWithoutProvinciasInput, CantonUncheckedCreateWithoutProvinciasInput> | CantonCreateWithoutProvinciasInput[] | CantonUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: CantonCreateOrConnectWithoutProvinciasInput | CantonCreateOrConnectWithoutProvinciasInput[]
    createMany?: CantonCreateManyProvinciasInputEnvelope
    connect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
  }

  export type DistritoCreateNestedManyWithoutProvinciasInput = {
    create?: XOR<DistritoCreateWithoutProvinciasInput, DistritoUncheckedCreateWithoutProvinciasInput> | DistritoCreateWithoutProvinciasInput[] | DistritoUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutProvinciasInput | DistritoCreateOrConnectWithoutProvinciasInput[]
    createMany?: DistritoCreateManyProvinciasInputEnvelope
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
  }

  export type BarrioCreateNestedManyWithoutProvinciasInput = {
    create?: XOR<BarrioCreateWithoutProvinciasInput, BarrioUncheckedCreateWithoutProvinciasInput> | BarrioCreateWithoutProvinciasInput[] | BarrioUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutProvinciasInput | BarrioCreateOrConnectWithoutProvinciasInput[]
    createMany?: BarrioCreateManyProvinciasInputEnvelope
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
  }

  export type UbicacionCreateNestedOneWithoutProvinciaInput = {
    create?: XOR<UbicacionCreateWithoutProvinciaInput, UbicacionUncheckedCreateWithoutProvinciaInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutProvinciaInput
    connect?: UbicacionWhereUniqueInput
  }

  export type CantonUncheckedCreateNestedManyWithoutProvinciasInput = {
    create?: XOR<CantonCreateWithoutProvinciasInput, CantonUncheckedCreateWithoutProvinciasInput> | CantonCreateWithoutProvinciasInput[] | CantonUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: CantonCreateOrConnectWithoutProvinciasInput | CantonCreateOrConnectWithoutProvinciasInput[]
    createMany?: CantonCreateManyProvinciasInputEnvelope
    connect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
  }

  export type DistritoUncheckedCreateNestedManyWithoutProvinciasInput = {
    create?: XOR<DistritoCreateWithoutProvinciasInput, DistritoUncheckedCreateWithoutProvinciasInput> | DistritoCreateWithoutProvinciasInput[] | DistritoUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutProvinciasInput | DistritoCreateOrConnectWithoutProvinciasInput[]
    createMany?: DistritoCreateManyProvinciasInputEnvelope
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
  }

  export type BarrioUncheckedCreateNestedManyWithoutProvinciasInput = {
    create?: XOR<BarrioCreateWithoutProvinciasInput, BarrioUncheckedCreateWithoutProvinciasInput> | BarrioCreateWithoutProvinciasInput[] | BarrioUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutProvinciasInput | BarrioCreateOrConnectWithoutProvinciasInput[]
    createMany?: BarrioCreateManyProvinciasInputEnvelope
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
  }

  export type CantonUpdateManyWithoutProvinciasNestedInput = {
    create?: XOR<CantonCreateWithoutProvinciasInput, CantonUncheckedCreateWithoutProvinciasInput> | CantonCreateWithoutProvinciasInput[] | CantonUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: CantonCreateOrConnectWithoutProvinciasInput | CantonCreateOrConnectWithoutProvinciasInput[]
    upsert?: CantonUpsertWithWhereUniqueWithoutProvinciasInput | CantonUpsertWithWhereUniqueWithoutProvinciasInput[]
    createMany?: CantonCreateManyProvinciasInputEnvelope
    set?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    disconnect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    delete?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    connect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    update?: CantonUpdateWithWhereUniqueWithoutProvinciasInput | CantonUpdateWithWhereUniqueWithoutProvinciasInput[]
    updateMany?: CantonUpdateManyWithWhereWithoutProvinciasInput | CantonUpdateManyWithWhereWithoutProvinciasInput[]
    deleteMany?: CantonScalarWhereInput | CantonScalarWhereInput[]
  }

  export type DistritoUpdateManyWithoutProvinciasNestedInput = {
    create?: XOR<DistritoCreateWithoutProvinciasInput, DistritoUncheckedCreateWithoutProvinciasInput> | DistritoCreateWithoutProvinciasInput[] | DistritoUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutProvinciasInput | DistritoCreateOrConnectWithoutProvinciasInput[]
    upsert?: DistritoUpsertWithWhereUniqueWithoutProvinciasInput | DistritoUpsertWithWhereUniqueWithoutProvinciasInput[]
    createMany?: DistritoCreateManyProvinciasInputEnvelope
    set?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    disconnect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    delete?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    update?: DistritoUpdateWithWhereUniqueWithoutProvinciasInput | DistritoUpdateWithWhereUniqueWithoutProvinciasInput[]
    updateMany?: DistritoUpdateManyWithWhereWithoutProvinciasInput | DistritoUpdateManyWithWhereWithoutProvinciasInput[]
    deleteMany?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
  }

  export type BarrioUpdateManyWithoutProvinciasNestedInput = {
    create?: XOR<BarrioCreateWithoutProvinciasInput, BarrioUncheckedCreateWithoutProvinciasInput> | BarrioCreateWithoutProvinciasInput[] | BarrioUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutProvinciasInput | BarrioCreateOrConnectWithoutProvinciasInput[]
    upsert?: BarrioUpsertWithWhereUniqueWithoutProvinciasInput | BarrioUpsertWithWhereUniqueWithoutProvinciasInput[]
    createMany?: BarrioCreateManyProvinciasInputEnvelope
    set?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    disconnect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    delete?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    update?: BarrioUpdateWithWhereUniqueWithoutProvinciasInput | BarrioUpdateWithWhereUniqueWithoutProvinciasInput[]
    updateMany?: BarrioUpdateManyWithWhereWithoutProvinciasInput | BarrioUpdateManyWithWhereWithoutProvinciasInput[]
    deleteMany?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
  }

  export type UbicacionUpdateOneRequiredWithoutProvinciaNestedInput = {
    create?: XOR<UbicacionCreateWithoutProvinciaInput, UbicacionUncheckedCreateWithoutProvinciaInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutProvinciaInput
    upsert?: UbicacionUpsertWithoutProvinciaInput
    connect?: UbicacionWhereUniqueInput
    update?: XOR<XOR<UbicacionUpdateToOneWithWhereWithoutProvinciaInput, UbicacionUpdateWithoutProvinciaInput>, UbicacionUncheckedUpdateWithoutProvinciaInput>
  }

  export type CantonUncheckedUpdateManyWithoutProvinciasNestedInput = {
    create?: XOR<CantonCreateWithoutProvinciasInput, CantonUncheckedCreateWithoutProvinciasInput> | CantonCreateWithoutProvinciasInput[] | CantonUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: CantonCreateOrConnectWithoutProvinciasInput | CantonCreateOrConnectWithoutProvinciasInput[]
    upsert?: CantonUpsertWithWhereUniqueWithoutProvinciasInput | CantonUpsertWithWhereUniqueWithoutProvinciasInput[]
    createMany?: CantonCreateManyProvinciasInputEnvelope
    set?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    disconnect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    delete?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    connect?: CantonWhereUniqueInput | CantonWhereUniqueInput[]
    update?: CantonUpdateWithWhereUniqueWithoutProvinciasInput | CantonUpdateWithWhereUniqueWithoutProvinciasInput[]
    updateMany?: CantonUpdateManyWithWhereWithoutProvinciasInput | CantonUpdateManyWithWhereWithoutProvinciasInput[]
    deleteMany?: CantonScalarWhereInput | CantonScalarWhereInput[]
  }

  export type DistritoUncheckedUpdateManyWithoutProvinciasNestedInput = {
    create?: XOR<DistritoCreateWithoutProvinciasInput, DistritoUncheckedCreateWithoutProvinciasInput> | DistritoCreateWithoutProvinciasInput[] | DistritoUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutProvinciasInput | DistritoCreateOrConnectWithoutProvinciasInput[]
    upsert?: DistritoUpsertWithWhereUniqueWithoutProvinciasInput | DistritoUpsertWithWhereUniqueWithoutProvinciasInput[]
    createMany?: DistritoCreateManyProvinciasInputEnvelope
    set?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    disconnect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    delete?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    update?: DistritoUpdateWithWhereUniqueWithoutProvinciasInput | DistritoUpdateWithWhereUniqueWithoutProvinciasInput[]
    updateMany?: DistritoUpdateManyWithWhereWithoutProvinciasInput | DistritoUpdateManyWithWhereWithoutProvinciasInput[]
    deleteMany?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
  }

  export type BarrioUncheckedUpdateManyWithoutProvinciasNestedInput = {
    create?: XOR<BarrioCreateWithoutProvinciasInput, BarrioUncheckedCreateWithoutProvinciasInput> | BarrioCreateWithoutProvinciasInput[] | BarrioUncheckedCreateWithoutProvinciasInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutProvinciasInput | BarrioCreateOrConnectWithoutProvinciasInput[]
    upsert?: BarrioUpsertWithWhereUniqueWithoutProvinciasInput | BarrioUpsertWithWhereUniqueWithoutProvinciasInput[]
    createMany?: BarrioCreateManyProvinciasInputEnvelope
    set?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    disconnect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    delete?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    update?: BarrioUpdateWithWhereUniqueWithoutProvinciasInput | BarrioUpdateWithWhereUniqueWithoutProvinciasInput[]
    updateMany?: BarrioUpdateManyWithWhereWithoutProvinciasInput | BarrioUpdateManyWithWhereWithoutProvinciasInput[]
    deleteMany?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
  }

  export type ProvinciaCreateNestedOneWithoutCantonesInput = {
    create?: XOR<ProvinciaCreateWithoutCantonesInput, ProvinciaUncheckedCreateWithoutCantonesInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutCantonesInput
    connect?: ProvinciaWhereUniqueInput
  }

  export type UbicacionCreateNestedOneWithoutCantonesInput = {
    create?: XOR<UbicacionCreateWithoutCantonesInput, UbicacionUncheckedCreateWithoutCantonesInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutCantonesInput
    connect?: UbicacionWhereUniqueInput
  }

  export type DistritoCreateNestedManyWithoutCantonesInput = {
    create?: XOR<DistritoCreateWithoutCantonesInput, DistritoUncheckedCreateWithoutCantonesInput> | DistritoCreateWithoutCantonesInput[] | DistritoUncheckedCreateWithoutCantonesInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutCantonesInput | DistritoCreateOrConnectWithoutCantonesInput[]
    createMany?: DistritoCreateManyCantonesInputEnvelope
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
  }

  export type BarrioCreateNestedManyWithoutCantonesInput = {
    create?: XOR<BarrioCreateWithoutCantonesInput, BarrioUncheckedCreateWithoutCantonesInput> | BarrioCreateWithoutCantonesInput[] | BarrioUncheckedCreateWithoutCantonesInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutCantonesInput | BarrioCreateOrConnectWithoutCantonesInput[]
    createMany?: BarrioCreateManyCantonesInputEnvelope
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
  }

  export type DistritoUncheckedCreateNestedManyWithoutCantonesInput = {
    create?: XOR<DistritoCreateWithoutCantonesInput, DistritoUncheckedCreateWithoutCantonesInput> | DistritoCreateWithoutCantonesInput[] | DistritoUncheckedCreateWithoutCantonesInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutCantonesInput | DistritoCreateOrConnectWithoutCantonesInput[]
    createMany?: DistritoCreateManyCantonesInputEnvelope
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
  }

  export type BarrioUncheckedCreateNestedManyWithoutCantonesInput = {
    create?: XOR<BarrioCreateWithoutCantonesInput, BarrioUncheckedCreateWithoutCantonesInput> | BarrioCreateWithoutCantonesInput[] | BarrioUncheckedCreateWithoutCantonesInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutCantonesInput | BarrioCreateOrConnectWithoutCantonesInput[]
    createMany?: BarrioCreateManyCantonesInputEnvelope
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
  }

  export type ProvinciaUpdateOneRequiredWithoutCantonesNestedInput = {
    create?: XOR<ProvinciaCreateWithoutCantonesInput, ProvinciaUncheckedCreateWithoutCantonesInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutCantonesInput
    upsert?: ProvinciaUpsertWithoutCantonesInput
    connect?: ProvinciaWhereUniqueInput
    update?: XOR<XOR<ProvinciaUpdateToOneWithWhereWithoutCantonesInput, ProvinciaUpdateWithoutCantonesInput>, ProvinciaUncheckedUpdateWithoutCantonesInput>
  }

  export type UbicacionUpdateOneRequiredWithoutCantonesNestedInput = {
    create?: XOR<UbicacionCreateWithoutCantonesInput, UbicacionUncheckedCreateWithoutCantonesInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutCantonesInput
    upsert?: UbicacionUpsertWithoutCantonesInput
    connect?: UbicacionWhereUniqueInput
    update?: XOR<XOR<UbicacionUpdateToOneWithWhereWithoutCantonesInput, UbicacionUpdateWithoutCantonesInput>, UbicacionUncheckedUpdateWithoutCantonesInput>
  }

  export type DistritoUpdateManyWithoutCantonesNestedInput = {
    create?: XOR<DistritoCreateWithoutCantonesInput, DistritoUncheckedCreateWithoutCantonesInput> | DistritoCreateWithoutCantonesInput[] | DistritoUncheckedCreateWithoutCantonesInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutCantonesInput | DistritoCreateOrConnectWithoutCantonesInput[]
    upsert?: DistritoUpsertWithWhereUniqueWithoutCantonesInput | DistritoUpsertWithWhereUniqueWithoutCantonesInput[]
    createMany?: DistritoCreateManyCantonesInputEnvelope
    set?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    disconnect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    delete?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    update?: DistritoUpdateWithWhereUniqueWithoutCantonesInput | DistritoUpdateWithWhereUniqueWithoutCantonesInput[]
    updateMany?: DistritoUpdateManyWithWhereWithoutCantonesInput | DistritoUpdateManyWithWhereWithoutCantonesInput[]
    deleteMany?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
  }

  export type BarrioUpdateManyWithoutCantonesNestedInput = {
    create?: XOR<BarrioCreateWithoutCantonesInput, BarrioUncheckedCreateWithoutCantonesInput> | BarrioCreateWithoutCantonesInput[] | BarrioUncheckedCreateWithoutCantonesInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutCantonesInput | BarrioCreateOrConnectWithoutCantonesInput[]
    upsert?: BarrioUpsertWithWhereUniqueWithoutCantonesInput | BarrioUpsertWithWhereUniqueWithoutCantonesInput[]
    createMany?: BarrioCreateManyCantonesInputEnvelope
    set?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    disconnect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    delete?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    update?: BarrioUpdateWithWhereUniqueWithoutCantonesInput | BarrioUpdateWithWhereUniqueWithoutCantonesInput[]
    updateMany?: BarrioUpdateManyWithWhereWithoutCantonesInput | BarrioUpdateManyWithWhereWithoutCantonesInput[]
    deleteMany?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
  }

  export type DistritoUncheckedUpdateManyWithoutCantonesNestedInput = {
    create?: XOR<DistritoCreateWithoutCantonesInput, DistritoUncheckedCreateWithoutCantonesInput> | DistritoCreateWithoutCantonesInput[] | DistritoUncheckedCreateWithoutCantonesInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutCantonesInput | DistritoCreateOrConnectWithoutCantonesInput[]
    upsert?: DistritoUpsertWithWhereUniqueWithoutCantonesInput | DistritoUpsertWithWhereUniqueWithoutCantonesInput[]
    createMany?: DistritoCreateManyCantonesInputEnvelope
    set?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    disconnect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    delete?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    update?: DistritoUpdateWithWhereUniqueWithoutCantonesInput | DistritoUpdateWithWhereUniqueWithoutCantonesInput[]
    updateMany?: DistritoUpdateManyWithWhereWithoutCantonesInput | DistritoUpdateManyWithWhereWithoutCantonesInput[]
    deleteMany?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
  }

  export type BarrioUncheckedUpdateManyWithoutCantonesNestedInput = {
    create?: XOR<BarrioCreateWithoutCantonesInput, BarrioUncheckedCreateWithoutCantonesInput> | BarrioCreateWithoutCantonesInput[] | BarrioUncheckedCreateWithoutCantonesInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutCantonesInput | BarrioCreateOrConnectWithoutCantonesInput[]
    upsert?: BarrioUpsertWithWhereUniqueWithoutCantonesInput | BarrioUpsertWithWhereUniqueWithoutCantonesInput[]
    createMany?: BarrioCreateManyCantonesInputEnvelope
    set?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    disconnect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    delete?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    update?: BarrioUpdateWithWhereUniqueWithoutCantonesInput | BarrioUpdateWithWhereUniqueWithoutCantonesInput[]
    updateMany?: BarrioUpdateManyWithWhereWithoutCantonesInput | BarrioUpdateManyWithWhereWithoutCantonesInput[]
    deleteMany?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
  }

  export type ProvinciaCreateNestedOneWithoutDistritosInput = {
    create?: XOR<ProvinciaCreateWithoutDistritosInput, ProvinciaUncheckedCreateWithoutDistritosInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutDistritosInput
    connect?: ProvinciaWhereUniqueInput
  }

  export type CantonCreateNestedOneWithoutDistritosInput = {
    create?: XOR<CantonCreateWithoutDistritosInput, CantonUncheckedCreateWithoutDistritosInput>
    connectOrCreate?: CantonCreateOrConnectWithoutDistritosInput
    connect?: CantonWhereUniqueInput
  }

  export type UbicacionCreateNestedOneWithoutDistritosInput = {
    create?: XOR<UbicacionCreateWithoutDistritosInput, UbicacionUncheckedCreateWithoutDistritosInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutDistritosInput
    connect?: UbicacionWhereUniqueInput
  }

  export type BarrioCreateNestedManyWithoutDistritosInput = {
    create?: XOR<BarrioCreateWithoutDistritosInput, BarrioUncheckedCreateWithoutDistritosInput> | BarrioCreateWithoutDistritosInput[] | BarrioUncheckedCreateWithoutDistritosInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutDistritosInput | BarrioCreateOrConnectWithoutDistritosInput[]
    createMany?: BarrioCreateManyDistritosInputEnvelope
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
  }

  export type BarrioUncheckedCreateNestedManyWithoutDistritosInput = {
    create?: XOR<BarrioCreateWithoutDistritosInput, BarrioUncheckedCreateWithoutDistritosInput> | BarrioCreateWithoutDistritosInput[] | BarrioUncheckedCreateWithoutDistritosInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutDistritosInput | BarrioCreateOrConnectWithoutDistritosInput[]
    createMany?: BarrioCreateManyDistritosInputEnvelope
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
  }

  export type ProvinciaUpdateOneRequiredWithoutDistritosNestedInput = {
    create?: XOR<ProvinciaCreateWithoutDistritosInput, ProvinciaUncheckedCreateWithoutDistritosInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutDistritosInput
    upsert?: ProvinciaUpsertWithoutDistritosInput
    connect?: ProvinciaWhereUniqueInput
    update?: XOR<XOR<ProvinciaUpdateToOneWithWhereWithoutDistritosInput, ProvinciaUpdateWithoutDistritosInput>, ProvinciaUncheckedUpdateWithoutDistritosInput>
  }

  export type CantonUpdateOneRequiredWithoutDistritosNestedInput = {
    create?: XOR<CantonCreateWithoutDistritosInput, CantonUncheckedCreateWithoutDistritosInput>
    connectOrCreate?: CantonCreateOrConnectWithoutDistritosInput
    upsert?: CantonUpsertWithoutDistritosInput
    connect?: CantonWhereUniqueInput
    update?: XOR<XOR<CantonUpdateToOneWithWhereWithoutDistritosInput, CantonUpdateWithoutDistritosInput>, CantonUncheckedUpdateWithoutDistritosInput>
  }

  export type UbicacionUpdateOneRequiredWithoutDistritosNestedInput = {
    create?: XOR<UbicacionCreateWithoutDistritosInput, UbicacionUncheckedCreateWithoutDistritosInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutDistritosInput
    upsert?: UbicacionUpsertWithoutDistritosInput
    connect?: UbicacionWhereUniqueInput
    update?: XOR<XOR<UbicacionUpdateToOneWithWhereWithoutDistritosInput, UbicacionUpdateWithoutDistritosInput>, UbicacionUncheckedUpdateWithoutDistritosInput>
  }

  export type BarrioUpdateManyWithoutDistritosNestedInput = {
    create?: XOR<BarrioCreateWithoutDistritosInput, BarrioUncheckedCreateWithoutDistritosInput> | BarrioCreateWithoutDistritosInput[] | BarrioUncheckedCreateWithoutDistritosInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutDistritosInput | BarrioCreateOrConnectWithoutDistritosInput[]
    upsert?: BarrioUpsertWithWhereUniqueWithoutDistritosInput | BarrioUpsertWithWhereUniqueWithoutDistritosInput[]
    createMany?: BarrioCreateManyDistritosInputEnvelope
    set?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    disconnect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    delete?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    update?: BarrioUpdateWithWhereUniqueWithoutDistritosInput | BarrioUpdateWithWhereUniqueWithoutDistritosInput[]
    updateMany?: BarrioUpdateManyWithWhereWithoutDistritosInput | BarrioUpdateManyWithWhereWithoutDistritosInput[]
    deleteMany?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
  }

  export type BarrioUncheckedUpdateManyWithoutDistritosNestedInput = {
    create?: XOR<BarrioCreateWithoutDistritosInput, BarrioUncheckedCreateWithoutDistritosInput> | BarrioCreateWithoutDistritosInput[] | BarrioUncheckedCreateWithoutDistritosInput[]
    connectOrCreate?: BarrioCreateOrConnectWithoutDistritosInput | BarrioCreateOrConnectWithoutDistritosInput[]
    upsert?: BarrioUpsertWithWhereUniqueWithoutDistritosInput | BarrioUpsertWithWhereUniqueWithoutDistritosInput[]
    createMany?: BarrioCreateManyDistritosInputEnvelope
    set?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    disconnect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    delete?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    connect?: BarrioWhereUniqueInput | BarrioWhereUniqueInput[]
    update?: BarrioUpdateWithWhereUniqueWithoutDistritosInput | BarrioUpdateWithWhereUniqueWithoutDistritosInput[]
    updateMany?: BarrioUpdateManyWithWhereWithoutDistritosInput | BarrioUpdateManyWithWhereWithoutDistritosInput[]
    deleteMany?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
  }

  export type ProvinciaCreateNestedOneWithoutBarriosInput = {
    create?: XOR<ProvinciaCreateWithoutBarriosInput, ProvinciaUncheckedCreateWithoutBarriosInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutBarriosInput
    connect?: ProvinciaWhereUniqueInput
  }

  export type CantonCreateNestedOneWithoutBarriosInput = {
    create?: XOR<CantonCreateWithoutBarriosInput, CantonUncheckedCreateWithoutBarriosInput>
    connectOrCreate?: CantonCreateOrConnectWithoutBarriosInput
    connect?: CantonWhereUniqueInput
  }

  export type DistritoCreateNestedOneWithoutBarriosInput = {
    create?: XOR<DistritoCreateWithoutBarriosInput, DistritoUncheckedCreateWithoutBarriosInput>
    connectOrCreate?: DistritoCreateOrConnectWithoutBarriosInput
    connect?: DistritoWhereUniqueInput
  }

  export type UbicacionCreateNestedOneWithoutBarriosInput = {
    create?: XOR<UbicacionCreateWithoutBarriosInput, UbicacionUncheckedCreateWithoutBarriosInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutBarriosInput
    connect?: UbicacionWhereUniqueInput
  }

  export type ProvinciaUpdateOneRequiredWithoutBarriosNestedInput = {
    create?: XOR<ProvinciaCreateWithoutBarriosInput, ProvinciaUncheckedCreateWithoutBarriosInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutBarriosInput
    upsert?: ProvinciaUpsertWithoutBarriosInput
    connect?: ProvinciaWhereUniqueInput
    update?: XOR<XOR<ProvinciaUpdateToOneWithWhereWithoutBarriosInput, ProvinciaUpdateWithoutBarriosInput>, ProvinciaUncheckedUpdateWithoutBarriosInput>
  }

  export type CantonUpdateOneRequiredWithoutBarriosNestedInput = {
    create?: XOR<CantonCreateWithoutBarriosInput, CantonUncheckedCreateWithoutBarriosInput>
    connectOrCreate?: CantonCreateOrConnectWithoutBarriosInput
    upsert?: CantonUpsertWithoutBarriosInput
    connect?: CantonWhereUniqueInput
    update?: XOR<XOR<CantonUpdateToOneWithWhereWithoutBarriosInput, CantonUpdateWithoutBarriosInput>, CantonUncheckedUpdateWithoutBarriosInput>
  }

  export type DistritoUpdateOneRequiredWithoutBarriosNestedInput = {
    create?: XOR<DistritoCreateWithoutBarriosInput, DistritoUncheckedCreateWithoutBarriosInput>
    connectOrCreate?: DistritoCreateOrConnectWithoutBarriosInput
    upsert?: DistritoUpsertWithoutBarriosInput
    connect?: DistritoWhereUniqueInput
    update?: XOR<XOR<DistritoUpdateToOneWithWhereWithoutBarriosInput, DistritoUpdateWithoutBarriosInput>, DistritoUncheckedUpdateWithoutBarriosInput>
  }

  export type UbicacionUpdateOneRequiredWithoutBarriosNestedInput = {
    create?: XOR<UbicacionCreateWithoutBarriosInput, UbicacionUncheckedCreateWithoutBarriosInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutBarriosInput
    upsert?: UbicacionUpsertWithoutBarriosInput
    connect?: UbicacionWhereUniqueInput
    update?: XOR<XOR<UbicacionUpdateToOneWithWhereWithoutBarriosInput, UbicacionUpdateWithoutBarriosInput>, UbicacionUncheckedUpdateWithoutBarriosInput>
  }

  export type UbicacionCreateNestedOneWithoutBodegaInput = {
    create?: XOR<UbicacionCreateWithoutBodegaInput, UbicacionUncheckedCreateWithoutBodegaInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutBodegaInput
    connect?: UbicacionWhereUniqueInput
  }

  export type BodegaProductosCreateNestedManyWithoutBodegasInput = {
    create?: XOR<BodegaProductosCreateWithoutBodegasInput, BodegaProductosUncheckedCreateWithoutBodegasInput> | BodegaProductosCreateWithoutBodegasInput[] | BodegaProductosUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutBodegasInput | BodegaProductosCreateOrConnectWithoutBodegasInput[]
    createMany?: BodegaProductosCreateManyBodegasInputEnvelope
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
  }

  export type DetalleCompraCreateNestedManyWithoutBodegasInput = {
    create?: XOR<DetalleCompraCreateWithoutBodegasInput, DetalleCompraUncheckedCreateWithoutBodegasInput> | DetalleCompraCreateWithoutBodegasInput[] | DetalleCompraUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutBodegasInput | DetalleCompraCreateOrConnectWithoutBodegasInput[]
    createMany?: DetalleCompraCreateManyBodegasInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type HistorialCreateNestedManyWithoutBodegasInput = {
    create?: XOR<HistorialCreateWithoutBodegasInput, HistorialUncheckedCreateWithoutBodegasInput> | HistorialCreateWithoutBodegasInput[] | HistorialUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutBodegasInput | HistorialCreateOrConnectWithoutBodegasInput[]
    createMany?: HistorialCreateManyBodegasInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type TrasladoDestinoCreateNestedManyWithoutBodegasInput = {
    create?: XOR<TrasladoDestinoCreateWithoutBodegasInput, TrasladoDestinoUncheckedCreateWithoutBodegasInput> | TrasladoDestinoCreateWithoutBodegasInput[] | TrasladoDestinoUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutBodegasInput | TrasladoDestinoCreateOrConnectWithoutBodegasInput[]
    createMany?: TrasladoDestinoCreateManyBodegasInputEnvelope
    connect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
  }

  export type BodegaProductosUncheckedCreateNestedManyWithoutBodegasInput = {
    create?: XOR<BodegaProductosCreateWithoutBodegasInput, BodegaProductosUncheckedCreateWithoutBodegasInput> | BodegaProductosCreateWithoutBodegasInput[] | BodegaProductosUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutBodegasInput | BodegaProductosCreateOrConnectWithoutBodegasInput[]
    createMany?: BodegaProductosCreateManyBodegasInputEnvelope
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
  }

  export type DetalleCompraUncheckedCreateNestedManyWithoutBodegasInput = {
    create?: XOR<DetalleCompraCreateWithoutBodegasInput, DetalleCompraUncheckedCreateWithoutBodegasInput> | DetalleCompraCreateWithoutBodegasInput[] | DetalleCompraUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutBodegasInput | DetalleCompraCreateOrConnectWithoutBodegasInput[]
    createMany?: DetalleCompraCreateManyBodegasInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type HistorialUncheckedCreateNestedManyWithoutBodegasInput = {
    create?: XOR<HistorialCreateWithoutBodegasInput, HistorialUncheckedCreateWithoutBodegasInput> | HistorialCreateWithoutBodegasInput[] | HistorialUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutBodegasInput | HistorialCreateOrConnectWithoutBodegasInput[]
    createMany?: HistorialCreateManyBodegasInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type TrasladoDestinoUncheckedCreateNestedManyWithoutBodegasInput = {
    create?: XOR<TrasladoDestinoCreateWithoutBodegasInput, TrasladoDestinoUncheckedCreateWithoutBodegasInput> | TrasladoDestinoCreateWithoutBodegasInput[] | TrasladoDestinoUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutBodegasInput | TrasladoDestinoCreateOrConnectWithoutBodegasInput[]
    createMany?: TrasladoDestinoCreateManyBodegasInputEnvelope
    connect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UbicacionUpdateOneRequiredWithoutBodegaNestedInput = {
    create?: XOR<UbicacionCreateWithoutBodegaInput, UbicacionUncheckedCreateWithoutBodegaInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutBodegaInput
    upsert?: UbicacionUpsertWithoutBodegaInput
    connect?: UbicacionWhereUniqueInput
    update?: XOR<XOR<UbicacionUpdateToOneWithWhereWithoutBodegaInput, UbicacionUpdateWithoutBodegaInput>, UbicacionUncheckedUpdateWithoutBodegaInput>
  }

  export type BodegaProductosUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<BodegaProductosCreateWithoutBodegasInput, BodegaProductosUncheckedCreateWithoutBodegasInput> | BodegaProductosCreateWithoutBodegasInput[] | BodegaProductosUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutBodegasInput | BodegaProductosCreateOrConnectWithoutBodegasInput[]
    upsert?: BodegaProductosUpsertWithWhereUniqueWithoutBodegasInput | BodegaProductosUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: BodegaProductosCreateManyBodegasInputEnvelope
    set?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    disconnect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    delete?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    update?: BodegaProductosUpdateWithWhereUniqueWithoutBodegasInput | BodegaProductosUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: BodegaProductosUpdateManyWithWhereWithoutBodegasInput | BodegaProductosUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: BodegaProductosScalarWhereInput | BodegaProductosScalarWhereInput[]
  }

  export type DetalleCompraUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutBodegasInput, DetalleCompraUncheckedCreateWithoutBodegasInput> | DetalleCompraCreateWithoutBodegasInput[] | DetalleCompraUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutBodegasInput | DetalleCompraCreateOrConnectWithoutBodegasInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutBodegasInput | DetalleCompraUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: DetalleCompraCreateManyBodegasInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutBodegasInput | DetalleCompraUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutBodegasInput | DetalleCompraUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type HistorialUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<HistorialCreateWithoutBodegasInput, HistorialUncheckedCreateWithoutBodegasInput> | HistorialCreateWithoutBodegasInput[] | HistorialUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutBodegasInput | HistorialCreateOrConnectWithoutBodegasInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutBodegasInput | HistorialUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: HistorialCreateManyBodegasInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutBodegasInput | HistorialUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutBodegasInput | HistorialUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type TrasladoDestinoUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<TrasladoDestinoCreateWithoutBodegasInput, TrasladoDestinoUncheckedCreateWithoutBodegasInput> | TrasladoDestinoCreateWithoutBodegasInput[] | TrasladoDestinoUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutBodegasInput | TrasladoDestinoCreateOrConnectWithoutBodegasInput[]
    upsert?: TrasladoDestinoUpsertWithWhereUniqueWithoutBodegasInput | TrasladoDestinoUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: TrasladoDestinoCreateManyBodegasInputEnvelope
    set?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    disconnect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    delete?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    connect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    update?: TrasladoDestinoUpdateWithWhereUniqueWithoutBodegasInput | TrasladoDestinoUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: TrasladoDestinoUpdateManyWithWhereWithoutBodegasInput | TrasladoDestinoUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: TrasladoDestinoScalarWhereInput | TrasladoDestinoScalarWhereInput[]
  }

  export type BodegaProductosUncheckedUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<BodegaProductosCreateWithoutBodegasInput, BodegaProductosUncheckedCreateWithoutBodegasInput> | BodegaProductosCreateWithoutBodegasInput[] | BodegaProductosUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: BodegaProductosCreateOrConnectWithoutBodegasInput | BodegaProductosCreateOrConnectWithoutBodegasInput[]
    upsert?: BodegaProductosUpsertWithWhereUniqueWithoutBodegasInput | BodegaProductosUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: BodegaProductosCreateManyBodegasInputEnvelope
    set?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    disconnect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    delete?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    connect?: BodegaProductosWhereUniqueInput | BodegaProductosWhereUniqueInput[]
    update?: BodegaProductosUpdateWithWhereUniqueWithoutBodegasInput | BodegaProductosUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: BodegaProductosUpdateManyWithWhereWithoutBodegasInput | BodegaProductosUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: BodegaProductosScalarWhereInput | BodegaProductosScalarWhereInput[]
  }

  export type DetalleCompraUncheckedUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutBodegasInput, DetalleCompraUncheckedCreateWithoutBodegasInput> | DetalleCompraCreateWithoutBodegasInput[] | DetalleCompraUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutBodegasInput | DetalleCompraCreateOrConnectWithoutBodegasInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutBodegasInput | DetalleCompraUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: DetalleCompraCreateManyBodegasInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutBodegasInput | DetalleCompraUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutBodegasInput | DetalleCompraUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type HistorialUncheckedUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<HistorialCreateWithoutBodegasInput, HistorialUncheckedCreateWithoutBodegasInput> | HistorialCreateWithoutBodegasInput[] | HistorialUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutBodegasInput | HistorialCreateOrConnectWithoutBodegasInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutBodegasInput | HistorialUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: HistorialCreateManyBodegasInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutBodegasInput | HistorialUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutBodegasInput | HistorialUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type TrasladoDestinoUncheckedUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<TrasladoDestinoCreateWithoutBodegasInput, TrasladoDestinoUncheckedCreateWithoutBodegasInput> | TrasladoDestinoCreateWithoutBodegasInput[] | TrasladoDestinoUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutBodegasInput | TrasladoDestinoCreateOrConnectWithoutBodegasInput[]
    upsert?: TrasladoDestinoUpsertWithWhereUniqueWithoutBodegasInput | TrasladoDestinoUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: TrasladoDestinoCreateManyBodegasInputEnvelope
    set?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    disconnect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    delete?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    connect?: TrasladoDestinoWhereUniqueInput | TrasladoDestinoWhereUniqueInput[]
    update?: TrasladoDestinoUpdateWithWhereUniqueWithoutBodegasInput | TrasladoDestinoUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: TrasladoDestinoUpdateManyWithWhereWithoutBodegasInput | TrasladoDestinoUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: TrasladoDestinoScalarWhereInput | TrasladoDestinoScalarWhereInput[]
  }

  export type BodegaCreateNestedOneWithoutBodegaProductosInput = {
    create?: XOR<BodegaCreateWithoutBodegaProductosInput, BodegaUncheckedCreateWithoutBodegaProductosInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutBodegaProductosInput
    connect?: BodegaWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutBodegaProductosInput = {
    create?: XOR<ProductoCreateWithoutBodegaProductosInput, ProductoUncheckedCreateWithoutBodegaProductosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutBodegaProductosInput
    connect?: ProductoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutBodegaProductosInput = {
    create?: XOR<UsuarioCreateWithoutBodegaProductosInput, UsuarioUncheckedCreateWithoutBodegaProductosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutBodegaProductosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type BodegaUpdateOneRequiredWithoutBodegaProductosNestedInput = {
    create?: XOR<BodegaCreateWithoutBodegaProductosInput, BodegaUncheckedCreateWithoutBodegaProductosInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutBodegaProductosInput
    upsert?: BodegaUpsertWithoutBodegaProductosInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutBodegaProductosInput, BodegaUpdateWithoutBodegaProductosInput>, BodegaUncheckedUpdateWithoutBodegaProductosInput>
  }

  export type ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput = {
    create?: XOR<ProductoCreateWithoutBodegaProductosInput, ProductoUncheckedCreateWithoutBodegaProductosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutBodegaProductosInput
    upsert?: ProductoUpsertWithoutBodegaProductosInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutBodegaProductosInput, ProductoUpdateWithoutBodegaProductosInput>, ProductoUncheckedUpdateWithoutBodegaProductosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutBodegaProductosNestedInput = {
    create?: XOR<UsuarioCreateWithoutBodegaProductosInput, UsuarioUncheckedCreateWithoutBodegaProductosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutBodegaProductosInput
    upsert?: UsuarioUpsertWithoutBodegaProductosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutBodegaProductosInput, UsuarioUpdateWithoutBodegaProductosInput>, UsuarioUncheckedUpdateWithoutBodegaProductosInput>
  }

  export type UsuarioCreateNestedOneWithoutEncabezadoComprasInput = {
    create?: XOR<UsuarioCreateWithoutEncabezadoComprasInput, UsuarioUncheckedCreateWithoutEncabezadoComprasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEncabezadoComprasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type DetalleCompraCreateNestedManyWithoutEncabezadoComprasInput = {
    create?: XOR<DetalleCompraCreateWithoutEncabezadoComprasInput, DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput> | DetalleCompraCreateWithoutEncabezadoComprasInput[] | DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput | DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput[]
    createMany?: DetalleCompraCreateManyEncabezadoComprasInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type PedidoCreateNestedManyWithoutEncabezadoComprasInput = {
    create?: XOR<PedidoCreateWithoutEncabezadoComprasInput, PedidoUncheckedCreateWithoutEncabezadoComprasInput> | PedidoCreateWithoutEncabezadoComprasInput[] | PedidoUncheckedCreateWithoutEncabezadoComprasInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEncabezadoComprasInput | PedidoCreateOrConnectWithoutEncabezadoComprasInput[]
    createMany?: PedidoCreateManyEncabezadoComprasInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoComprasInput = {
    create?: XOR<DetalleCompraCreateWithoutEncabezadoComprasInput, DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput> | DetalleCompraCreateWithoutEncabezadoComprasInput[] | DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput | DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput[]
    createMany?: DetalleCompraCreateManyEncabezadoComprasInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutEncabezadoComprasInput = {
    create?: XOR<PedidoCreateWithoutEncabezadoComprasInput, PedidoUncheckedCreateWithoutEncabezadoComprasInput> | PedidoCreateWithoutEncabezadoComprasInput[] | PedidoUncheckedCreateWithoutEncabezadoComprasInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEncabezadoComprasInput | PedidoCreateOrConnectWithoutEncabezadoComprasInput[]
    createMany?: PedidoCreateManyEncabezadoComprasInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput = {
    create?: XOR<UsuarioCreateWithoutEncabezadoComprasInput, UsuarioUncheckedCreateWithoutEncabezadoComprasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEncabezadoComprasInput
    upsert?: UsuarioUpsertWithoutEncabezadoComprasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEncabezadoComprasInput, UsuarioUpdateWithoutEncabezadoComprasInput>, UsuarioUncheckedUpdateWithoutEncabezadoComprasInput>
  }

  export type DetalleCompraUpdateManyWithoutEncabezadoComprasNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutEncabezadoComprasInput, DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput> | DetalleCompraCreateWithoutEncabezadoComprasInput[] | DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput | DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoComprasInput | DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoComprasInput[]
    createMany?: DetalleCompraCreateManyEncabezadoComprasInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoComprasInput | DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoComprasInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutEncabezadoComprasInput | DetalleCompraUpdateManyWithWhereWithoutEncabezadoComprasInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type PedidoUpdateManyWithoutEncabezadoComprasNestedInput = {
    create?: XOR<PedidoCreateWithoutEncabezadoComprasInput, PedidoUncheckedCreateWithoutEncabezadoComprasInput> | PedidoCreateWithoutEncabezadoComprasInput[] | PedidoUncheckedCreateWithoutEncabezadoComprasInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEncabezadoComprasInput | PedidoCreateOrConnectWithoutEncabezadoComprasInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutEncabezadoComprasInput | PedidoUpsertWithWhereUniqueWithoutEncabezadoComprasInput[]
    createMany?: PedidoCreateManyEncabezadoComprasInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutEncabezadoComprasInput | PedidoUpdateWithWhereUniqueWithoutEncabezadoComprasInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutEncabezadoComprasInput | PedidoUpdateManyWithWhereWithoutEncabezadoComprasInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type DetalleCompraUncheckedUpdateManyWithoutEncabezadoComprasNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutEncabezadoComprasInput, DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput> | DetalleCompraCreateWithoutEncabezadoComprasInput[] | DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput | DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoComprasInput | DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoComprasInput[]
    createMany?: DetalleCompraCreateManyEncabezadoComprasInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoComprasInput | DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoComprasInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutEncabezadoComprasInput | DetalleCompraUpdateManyWithWhereWithoutEncabezadoComprasInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutEncabezadoComprasNestedInput = {
    create?: XOR<PedidoCreateWithoutEncabezadoComprasInput, PedidoUncheckedCreateWithoutEncabezadoComprasInput> | PedidoCreateWithoutEncabezadoComprasInput[] | PedidoUncheckedCreateWithoutEncabezadoComprasInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEncabezadoComprasInput | PedidoCreateOrConnectWithoutEncabezadoComprasInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutEncabezadoComprasInput | PedidoUpsertWithWhereUniqueWithoutEncabezadoComprasInput[]
    createMany?: PedidoCreateManyEncabezadoComprasInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutEncabezadoComprasInput | PedidoUpdateWithWhereUniqueWithoutEncabezadoComprasInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutEncabezadoComprasInput | PedidoUpdateManyWithWhereWithoutEncabezadoComprasInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type ProductoCreateNestedOneWithoutDetalleComprasInput = {
    create?: XOR<ProductoCreateWithoutDetalleComprasInput, ProductoUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetalleComprasInput
    connect?: ProductoWhereUniqueInput
  }

  export type EncabezadoCompraCreateNestedOneWithoutDetalleComprasInput = {
    create?: XOR<EncabezadoCompraCreateWithoutDetalleComprasInput, EncabezadoCompraUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutDetalleComprasInput
    connect?: EncabezadoCompraWhereUniqueInput
  }

  export type BodegaCreateNestedOneWithoutDetalleComprasInput = {
    create?: XOR<BodegaCreateWithoutDetalleComprasInput, BodegaUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutDetalleComprasInput
    connect?: BodegaWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutDetalleComprasNestedInput = {
    create?: XOR<ProductoCreateWithoutDetalleComprasInput, ProductoUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetalleComprasInput
    upsert?: ProductoUpsertWithoutDetalleComprasInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutDetalleComprasInput, ProductoUpdateWithoutDetalleComprasInput>, ProductoUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type EncabezadoCompraUpdateOneRequiredWithoutDetalleComprasNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutDetalleComprasInput, EncabezadoCompraUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutDetalleComprasInput
    upsert?: EncabezadoCompraUpsertWithoutDetalleComprasInput
    connect?: EncabezadoCompraWhereUniqueInput
    update?: XOR<XOR<EncabezadoCompraUpdateToOneWithWhereWithoutDetalleComprasInput, EncabezadoCompraUpdateWithoutDetalleComprasInput>, EncabezadoCompraUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type BodegaUpdateOneRequiredWithoutDetalleComprasNestedInput = {
    create?: XOR<BodegaCreateWithoutDetalleComprasInput, BodegaUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutDetalleComprasInput
    upsert?: BodegaUpsertWithoutDetalleComprasInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutDetalleComprasInput, BodegaUpdateWithoutDetalleComprasInput>, BodegaUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type EstadoCreateNestedOneWithoutPedidosInput = {
    create?: XOR<EstadoCreateWithoutPedidosInput, EstadoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutPedidosInput
    connect?: EstadoWhereUniqueInput
  }

  export type EncabezadoCompraCreateNestedOneWithoutPedidosInput = {
    create?: XOR<EncabezadoCompraCreateWithoutPedidosInput, EncabezadoCompraUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutPedidosInput
    connect?: EncabezadoCompraWhereUniqueInput
  }

  export type TrasladoBodegasCreateNestedManyWithoutPedidosInput = {
    create?: XOR<TrasladoBodegasCreateWithoutPedidosInput, TrasladoBodegasUncheckedCreateWithoutPedidosInput> | TrasladoBodegasCreateWithoutPedidosInput[] | TrasladoBodegasUncheckedCreateWithoutPedidosInput[]
    connectOrCreate?: TrasladoBodegasCreateOrConnectWithoutPedidosInput | TrasladoBodegasCreateOrConnectWithoutPedidosInput[]
    createMany?: TrasladoBodegasCreateManyPedidosInputEnvelope
    connect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
  }

  export type TrasladoBodegasUncheckedCreateNestedManyWithoutPedidosInput = {
    create?: XOR<TrasladoBodegasCreateWithoutPedidosInput, TrasladoBodegasUncheckedCreateWithoutPedidosInput> | TrasladoBodegasCreateWithoutPedidosInput[] | TrasladoBodegasUncheckedCreateWithoutPedidosInput[]
    connectOrCreate?: TrasladoBodegasCreateOrConnectWithoutPedidosInput | TrasladoBodegasCreateOrConnectWithoutPedidosInput[]
    createMany?: TrasladoBodegasCreateManyPedidosInputEnvelope
    connect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
  }

  export type EstadoUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<EstadoCreateWithoutPedidosInput, EstadoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutPedidosInput
    upsert?: EstadoUpsertWithoutPedidosInput
    connect?: EstadoWhereUniqueInput
    update?: XOR<XOR<EstadoUpdateToOneWithWhereWithoutPedidosInput, EstadoUpdateWithoutPedidosInput>, EstadoUncheckedUpdateWithoutPedidosInput>
  }

  export type EncabezadoCompraUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutPedidosInput, EncabezadoCompraUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutPedidosInput
    upsert?: EncabezadoCompraUpsertWithoutPedidosInput
    connect?: EncabezadoCompraWhereUniqueInput
    update?: XOR<XOR<EncabezadoCompraUpdateToOneWithWhereWithoutPedidosInput, EncabezadoCompraUpdateWithoutPedidosInput>, EncabezadoCompraUncheckedUpdateWithoutPedidosInput>
  }

  export type TrasladoBodegasUpdateManyWithoutPedidosNestedInput = {
    create?: XOR<TrasladoBodegasCreateWithoutPedidosInput, TrasladoBodegasUncheckedCreateWithoutPedidosInput> | TrasladoBodegasCreateWithoutPedidosInput[] | TrasladoBodegasUncheckedCreateWithoutPedidosInput[]
    connectOrCreate?: TrasladoBodegasCreateOrConnectWithoutPedidosInput | TrasladoBodegasCreateOrConnectWithoutPedidosInput[]
    upsert?: TrasladoBodegasUpsertWithWhereUniqueWithoutPedidosInput | TrasladoBodegasUpsertWithWhereUniqueWithoutPedidosInput[]
    createMany?: TrasladoBodegasCreateManyPedidosInputEnvelope
    set?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    disconnect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    delete?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    connect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    update?: TrasladoBodegasUpdateWithWhereUniqueWithoutPedidosInput | TrasladoBodegasUpdateWithWhereUniqueWithoutPedidosInput[]
    updateMany?: TrasladoBodegasUpdateManyWithWhereWithoutPedidosInput | TrasladoBodegasUpdateManyWithWhereWithoutPedidosInput[]
    deleteMany?: TrasladoBodegasScalarWhereInput | TrasladoBodegasScalarWhereInput[]
  }

  export type TrasladoBodegasUncheckedUpdateManyWithoutPedidosNestedInput = {
    create?: XOR<TrasladoBodegasCreateWithoutPedidosInput, TrasladoBodegasUncheckedCreateWithoutPedidosInput> | TrasladoBodegasCreateWithoutPedidosInput[] | TrasladoBodegasUncheckedCreateWithoutPedidosInput[]
    connectOrCreate?: TrasladoBodegasCreateOrConnectWithoutPedidosInput | TrasladoBodegasCreateOrConnectWithoutPedidosInput[]
    upsert?: TrasladoBodegasUpsertWithWhereUniqueWithoutPedidosInput | TrasladoBodegasUpsertWithWhereUniqueWithoutPedidosInput[]
    createMany?: TrasladoBodegasCreateManyPedidosInputEnvelope
    set?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    disconnect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    delete?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    connect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    update?: TrasladoBodegasUpdateWithWhereUniqueWithoutPedidosInput | TrasladoBodegasUpdateWithWhereUniqueWithoutPedidosInput[]
    updateMany?: TrasladoBodegasUpdateManyWithWhereWithoutPedidosInput | TrasladoBodegasUpdateManyWithWhereWithoutPedidosInput[]
    deleteMany?: TrasladoBodegasScalarWhereInput | TrasladoBodegasScalarWhereInput[]
  }

  export type PedidoCreateNestedOneWithoutTrasladoBodegasInput = {
    create?: XOR<PedidoCreateWithoutTrasladoBodegasInput, PedidoUncheckedCreateWithoutTrasladoBodegasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutTrasladoBodegasInput
    connect?: PedidoWhereUniqueInput
  }

  export type TrasladoDestinoCreateNestedOneWithoutTrasladoBodegasInput = {
    create?: XOR<TrasladoDestinoCreateWithoutTrasladoBodegasInput, TrasladoDestinoUncheckedCreateWithoutTrasladoBodegasInput>
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutTrasladoBodegasInput
    connect?: TrasladoDestinoWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutTrasladoBodegasNestedInput = {
    create?: XOR<PedidoCreateWithoutTrasladoBodegasInput, PedidoUncheckedCreateWithoutTrasladoBodegasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutTrasladoBodegasInput
    upsert?: PedidoUpsertWithoutTrasladoBodegasInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutTrasladoBodegasInput, PedidoUpdateWithoutTrasladoBodegasInput>, PedidoUncheckedUpdateWithoutTrasladoBodegasInput>
  }

  export type TrasladoDestinoUpdateOneRequiredWithoutTrasladoBodegasNestedInput = {
    create?: XOR<TrasladoDestinoCreateWithoutTrasladoBodegasInput, TrasladoDestinoUncheckedCreateWithoutTrasladoBodegasInput>
    connectOrCreate?: TrasladoDestinoCreateOrConnectWithoutTrasladoBodegasInput
    upsert?: TrasladoDestinoUpsertWithoutTrasladoBodegasInput
    connect?: TrasladoDestinoWhereUniqueInput
    update?: XOR<XOR<TrasladoDestinoUpdateToOneWithWhereWithoutTrasladoBodegasInput, TrasladoDestinoUpdateWithoutTrasladoBodegasInput>, TrasladoDestinoUncheckedUpdateWithoutTrasladoBodegasInput>
  }

  export type BodegaCreateNestedOneWithoutTrasladoDestinoInput = {
    create?: XOR<BodegaCreateWithoutTrasladoDestinoInput, BodegaUncheckedCreateWithoutTrasladoDestinoInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutTrasladoDestinoInput
    connect?: BodegaWhereUniqueInput
  }

  export type EstadoCreateNestedOneWithoutTrasladoDestinoInput = {
    create?: XOR<EstadoCreateWithoutTrasladoDestinoInput, EstadoUncheckedCreateWithoutTrasladoDestinoInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutTrasladoDestinoInput
    connect?: EstadoWhereUniqueInput
  }

  export type TrasladoBodegasCreateNestedManyWithoutDestinosInput = {
    create?: XOR<TrasladoBodegasCreateWithoutDestinosInput, TrasladoBodegasUncheckedCreateWithoutDestinosInput> | TrasladoBodegasCreateWithoutDestinosInput[] | TrasladoBodegasUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: TrasladoBodegasCreateOrConnectWithoutDestinosInput | TrasladoBodegasCreateOrConnectWithoutDestinosInput[]
    createMany?: TrasladoBodegasCreateManyDestinosInputEnvelope
    connect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
  }

  export type TrasladoBodegasUncheckedCreateNestedManyWithoutDestinosInput = {
    create?: XOR<TrasladoBodegasCreateWithoutDestinosInput, TrasladoBodegasUncheckedCreateWithoutDestinosInput> | TrasladoBodegasCreateWithoutDestinosInput[] | TrasladoBodegasUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: TrasladoBodegasCreateOrConnectWithoutDestinosInput | TrasladoBodegasCreateOrConnectWithoutDestinosInput[]
    createMany?: TrasladoBodegasCreateManyDestinosInputEnvelope
    connect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
  }

  export type BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput = {
    create?: XOR<BodegaCreateWithoutTrasladoDestinoInput, BodegaUncheckedCreateWithoutTrasladoDestinoInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutTrasladoDestinoInput
    upsert?: BodegaUpsertWithoutTrasladoDestinoInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutTrasladoDestinoInput, BodegaUpdateWithoutTrasladoDestinoInput>, BodegaUncheckedUpdateWithoutTrasladoDestinoInput>
  }

  export type EstadoUpdateOneRequiredWithoutTrasladoDestinoNestedInput = {
    create?: XOR<EstadoCreateWithoutTrasladoDestinoInput, EstadoUncheckedCreateWithoutTrasladoDestinoInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutTrasladoDestinoInput
    upsert?: EstadoUpsertWithoutTrasladoDestinoInput
    connect?: EstadoWhereUniqueInput
    update?: XOR<XOR<EstadoUpdateToOneWithWhereWithoutTrasladoDestinoInput, EstadoUpdateWithoutTrasladoDestinoInput>, EstadoUncheckedUpdateWithoutTrasladoDestinoInput>
  }

  export type TrasladoBodegasUpdateManyWithoutDestinosNestedInput = {
    create?: XOR<TrasladoBodegasCreateWithoutDestinosInput, TrasladoBodegasUncheckedCreateWithoutDestinosInput> | TrasladoBodegasCreateWithoutDestinosInput[] | TrasladoBodegasUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: TrasladoBodegasCreateOrConnectWithoutDestinosInput | TrasladoBodegasCreateOrConnectWithoutDestinosInput[]
    upsert?: TrasladoBodegasUpsertWithWhereUniqueWithoutDestinosInput | TrasladoBodegasUpsertWithWhereUniqueWithoutDestinosInput[]
    createMany?: TrasladoBodegasCreateManyDestinosInputEnvelope
    set?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    disconnect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    delete?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    connect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    update?: TrasladoBodegasUpdateWithWhereUniqueWithoutDestinosInput | TrasladoBodegasUpdateWithWhereUniqueWithoutDestinosInput[]
    updateMany?: TrasladoBodegasUpdateManyWithWhereWithoutDestinosInput | TrasladoBodegasUpdateManyWithWhereWithoutDestinosInput[]
    deleteMany?: TrasladoBodegasScalarWhereInput | TrasladoBodegasScalarWhereInput[]
  }

  export type TrasladoBodegasUncheckedUpdateManyWithoutDestinosNestedInput = {
    create?: XOR<TrasladoBodegasCreateWithoutDestinosInput, TrasladoBodegasUncheckedCreateWithoutDestinosInput> | TrasladoBodegasCreateWithoutDestinosInput[] | TrasladoBodegasUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: TrasladoBodegasCreateOrConnectWithoutDestinosInput | TrasladoBodegasCreateOrConnectWithoutDestinosInput[]
    upsert?: TrasladoBodegasUpsertWithWhereUniqueWithoutDestinosInput | TrasladoBodegasUpsertWithWhereUniqueWithoutDestinosInput[]
    createMany?: TrasladoBodegasCreateManyDestinosInputEnvelope
    set?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    disconnect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    delete?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    connect?: TrasladoBodegasWhereUniqueInput | TrasladoBodegasWhereUniqueInput[]
    update?: TrasladoBodegasUpdateWithWhereUniqueWithoutDestinosInput | TrasladoBodegasUpdateWithWhereUniqueWithoutDestinosInput[]
    updateMany?: TrasladoBodegasUpdateManyWithWhereWithoutDestinosInput | TrasladoBodegasUpdateManyWithWhereWithoutDestinosInput[]
    deleteMany?: TrasladoBodegasScalarWhereInput | TrasladoBodegasScalarWhereInput[]
  }

  export type BodegaCreateNestedOneWithoutHistorialInput = {
    create?: XOR<BodegaCreateWithoutHistorialInput, BodegaUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutHistorialInput
    connect?: BodegaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutHistorialInput = {
    create?: XOR<UsuarioCreateWithoutHistorialInput, UsuarioUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHistorialInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutHistorialInput = {
    create?: XOR<ProductoCreateWithoutHistorialInput, ProductoUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutHistorialInput
    connect?: ProductoWhereUniqueInput
  }

  export type BodegaUpdateOneRequiredWithoutHistorialNestedInput = {
    create?: XOR<BodegaCreateWithoutHistorialInput, BodegaUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutHistorialInput
    upsert?: BodegaUpsertWithoutHistorialInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutHistorialInput, BodegaUpdateWithoutHistorialInput>, BodegaUncheckedUpdateWithoutHistorialInput>
  }

  export type UsuarioUpdateOneRequiredWithoutHistorialNestedInput = {
    create?: XOR<UsuarioCreateWithoutHistorialInput, UsuarioUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHistorialInput
    upsert?: UsuarioUpsertWithoutHistorialInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutHistorialInput, UsuarioUpdateWithoutHistorialInput>, UsuarioUncheckedUpdateWithoutHistorialInput>
  }

  export type ProductoUpdateOneRequiredWithoutHistorialNestedInput = {
    create?: XOR<ProductoCreateWithoutHistorialInput, ProductoUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutHistorialInput
    upsert?: ProductoUpsertWithoutHistorialInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutHistorialInput, ProductoUpdateWithoutHistorialInput>, ProductoUncheckedUpdateWithoutHistorialInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UbicacionCreateWithoutUsuarioInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    bodega?: BodegaCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaCreateNestedManyWithoutUbicacionInput
    cantones?: CantonCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    bodega?: BodegaUncheckedCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaUncheckedCreateNestedManyWithoutUbicacionInput
    cantones?: CantonUncheckedCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionCreateOrConnectWithoutUsuarioInput = {
    where: UbicacionWhereUniqueInput
    create: XOR<UbicacionCreateWithoutUsuarioInput, UbicacionUncheckedCreateWithoutUsuarioInput>
  }

  export type BodegaProductosCreateWithoutUsuarioInput = {
    fechaRegistro?: Date | string
    cantidad: number
    bodegas: BodegaCreateNestedOneWithoutBodegaProductosInput
    producto: ProductoCreateNestedOneWithoutBodegaProductosInput
  }

  export type BodegaProductosUncheckedCreateWithoutUsuarioInput = {
    idBodega: number
    idProducto: number
    fechaRegistro?: Date | string
    cantidad: number
  }

  export type BodegaProductosCreateOrConnectWithoutUsuarioInput = {
    where: BodegaProductosWhereUniqueInput
    create: XOR<BodegaProductosCreateWithoutUsuarioInput, BodegaProductosUncheckedCreateWithoutUsuarioInput>
  }

  export type BodegaProductosCreateManyUsuarioInputEnvelope = {
    data: BodegaProductosCreateManyUsuarioInput | BodegaProductosCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EncabezadoCompraCreateWithoutUsuarioProveedorInput = {
    fechaCompra?: Date | string
    idUsuarioRegistro: number
    detalleCompras?: DetalleCompraCreateNestedManyWithoutEncabezadoComprasInput
    pedidos?: PedidoCreateNestedManyWithoutEncabezadoComprasInput
  }

  export type EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput = {
    id?: number
    fechaCompra?: Date | string
    idUsuarioRegistro: number
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoComprasInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutEncabezadoComprasInput
  }

  export type EncabezadoCompraCreateOrConnectWithoutUsuarioProveedorInput = {
    where: EncabezadoCompraWhereUniqueInput
    create: XOR<EncabezadoCompraCreateWithoutUsuarioProveedorInput, EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput>
  }

  export type EncabezadoCompraCreateManyUsuarioProveedorInputEnvelope = {
    data: EncabezadoCompraCreateManyUsuarioProveedorInput | EncabezadoCompraCreateManyUsuarioProveedorInput[]
    skipDuplicates?: boolean
  }

  export type HistorialCreateWithoutUsuarioRegistroInput = {
    fechaAjuste?: Date | string
    justificacion: string
    bodegas: BodegaCreateNestedOneWithoutHistorialInput
    productos: ProductoCreateNestedOneWithoutHistorialInput
  }

  export type HistorialUncheckedCreateWithoutUsuarioRegistroInput = {
    id?: number
    idBodega: number
    idProducto: number
    fechaAjuste?: Date | string
    justificacion: string
  }

  export type HistorialCreateOrConnectWithoutUsuarioRegistroInput = {
    where: HistorialWhereUniqueInput
    create: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput>
  }

  export type HistorialCreateManyUsuarioRegistroInputEnvelope = {
    data: HistorialCreateManyUsuarioRegistroInput | HistorialCreateManyUsuarioRegistroInput[]
    skipDuplicates?: boolean
  }

  export type UbicacionUpsertWithoutUsuarioInput = {
    update: XOR<UbicacionUpdateWithoutUsuarioInput, UbicacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<UbicacionCreateWithoutUsuarioInput, UbicacionUncheckedCreateWithoutUsuarioInput>
    where?: UbicacionWhereInput
  }

  export type UbicacionUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: UbicacionWhereInput
    data: XOR<UbicacionUpdateWithoutUsuarioInput, UbicacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type UbicacionUpdateWithoutUsuarioInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    bodega?: BodegaUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    bodega?: BodegaUncheckedUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUncheckedUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUncheckedUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type BodegaProductosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: BodegaProductosWhereUniqueInput
    update: XOR<BodegaProductosUpdateWithoutUsuarioInput, BodegaProductosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<BodegaProductosCreateWithoutUsuarioInput, BodegaProductosUncheckedCreateWithoutUsuarioInput>
  }

  export type BodegaProductosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: BodegaProductosWhereUniqueInput
    data: XOR<BodegaProductosUpdateWithoutUsuarioInput, BodegaProductosUncheckedUpdateWithoutUsuarioInput>
  }

  export type BodegaProductosUpdateManyWithWhereWithoutUsuarioInput = {
    where: BodegaProductosScalarWhereInput
    data: XOR<BodegaProductosUpdateManyMutationInput, BodegaProductosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type BodegaProductosScalarWhereInput = {
    AND?: BodegaProductosScalarWhereInput | BodegaProductosScalarWhereInput[]
    OR?: BodegaProductosScalarWhereInput[]
    NOT?: BodegaProductosScalarWhereInput | BodegaProductosScalarWhereInput[]
    idBodega?: IntFilter<"BodegaProductos"> | number
    idProducto?: IntFilter<"BodegaProductos"> | number
    idUsuario?: IntFilter<"BodegaProductos"> | number
    fechaRegistro?: DateTimeFilter<"BodegaProductos"> | Date | string
    cantidad?: IntFilter<"BodegaProductos"> | number
  }

  export type EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioProveedorInput = {
    where: EncabezadoCompraWhereUniqueInput
    update: XOR<EncabezadoCompraUpdateWithoutUsuarioProveedorInput, EncabezadoCompraUncheckedUpdateWithoutUsuarioProveedorInput>
    create: XOR<EncabezadoCompraCreateWithoutUsuarioProveedorInput, EncabezadoCompraUncheckedCreateWithoutUsuarioProveedorInput>
  }

  export type EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioProveedorInput = {
    where: EncabezadoCompraWhereUniqueInput
    data: XOR<EncabezadoCompraUpdateWithoutUsuarioProveedorInput, EncabezadoCompraUncheckedUpdateWithoutUsuarioProveedorInput>
  }

  export type EncabezadoCompraUpdateManyWithWhereWithoutUsuarioProveedorInput = {
    where: EncabezadoCompraScalarWhereInput
    data: XOR<EncabezadoCompraUpdateManyMutationInput, EncabezadoCompraUncheckedUpdateManyWithoutUsuarioProveedorInput>
  }

  export type EncabezadoCompraScalarWhereInput = {
    AND?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
    OR?: EncabezadoCompraScalarWhereInput[]
    NOT?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
    id?: IntFilter<"EncabezadoCompra"> | number
    fechaCompra?: DateTimeFilter<"EncabezadoCompra"> | Date | string
    idUsuarioProveedor?: IntFilter<"EncabezadoCompra"> | number
    idUsuarioRegistro?: IntFilter<"EncabezadoCompra"> | number
  }

  export type HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput = {
    where: HistorialWhereUniqueInput
    update: XOR<HistorialUpdateWithoutUsuarioRegistroInput, HistorialUncheckedUpdateWithoutUsuarioRegistroInput>
    create: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput>
  }

  export type HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput = {
    where: HistorialWhereUniqueInput
    data: XOR<HistorialUpdateWithoutUsuarioRegistroInput, HistorialUncheckedUpdateWithoutUsuarioRegistroInput>
  }

  export type HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput = {
    where: HistorialScalarWhereInput
    data: XOR<HistorialUpdateManyMutationInput, HistorialUncheckedUpdateManyWithoutUsuarioRegistroInput>
  }

  export type HistorialScalarWhereInput = {
    AND?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
    OR?: HistorialScalarWhereInput[]
    NOT?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
    id?: IntFilter<"Historial"> | number
    idBodega?: IntFilter<"Historial"> | number
    idUsuarioRegistro?: IntFilter<"Historial"> | number
    idProducto?: IntFilter<"Historial"> | number
    fechaAjuste?: DateTimeFilter<"Historial"> | Date | string
    justificacion?: StringFilter<"Historial"> | string
  }

  export type PedidoCreateWithoutEstadoPedidoInput = {
    fechaPedido?: Date | string
    observaciones?: string | null
    encabezadoCompras: EncabezadoCompraCreateNestedOneWithoutPedidosInput
    TrasladoBodegas?: TrasladoBodegasCreateNestedManyWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutEstadoPedidoInput = {
    idEncabezadoCompra: number
    fechaPedido?: Date | string
    observaciones?: string | null
    TrasladoBodegas?: TrasladoBodegasUncheckedCreateNestedManyWithoutPedidosInput
  }

  export type PedidoCreateOrConnectWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput>
  }

  export type PedidoCreateManyEstadoPedidoInputEnvelope = {
    data: PedidoCreateManyEstadoPedidoInput | PedidoCreateManyEstadoPedidoInput[]
    skipDuplicates?: boolean
  }

  export type TrasladoDestinoCreateWithoutEstadoDestinoInput = {
    fechaRecibido?: Date | string
    bodegas: BodegaCreateNestedOneWithoutTrasladoDestinoInput
    TrasladoBodegas?: TrasladoBodegasCreateNestedManyWithoutDestinosInput
  }

  export type TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput = {
    id?: number
    idBodegaDestino: number
    fechaRecibido?: Date | string
    TrasladoBodegas?: TrasladoBodegasUncheckedCreateNestedManyWithoutDestinosInput
  }

  export type TrasladoDestinoCreateOrConnectWithoutEstadoDestinoInput = {
    where: TrasladoDestinoWhereUniqueInput
    create: XOR<TrasladoDestinoCreateWithoutEstadoDestinoInput, TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput>
  }

  export type TrasladoDestinoCreateManyEstadoDestinoInputEnvelope = {
    data: TrasladoDestinoCreateManyEstadoDestinoInput | TrasladoDestinoCreateManyEstadoDestinoInput[]
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutEstadoPedidoInput, PedidoUncheckedUpdateWithoutEstadoPedidoInput>
    create: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutEstadoPedidoInput, PedidoUncheckedUpdateWithoutEstadoPedidoInput>
  }

  export type PedidoUpdateManyWithWhereWithoutEstadoPedidoInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutEstadoPedidoInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    OR?: PedidoScalarWhereInput[]
    NOT?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    idEncabezadoCompra?: IntFilter<"Pedido"> | number
    fechaPedido?: DateTimeFilter<"Pedido"> | Date | string
    idEstado?: IntFilter<"Pedido"> | number
    observaciones?: StringNullableFilter<"Pedido"> | string | null
  }

  export type TrasladoDestinoUpsertWithWhereUniqueWithoutEstadoDestinoInput = {
    where: TrasladoDestinoWhereUniqueInput
    update: XOR<TrasladoDestinoUpdateWithoutEstadoDestinoInput, TrasladoDestinoUncheckedUpdateWithoutEstadoDestinoInput>
    create: XOR<TrasladoDestinoCreateWithoutEstadoDestinoInput, TrasladoDestinoUncheckedCreateWithoutEstadoDestinoInput>
  }

  export type TrasladoDestinoUpdateWithWhereUniqueWithoutEstadoDestinoInput = {
    where: TrasladoDestinoWhereUniqueInput
    data: XOR<TrasladoDestinoUpdateWithoutEstadoDestinoInput, TrasladoDestinoUncheckedUpdateWithoutEstadoDestinoInput>
  }

  export type TrasladoDestinoUpdateManyWithWhereWithoutEstadoDestinoInput = {
    where: TrasladoDestinoScalarWhereInput
    data: XOR<TrasladoDestinoUpdateManyMutationInput, TrasladoDestinoUncheckedUpdateManyWithoutEstadoDestinoInput>
  }

  export type TrasladoDestinoScalarWhereInput = {
    AND?: TrasladoDestinoScalarWhereInput | TrasladoDestinoScalarWhereInput[]
    OR?: TrasladoDestinoScalarWhereInput[]
    NOT?: TrasladoDestinoScalarWhereInput | TrasladoDestinoScalarWhereInput[]
    id?: IntFilter<"TrasladoDestino"> | number
    idBodegaDestino?: IntFilter<"TrasladoDestino"> | number
    fechaRecibido?: DateTimeFilter<"TrasladoDestino"> | Date | string
    idEstado?: IntFilter<"TrasladoDestino"> | number
  }

  export type SubCategoriaCreateWithoutCategoriasInput = {
    nombre: string
    producto?: ProductoCreateNestedManyWithoutSubCategoriasInput
  }

  export type SubCategoriaUncheckedCreateWithoutCategoriasInput = {
    id?: number
    nombre: string
    producto?: ProductoUncheckedCreateNestedManyWithoutSubCategoriasInput
  }

  export type SubCategoriaCreateOrConnectWithoutCategoriasInput = {
    where: SubCategoriaWhereUniqueInput
    create: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput>
  }

  export type SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: SubCategoriaWhereUniqueInput
    update: XOR<SubCategoriaUpdateWithoutCategoriasInput, SubCategoriaUncheckedUpdateWithoutCategoriasInput>
    create: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput>
  }

  export type SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: SubCategoriaWhereUniqueInput
    data: XOR<SubCategoriaUpdateWithoutCategoriasInput, SubCategoriaUncheckedUpdateWithoutCategoriasInput>
  }

  export type SubCategoriaUpdateManyWithWhereWithoutCategoriasInput = {
    where: SubCategoriaScalarWhereInput
    data: XOR<SubCategoriaUpdateManyMutationInput, SubCategoriaUncheckedUpdateManyWithoutCategoriasInput>
  }

  export type SubCategoriaScalarWhereInput = {
    AND?: SubCategoriaScalarWhereInput | SubCategoriaScalarWhereInput[]
    OR?: SubCategoriaScalarWhereInput[]
    NOT?: SubCategoriaScalarWhereInput | SubCategoriaScalarWhereInput[]
    id?: IntFilter<"SubCategoria"> | number
    nombre?: StringFilter<"SubCategoria"> | string
  }

  export type ProductoCreateWithoutSubCategoriasInput = {
    codigoProducto: string
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    foto?: FotoCreateNestedManyWithoutProductosInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductosInput
    Historial?: HistorialCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutSubCategoriasInput = {
    id?: number
    codigoProducto: string
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedCreateNestedManyWithoutProductosInput
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductosInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoCreateOrConnectWithoutSubCategoriasInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput>
  }

  export type ProductoCreateManySubCategoriasInputEnvelope = {
    data: ProductoCreateManySubCategoriasInput | ProductoCreateManySubCategoriasInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaCreateWithoutSubCategoriaInput = {
    nombre: string
  }

  export type CategoriaUncheckedCreateWithoutSubCategoriaInput = {
    id?: number
    nombre: string
  }

  export type CategoriaCreateOrConnectWithoutSubCategoriaInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput>
  }

  export type ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutSubCategoriasInput, ProductoUncheckedUpdateWithoutSubCategoriasInput>
    create: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutSubCategoriasInput, ProductoUncheckedUpdateWithoutSubCategoriasInput>
  }

  export type ProductoUpdateManyWithWhereWithoutSubCategoriasInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutSubCategoriasInput>
  }

  export type ProductoScalarWhereInput = {
    AND?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    OR?: ProductoScalarWhereInput[]
    NOT?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    id?: IntFilter<"Producto"> | number
    codigoProducto?: StringFilter<"Producto"> | string
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    idSubCategoria?: IntFilter<"Producto"> | number
    stock?: IntFilter<"Producto"> | number
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
  }

  export type CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutSubCategoriaInput, CategoriaUncheckedUpdateWithoutSubCategoriaInput>
    create: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutSubCategoriaInput, CategoriaUncheckedUpdateWithoutSubCategoriaInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutSubCategoriaInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutSubCategoriaInput>
  }

  export type CategoriaScalarWhereInput = {
    AND?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
    OR?: CategoriaScalarWhereInput[]
    NOT?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nombre?: StringFilter<"Categoria"> | string
  }

  export type SubCategoriaCreateWithoutProductoInput = {
    nombre: string
    categorias?: CategoriaCreateNestedManyWithoutSubCategoriaInput
  }

  export type SubCategoriaUncheckedCreateWithoutProductoInput = {
    id?: number
    nombre: string
    categorias?: CategoriaUncheckedCreateNestedManyWithoutSubCategoriaInput
  }

  export type SubCategoriaCreateOrConnectWithoutProductoInput = {
    where: SubCategoriaWhereUniqueInput
    create: XOR<SubCategoriaCreateWithoutProductoInput, SubCategoriaUncheckedCreateWithoutProductoInput>
  }

  export type FotoCreateWithoutProductosInput = {
    foto: Buffer
  }

  export type FotoUncheckedCreateWithoutProductosInput = {
    id?: number
    foto: Buffer
  }

  export type FotoCreateOrConnectWithoutProductosInput = {
    where: FotoWhereUniqueInput
    create: XOR<FotoCreateWithoutProductosInput, FotoUncheckedCreateWithoutProductosInput>
  }

  export type FotoCreateManyProductosInputEnvelope = {
    data: FotoCreateManyProductosInput | FotoCreateManyProductosInput[]
    skipDuplicates?: boolean
  }

  export type BodegaProductosCreateWithoutProductoInput = {
    fechaRegistro?: Date | string
    cantidad: number
    bodegas: BodegaCreateNestedOneWithoutBodegaProductosInput
    usuario: UsuarioCreateNestedOneWithoutBodegaProductosInput
  }

  export type BodegaProductosUncheckedCreateWithoutProductoInput = {
    idBodega: number
    idUsuario: number
    fechaRegistro?: Date | string
    cantidad: number
  }

  export type BodegaProductosCreateOrConnectWithoutProductoInput = {
    where: BodegaProductosWhereUniqueInput
    create: XOR<BodegaProductosCreateWithoutProductoInput, BodegaProductosUncheckedCreateWithoutProductoInput>
  }

  export type BodegaProductosCreateManyProductoInputEnvelope = {
    data: BodegaProductosCreateManyProductoInput | BodegaProductosCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type DetalleCompraCreateWithoutProductosInput = {
    cantidad: number
    encabezadoCompras: EncabezadoCompraCreateNestedOneWithoutDetalleComprasInput
    bodegas: BodegaCreateNestedOneWithoutDetalleComprasInput
  }

  export type DetalleCompraUncheckedCreateWithoutProductosInput = {
    id?: number
    idEncabezadoCompra: number
    idBodega: number
    cantidad: number
  }

  export type DetalleCompraCreateOrConnectWithoutProductosInput = {
    where: DetalleCompraWhereUniqueInput
    create: XOR<DetalleCompraCreateWithoutProductosInput, DetalleCompraUncheckedCreateWithoutProductosInput>
  }

  export type DetalleCompraCreateManyProductosInputEnvelope = {
    data: DetalleCompraCreateManyProductosInput | DetalleCompraCreateManyProductosInput[]
    skipDuplicates?: boolean
  }

  export type HistorialCreateWithoutProductosInput = {
    fechaAjuste?: Date | string
    justificacion: string
    bodegas: BodegaCreateNestedOneWithoutHistorialInput
    UsuarioRegistro: UsuarioCreateNestedOneWithoutHistorialInput
  }

  export type HistorialUncheckedCreateWithoutProductosInput = {
    id?: number
    idBodega: number
    idUsuarioRegistro: number
    fechaAjuste?: Date | string
    justificacion: string
  }

  export type HistorialCreateOrConnectWithoutProductosInput = {
    where: HistorialWhereUniqueInput
    create: XOR<HistorialCreateWithoutProductosInput, HistorialUncheckedCreateWithoutProductosInput>
  }

  export type HistorialCreateManyProductosInputEnvelope = {
    data: HistorialCreateManyProductosInput | HistorialCreateManyProductosInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoriaUpsertWithoutProductoInput = {
    update: XOR<SubCategoriaUpdateWithoutProductoInput, SubCategoriaUncheckedUpdateWithoutProductoInput>
    create: XOR<SubCategoriaCreateWithoutProductoInput, SubCategoriaUncheckedCreateWithoutProductoInput>
    where?: SubCategoriaWhereInput
  }

  export type SubCategoriaUpdateToOneWithWhereWithoutProductoInput = {
    where?: SubCategoriaWhereInput
    data: XOR<SubCategoriaUpdateWithoutProductoInput, SubCategoriaUncheckedUpdateWithoutProductoInput>
  }

  export type SubCategoriaUpdateWithoutProductoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    categorias?: CategoriaUpdateManyWithoutSubCategoriaNestedInput
  }

  export type SubCategoriaUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    categorias?: CategoriaUncheckedUpdateManyWithoutSubCategoriaNestedInput
  }

  export type FotoUpsertWithWhereUniqueWithoutProductosInput = {
    where: FotoWhereUniqueInput
    update: XOR<FotoUpdateWithoutProductosInput, FotoUncheckedUpdateWithoutProductosInput>
    create: XOR<FotoCreateWithoutProductosInput, FotoUncheckedCreateWithoutProductosInput>
  }

  export type FotoUpdateWithWhereUniqueWithoutProductosInput = {
    where: FotoWhereUniqueInput
    data: XOR<FotoUpdateWithoutProductosInput, FotoUncheckedUpdateWithoutProductosInput>
  }

  export type FotoUpdateManyWithWhereWithoutProductosInput = {
    where: FotoScalarWhereInput
    data: XOR<FotoUpdateManyMutationInput, FotoUncheckedUpdateManyWithoutProductosInput>
  }

  export type FotoScalarWhereInput = {
    AND?: FotoScalarWhereInput | FotoScalarWhereInput[]
    OR?: FotoScalarWhereInput[]
    NOT?: FotoScalarWhereInput | FotoScalarWhereInput[]
    id?: IntFilter<"Foto"> | number
    idProducto?: IntFilter<"Foto"> | number
    foto?: BytesFilter<"Foto"> | Buffer
  }

  export type BodegaProductosUpsertWithWhereUniqueWithoutProductoInput = {
    where: BodegaProductosWhereUniqueInput
    update: XOR<BodegaProductosUpdateWithoutProductoInput, BodegaProductosUncheckedUpdateWithoutProductoInput>
    create: XOR<BodegaProductosCreateWithoutProductoInput, BodegaProductosUncheckedCreateWithoutProductoInput>
  }

  export type BodegaProductosUpdateWithWhereUniqueWithoutProductoInput = {
    where: BodegaProductosWhereUniqueInput
    data: XOR<BodegaProductosUpdateWithoutProductoInput, BodegaProductosUncheckedUpdateWithoutProductoInput>
  }

  export type BodegaProductosUpdateManyWithWhereWithoutProductoInput = {
    where: BodegaProductosScalarWhereInput
    data: XOR<BodegaProductosUpdateManyMutationInput, BodegaProductosUncheckedUpdateManyWithoutProductoInput>
  }

  export type DetalleCompraUpsertWithWhereUniqueWithoutProductosInput = {
    where: DetalleCompraWhereUniqueInput
    update: XOR<DetalleCompraUpdateWithoutProductosInput, DetalleCompraUncheckedUpdateWithoutProductosInput>
    create: XOR<DetalleCompraCreateWithoutProductosInput, DetalleCompraUncheckedCreateWithoutProductosInput>
  }

  export type DetalleCompraUpdateWithWhereUniqueWithoutProductosInput = {
    where: DetalleCompraWhereUniqueInput
    data: XOR<DetalleCompraUpdateWithoutProductosInput, DetalleCompraUncheckedUpdateWithoutProductosInput>
  }

  export type DetalleCompraUpdateManyWithWhereWithoutProductosInput = {
    where: DetalleCompraScalarWhereInput
    data: XOR<DetalleCompraUpdateManyMutationInput, DetalleCompraUncheckedUpdateManyWithoutProductosInput>
  }

  export type DetalleCompraScalarWhereInput = {
    AND?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
    OR?: DetalleCompraScalarWhereInput[]
    NOT?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
    id?: IntFilter<"DetalleCompra"> | number
    idEncabezadoCompra?: IntFilter<"DetalleCompra"> | number
    idProducto?: IntFilter<"DetalleCompra"> | number
    idBodega?: IntFilter<"DetalleCompra"> | number
    cantidad?: IntFilter<"DetalleCompra"> | number
  }

  export type HistorialUpsertWithWhereUniqueWithoutProductosInput = {
    where: HistorialWhereUniqueInput
    update: XOR<HistorialUpdateWithoutProductosInput, HistorialUncheckedUpdateWithoutProductosInput>
    create: XOR<HistorialCreateWithoutProductosInput, HistorialUncheckedCreateWithoutProductosInput>
  }

  export type HistorialUpdateWithWhereUniqueWithoutProductosInput = {
    where: HistorialWhereUniqueInput
    data: XOR<HistorialUpdateWithoutProductosInput, HistorialUncheckedUpdateWithoutProductosInput>
  }

  export type HistorialUpdateManyWithWhereWithoutProductosInput = {
    where: HistorialScalarWhereInput
    data: XOR<HistorialUpdateManyMutationInput, HistorialUncheckedUpdateManyWithoutProductosInput>
  }

  export type ProductoCreateWithoutFotoInput = {
    codigoProducto: string
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductosInput
    Historial?: HistorialCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutFotoInput = {
    id?: number
    codigoProducto: string
    nombre: string
    descripcion: string
    idSubCategoria: number
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductosInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoCreateOrConnectWithoutFotoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutFotoInput, ProductoUncheckedCreateWithoutFotoInput>
  }

  export type ProductoUpsertWithoutFotoInput = {
    update: XOR<ProductoUpdateWithoutFotoInput, ProductoUncheckedUpdateWithoutFotoInput>
    create: XOR<ProductoCreateWithoutFotoInput, ProductoUncheckedCreateWithoutFotoInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutFotoInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutFotoInput, ProductoUncheckedUpdateWithoutFotoInput>
  }

  export type ProductoUpdateWithoutFotoInput = {
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductosNestedInput
    Historial?: HistorialUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutFotoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductosNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type UsuarioCreateWithoutUbicacionInput = {
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutUsuarioInput
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioProveedorInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioUncheckedCreateWithoutUbicacionInput = {
    id?: number
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutUsuarioInput
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioProveedorInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioCreateOrConnectWithoutUbicacionInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutUbicacionInput, UsuarioUncheckedCreateWithoutUbicacionInput>
  }

  export type UsuarioCreateManyUbicacionInputEnvelope = {
    data: UsuarioCreateManyUbicacionInput | UsuarioCreateManyUbicacionInput[]
    skipDuplicates?: boolean
  }

  export type BodegaCreateWithoutUbicacionInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutBodegasInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutBodegasInput
    Historial?: HistorialCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoCreateNestedManyWithoutBodegasInput
  }

  export type BodegaUncheckedCreateWithoutUbicacionInput = {
    id?: number
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutBodegasInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoUncheckedCreateNestedManyWithoutBodegasInput
  }

  export type BodegaCreateOrConnectWithoutUbicacionInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput>
  }

  export type BodegaCreateManyUbicacionInputEnvelope = {
    data: BodegaCreateManyUbicacionInput | BodegaCreateManyUbicacionInput[]
    skipDuplicates?: boolean
  }

  export type ProvinciaCreateWithoutUbicacionInput = {
    nombre: string
    cantones?: CantonCreateNestedManyWithoutProvinciasInput
    distritos?: DistritoCreateNestedManyWithoutProvinciasInput
    barrios?: BarrioCreateNestedManyWithoutProvinciasInput
  }

  export type ProvinciaUncheckedCreateWithoutUbicacionInput = {
    nombre: string
    cantones?: CantonUncheckedCreateNestedManyWithoutProvinciasInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutProvinciasInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutProvinciasInput
  }

  export type ProvinciaCreateOrConnectWithoutUbicacionInput = {
    where: ProvinciaWhereUniqueInput
    create: XOR<ProvinciaCreateWithoutUbicacionInput, ProvinciaUncheckedCreateWithoutUbicacionInput>
  }

  export type ProvinciaCreateManyUbicacionInputEnvelope = {
    data: ProvinciaCreateManyUbicacionInput | ProvinciaCreateManyUbicacionInput[]
    skipDuplicates?: boolean
  }

  export type CantonCreateWithoutUbicacionInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutCantonesInput
    distritos?: DistritoCreateNestedManyWithoutCantonesInput
    barrios?: BarrioCreateNestedManyWithoutCantonesInput
  }

  export type CantonUncheckedCreateWithoutUbicacionInput = {
    idProvincia: number
    nombre: string
    distritos?: DistritoUncheckedCreateNestedManyWithoutCantonesInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutCantonesInput
  }

  export type CantonCreateOrConnectWithoutUbicacionInput = {
    where: CantonWhereUniqueInput
    create: XOR<CantonCreateWithoutUbicacionInput, CantonUncheckedCreateWithoutUbicacionInput>
  }

  export type CantonCreateManyUbicacionInputEnvelope = {
    data: CantonCreateManyUbicacionInput | CantonCreateManyUbicacionInput[]
    skipDuplicates?: boolean
  }

  export type DistritoCreateWithoutUbicacionInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutDistritosInput
    cantones: CantonCreateNestedOneWithoutDistritosInput
    barrios?: BarrioCreateNestedManyWithoutDistritosInput
  }

  export type DistritoUncheckedCreateWithoutUbicacionInput = {
    idProvincia: number
    idCanton: number
    nombre: string
    barrios?: BarrioUncheckedCreateNestedManyWithoutDistritosInput
  }

  export type DistritoCreateOrConnectWithoutUbicacionInput = {
    where: DistritoWhereUniqueInput
    create: XOR<DistritoCreateWithoutUbicacionInput, DistritoUncheckedCreateWithoutUbicacionInput>
  }

  export type DistritoCreateManyUbicacionInputEnvelope = {
    data: DistritoCreateManyUbicacionInput | DistritoCreateManyUbicacionInput[]
    skipDuplicates?: boolean
  }

  export type BarrioCreateWithoutUbicacionInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutBarriosInput
    cantones: CantonCreateNestedOneWithoutBarriosInput
    distritos: DistritoCreateNestedOneWithoutBarriosInput
  }

  export type BarrioUncheckedCreateWithoutUbicacionInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    nombre: string
  }

  export type BarrioCreateOrConnectWithoutUbicacionInput = {
    where: BarrioWhereUniqueInput
    create: XOR<BarrioCreateWithoutUbicacionInput, BarrioUncheckedCreateWithoutUbicacionInput>
  }

  export type BarrioCreateManyUbicacionInputEnvelope = {
    data: BarrioCreateManyUbicacionInput | BarrioCreateManyUbicacionInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutUbicacionInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutUbicacionInput, UsuarioUncheckedUpdateWithoutUbicacionInput>
    create: XOR<UsuarioCreateWithoutUbicacionInput, UsuarioUncheckedCreateWithoutUbicacionInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutUbicacionInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutUbicacionInput, UsuarioUncheckedUpdateWithoutUbicacionInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutUbicacionInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutUbicacionInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    nombreProveedor?: StringNullableFilter<"Usuario"> | string | null
    correo?: StringFilter<"Usuario"> | string
    contrasenna?: StringFilter<"Usuario"> | string
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    idUbicacion?: IntFilter<"Usuario"> | number
  }

  export type BodegaUpsertWithWhereUniqueWithoutUbicacionInput = {
    where: BodegaWhereUniqueInput
    update: XOR<BodegaUpdateWithoutUbicacionInput, BodegaUncheckedUpdateWithoutUbicacionInput>
    create: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput>
  }

  export type BodegaUpdateWithWhereUniqueWithoutUbicacionInput = {
    where: BodegaWhereUniqueInput
    data: XOR<BodegaUpdateWithoutUbicacionInput, BodegaUncheckedUpdateWithoutUbicacionInput>
  }

  export type BodegaUpdateManyWithWhereWithoutUbicacionInput = {
    where: BodegaScalarWhereInput
    data: XOR<BodegaUpdateManyMutationInput, BodegaUncheckedUpdateManyWithoutUbicacionInput>
  }

  export type BodegaScalarWhereInput = {
    AND?: BodegaScalarWhereInput | BodegaScalarWhereInput[]
    OR?: BodegaScalarWhereInput[]
    NOT?: BodegaScalarWhereInput | BodegaScalarWhereInput[]
    id?: IntFilter<"Bodega"> | number
    nombre?: StringFilter<"Bodega"> | string
    idUbicacion?: IntFilter<"Bodega"> | number
    tamanno?: FloatFilter<"Bodega"> | number
    capacidad?: FloatFilter<"Bodega"> | number
    seguridad?: BoolFilter<"Bodega"> | boolean
  }

  export type ProvinciaUpsertWithWhereUniqueWithoutUbicacionInput = {
    where: ProvinciaWhereUniqueInput
    update: XOR<ProvinciaUpdateWithoutUbicacionInput, ProvinciaUncheckedUpdateWithoutUbicacionInput>
    create: XOR<ProvinciaCreateWithoutUbicacionInput, ProvinciaUncheckedCreateWithoutUbicacionInput>
  }

  export type ProvinciaUpdateWithWhereUniqueWithoutUbicacionInput = {
    where: ProvinciaWhereUniqueInput
    data: XOR<ProvinciaUpdateWithoutUbicacionInput, ProvinciaUncheckedUpdateWithoutUbicacionInput>
  }

  export type ProvinciaUpdateManyWithWhereWithoutUbicacionInput = {
    where: ProvinciaScalarWhereInput
    data: XOR<ProvinciaUpdateManyMutationInput, ProvinciaUncheckedUpdateManyWithoutUbicacionInput>
  }

  export type ProvinciaScalarWhereInput = {
    AND?: ProvinciaScalarWhereInput | ProvinciaScalarWhereInput[]
    OR?: ProvinciaScalarWhereInput[]
    NOT?: ProvinciaScalarWhereInput | ProvinciaScalarWhereInput[]
    id?: IntFilter<"Provincia"> | number
    nombre?: StringFilter<"Provincia"> | string
  }

  export type CantonUpsertWithWhereUniqueWithoutUbicacionInput = {
    where: CantonWhereUniqueInput
    update: XOR<CantonUpdateWithoutUbicacionInput, CantonUncheckedUpdateWithoutUbicacionInput>
    create: XOR<CantonCreateWithoutUbicacionInput, CantonUncheckedCreateWithoutUbicacionInput>
  }

  export type CantonUpdateWithWhereUniqueWithoutUbicacionInput = {
    where: CantonWhereUniqueInput
    data: XOR<CantonUpdateWithoutUbicacionInput, CantonUncheckedUpdateWithoutUbicacionInput>
  }

  export type CantonUpdateManyWithWhereWithoutUbicacionInput = {
    where: CantonScalarWhereInput
    data: XOR<CantonUpdateManyMutationInput, CantonUncheckedUpdateManyWithoutUbicacionInput>
  }

  export type CantonScalarWhereInput = {
    AND?: CantonScalarWhereInput | CantonScalarWhereInput[]
    OR?: CantonScalarWhereInput[]
    NOT?: CantonScalarWhereInput | CantonScalarWhereInput[]
    id?: IntFilter<"Canton"> | number
    idProvincia?: IntFilter<"Canton"> | number
    nombre?: StringFilter<"Canton"> | string
  }

  export type DistritoUpsertWithWhereUniqueWithoutUbicacionInput = {
    where: DistritoWhereUniqueInput
    update: XOR<DistritoUpdateWithoutUbicacionInput, DistritoUncheckedUpdateWithoutUbicacionInput>
    create: XOR<DistritoCreateWithoutUbicacionInput, DistritoUncheckedCreateWithoutUbicacionInput>
  }

  export type DistritoUpdateWithWhereUniqueWithoutUbicacionInput = {
    where: DistritoWhereUniqueInput
    data: XOR<DistritoUpdateWithoutUbicacionInput, DistritoUncheckedUpdateWithoutUbicacionInput>
  }

  export type DistritoUpdateManyWithWhereWithoutUbicacionInput = {
    where: DistritoScalarWhereInput
    data: XOR<DistritoUpdateManyMutationInput, DistritoUncheckedUpdateManyWithoutUbicacionInput>
  }

  export type DistritoScalarWhereInput = {
    AND?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
    OR?: DistritoScalarWhereInput[]
    NOT?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
    id?: IntFilter<"Distrito"> | number
    idProvincia?: IntFilter<"Distrito"> | number
    idCanton?: IntFilter<"Distrito"> | number
    nombre?: StringFilter<"Distrito"> | string
  }

  export type BarrioUpsertWithWhereUniqueWithoutUbicacionInput = {
    where: BarrioWhereUniqueInput
    update: XOR<BarrioUpdateWithoutUbicacionInput, BarrioUncheckedUpdateWithoutUbicacionInput>
    create: XOR<BarrioCreateWithoutUbicacionInput, BarrioUncheckedCreateWithoutUbicacionInput>
  }

  export type BarrioUpdateWithWhereUniqueWithoutUbicacionInput = {
    where: BarrioWhereUniqueInput
    data: XOR<BarrioUpdateWithoutUbicacionInput, BarrioUncheckedUpdateWithoutUbicacionInput>
  }

  export type BarrioUpdateManyWithWhereWithoutUbicacionInput = {
    where: BarrioScalarWhereInput
    data: XOR<BarrioUpdateManyMutationInput, BarrioUncheckedUpdateManyWithoutUbicacionInput>
  }

  export type BarrioScalarWhereInput = {
    AND?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
    OR?: BarrioScalarWhereInput[]
    NOT?: BarrioScalarWhereInput | BarrioScalarWhereInput[]
    id?: IntFilter<"Barrio"> | number
    idProvincia?: IntFilter<"Barrio"> | number
    idCanton?: IntFilter<"Barrio"> | number
    idDistrito?: IntFilter<"Barrio"> | number
    nombre?: StringFilter<"Barrio"> | string
  }

  export type CantonCreateWithoutProvinciasInput = {
    nombre: string
    ubicacion?: UbicacionCreateNestedOneWithoutCantonesInput
    distritos?: DistritoCreateNestedManyWithoutCantonesInput
    barrios?: BarrioCreateNestedManyWithoutCantonesInput
  }

  export type CantonUncheckedCreateWithoutProvinciasInput = {
    id?: number
    nombre: string
    distritos?: DistritoUncheckedCreateNestedManyWithoutCantonesInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutCantonesInput
  }

  export type CantonCreateOrConnectWithoutProvinciasInput = {
    where: CantonWhereUniqueInput
    create: XOR<CantonCreateWithoutProvinciasInput, CantonUncheckedCreateWithoutProvinciasInput>
  }

  export type CantonCreateManyProvinciasInputEnvelope = {
    data: CantonCreateManyProvinciasInput | CantonCreateManyProvinciasInput[]
    skipDuplicates?: boolean
  }

  export type DistritoCreateWithoutProvinciasInput = {
    nombre: string
    cantones: CantonCreateNestedOneWithoutDistritosInput
    ubicacion?: UbicacionCreateNestedOneWithoutDistritosInput
    barrios?: BarrioCreateNestedManyWithoutDistritosInput
  }

  export type DistritoUncheckedCreateWithoutProvinciasInput = {
    id?: number
    idCanton: number
    nombre: string
    barrios?: BarrioUncheckedCreateNestedManyWithoutDistritosInput
  }

  export type DistritoCreateOrConnectWithoutProvinciasInput = {
    where: DistritoWhereUniqueInput
    create: XOR<DistritoCreateWithoutProvinciasInput, DistritoUncheckedCreateWithoutProvinciasInput>
  }

  export type DistritoCreateManyProvinciasInputEnvelope = {
    data: DistritoCreateManyProvinciasInput | DistritoCreateManyProvinciasInput[]
    skipDuplicates?: boolean
  }

  export type BarrioCreateWithoutProvinciasInput = {
    nombre: string
    cantones: CantonCreateNestedOneWithoutBarriosInput
    distritos: DistritoCreateNestedOneWithoutBarriosInput
    ubicacion?: UbicacionCreateNestedOneWithoutBarriosInput
  }

  export type BarrioUncheckedCreateWithoutProvinciasInput = {
    id?: number
    idCanton: number
    idDistrito: number
    nombre: string
  }

  export type BarrioCreateOrConnectWithoutProvinciasInput = {
    where: BarrioWhereUniqueInput
    create: XOR<BarrioCreateWithoutProvinciasInput, BarrioUncheckedCreateWithoutProvinciasInput>
  }

  export type BarrioCreateManyProvinciasInputEnvelope = {
    data: BarrioCreateManyProvinciasInput | BarrioCreateManyProvinciasInput[]
    skipDuplicates?: boolean
  }

  export type UbicacionCreateWithoutProvinciaInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaCreateNestedManyWithoutUbicacionInput
    cantones?: CantonCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateWithoutProvinciaInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioUncheckedCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaUncheckedCreateNestedManyWithoutUbicacionInput
    cantones?: CantonUncheckedCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionCreateOrConnectWithoutProvinciaInput = {
    where: UbicacionWhereUniqueInput
    create: XOR<UbicacionCreateWithoutProvinciaInput, UbicacionUncheckedCreateWithoutProvinciaInput>
  }

  export type CantonUpsertWithWhereUniqueWithoutProvinciasInput = {
    where: CantonWhereUniqueInput
    update: XOR<CantonUpdateWithoutProvinciasInput, CantonUncheckedUpdateWithoutProvinciasInput>
    create: XOR<CantonCreateWithoutProvinciasInput, CantonUncheckedCreateWithoutProvinciasInput>
  }

  export type CantonUpdateWithWhereUniqueWithoutProvinciasInput = {
    where: CantonWhereUniqueInput
    data: XOR<CantonUpdateWithoutProvinciasInput, CantonUncheckedUpdateWithoutProvinciasInput>
  }

  export type CantonUpdateManyWithWhereWithoutProvinciasInput = {
    where: CantonScalarWhereInput
    data: XOR<CantonUpdateManyMutationInput, CantonUncheckedUpdateManyWithoutProvinciasInput>
  }

  export type DistritoUpsertWithWhereUniqueWithoutProvinciasInput = {
    where: DistritoWhereUniqueInput
    update: XOR<DistritoUpdateWithoutProvinciasInput, DistritoUncheckedUpdateWithoutProvinciasInput>
    create: XOR<DistritoCreateWithoutProvinciasInput, DistritoUncheckedCreateWithoutProvinciasInput>
  }

  export type DistritoUpdateWithWhereUniqueWithoutProvinciasInput = {
    where: DistritoWhereUniqueInput
    data: XOR<DistritoUpdateWithoutProvinciasInput, DistritoUncheckedUpdateWithoutProvinciasInput>
  }

  export type DistritoUpdateManyWithWhereWithoutProvinciasInput = {
    where: DistritoScalarWhereInput
    data: XOR<DistritoUpdateManyMutationInput, DistritoUncheckedUpdateManyWithoutProvinciasInput>
  }

  export type BarrioUpsertWithWhereUniqueWithoutProvinciasInput = {
    where: BarrioWhereUniqueInput
    update: XOR<BarrioUpdateWithoutProvinciasInput, BarrioUncheckedUpdateWithoutProvinciasInput>
    create: XOR<BarrioCreateWithoutProvinciasInput, BarrioUncheckedCreateWithoutProvinciasInput>
  }

  export type BarrioUpdateWithWhereUniqueWithoutProvinciasInput = {
    where: BarrioWhereUniqueInput
    data: XOR<BarrioUpdateWithoutProvinciasInput, BarrioUncheckedUpdateWithoutProvinciasInput>
  }

  export type BarrioUpdateManyWithWhereWithoutProvinciasInput = {
    where: BarrioScalarWhereInput
    data: XOR<BarrioUpdateManyMutationInput, BarrioUncheckedUpdateManyWithoutProvinciasInput>
  }

  export type UbicacionUpsertWithoutProvinciaInput = {
    update: XOR<UbicacionUpdateWithoutProvinciaInput, UbicacionUncheckedUpdateWithoutProvinciaInput>
    create: XOR<UbicacionCreateWithoutProvinciaInput, UbicacionUncheckedCreateWithoutProvinciaInput>
    where?: UbicacionWhereInput
  }

  export type UbicacionUpdateToOneWithWhereWithoutProvinciaInput = {
    where?: UbicacionWhereInput
    data: XOR<UbicacionUpdateWithoutProvinciaInput, UbicacionUncheckedUpdateWithoutProvinciaInput>
  }

  export type UbicacionUpdateWithoutProvinciaInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateWithoutProvinciaInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUncheckedUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUncheckedUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUncheckedUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type ProvinciaCreateWithoutCantonesInput = {
    nombre: string
    distritos?: DistritoCreateNestedManyWithoutProvinciasInput
    barrios?: BarrioCreateNestedManyWithoutProvinciasInput
    ubicacion?: UbicacionCreateNestedOneWithoutProvinciaInput
  }

  export type ProvinciaUncheckedCreateWithoutCantonesInput = {
    id?: number
    nombre: string
    distritos?: DistritoUncheckedCreateNestedManyWithoutProvinciasInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutProvinciasInput
  }

  export type ProvinciaCreateOrConnectWithoutCantonesInput = {
    where: ProvinciaWhereUniqueInput
    create: XOR<ProvinciaCreateWithoutCantonesInput, ProvinciaUncheckedCreateWithoutCantonesInput>
  }

  export type UbicacionCreateWithoutCantonesInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateWithoutCantonesInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioUncheckedCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaUncheckedCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaUncheckedCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionCreateOrConnectWithoutCantonesInput = {
    where: UbicacionWhereUniqueInput
    create: XOR<UbicacionCreateWithoutCantonesInput, UbicacionUncheckedCreateWithoutCantonesInput>
  }

  export type DistritoCreateWithoutCantonesInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutDistritosInput
    ubicacion?: UbicacionCreateNestedOneWithoutDistritosInput
    barrios?: BarrioCreateNestedManyWithoutDistritosInput
  }

  export type DistritoUncheckedCreateWithoutCantonesInput = {
    id?: number
    idProvincia: number
    nombre: string
    barrios?: BarrioUncheckedCreateNestedManyWithoutDistritosInput
  }

  export type DistritoCreateOrConnectWithoutCantonesInput = {
    where: DistritoWhereUniqueInput
    create: XOR<DistritoCreateWithoutCantonesInput, DistritoUncheckedCreateWithoutCantonesInput>
  }

  export type DistritoCreateManyCantonesInputEnvelope = {
    data: DistritoCreateManyCantonesInput | DistritoCreateManyCantonesInput[]
    skipDuplicates?: boolean
  }

  export type BarrioCreateWithoutCantonesInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutBarriosInput
    distritos: DistritoCreateNestedOneWithoutBarriosInput
    ubicacion?: UbicacionCreateNestedOneWithoutBarriosInput
  }

  export type BarrioUncheckedCreateWithoutCantonesInput = {
    id?: number
    idProvincia: number
    idDistrito: number
    nombre: string
  }

  export type BarrioCreateOrConnectWithoutCantonesInput = {
    where: BarrioWhereUniqueInput
    create: XOR<BarrioCreateWithoutCantonesInput, BarrioUncheckedCreateWithoutCantonesInput>
  }

  export type BarrioCreateManyCantonesInputEnvelope = {
    data: BarrioCreateManyCantonesInput | BarrioCreateManyCantonesInput[]
    skipDuplicates?: boolean
  }

  export type ProvinciaUpsertWithoutCantonesInput = {
    update: XOR<ProvinciaUpdateWithoutCantonesInput, ProvinciaUncheckedUpdateWithoutCantonesInput>
    create: XOR<ProvinciaCreateWithoutCantonesInput, ProvinciaUncheckedCreateWithoutCantonesInput>
    where?: ProvinciaWhereInput
  }

  export type ProvinciaUpdateToOneWithWhereWithoutCantonesInput = {
    where?: ProvinciaWhereInput
    data: XOR<ProvinciaUpdateWithoutCantonesInput, ProvinciaUncheckedUpdateWithoutCantonesInput>
  }

  export type ProvinciaUpdateWithoutCantonesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    distritos?: DistritoUpdateManyWithoutProvinciasNestedInput
    barrios?: BarrioUpdateManyWithoutProvinciasNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateWithoutCantonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    distritos?: DistritoUncheckedUpdateManyWithoutProvinciasNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutProvinciasNestedInput
  }

  export type UbicacionUpsertWithoutCantonesInput = {
    update: XOR<UbicacionUpdateWithoutCantonesInput, UbicacionUncheckedUpdateWithoutCantonesInput>
    create: XOR<UbicacionCreateWithoutCantonesInput, UbicacionUncheckedCreateWithoutCantonesInput>
    where?: UbicacionWhereInput
  }

  export type UbicacionUpdateToOneWithWhereWithoutCantonesInput = {
    where?: UbicacionWhereInput
    data: XOR<UbicacionUpdateWithoutCantonesInput, UbicacionUncheckedUpdateWithoutCantonesInput>
  }

  export type UbicacionUpdateWithoutCantonesInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateWithoutCantonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUncheckedUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUncheckedUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUncheckedUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type DistritoUpsertWithWhereUniqueWithoutCantonesInput = {
    where: DistritoWhereUniqueInput
    update: XOR<DistritoUpdateWithoutCantonesInput, DistritoUncheckedUpdateWithoutCantonesInput>
    create: XOR<DistritoCreateWithoutCantonesInput, DistritoUncheckedCreateWithoutCantonesInput>
  }

  export type DistritoUpdateWithWhereUniqueWithoutCantonesInput = {
    where: DistritoWhereUniqueInput
    data: XOR<DistritoUpdateWithoutCantonesInput, DistritoUncheckedUpdateWithoutCantonesInput>
  }

  export type DistritoUpdateManyWithWhereWithoutCantonesInput = {
    where: DistritoScalarWhereInput
    data: XOR<DistritoUpdateManyMutationInput, DistritoUncheckedUpdateManyWithoutCantonesInput>
  }

  export type BarrioUpsertWithWhereUniqueWithoutCantonesInput = {
    where: BarrioWhereUniqueInput
    update: XOR<BarrioUpdateWithoutCantonesInput, BarrioUncheckedUpdateWithoutCantonesInput>
    create: XOR<BarrioCreateWithoutCantonesInput, BarrioUncheckedCreateWithoutCantonesInput>
  }

  export type BarrioUpdateWithWhereUniqueWithoutCantonesInput = {
    where: BarrioWhereUniqueInput
    data: XOR<BarrioUpdateWithoutCantonesInput, BarrioUncheckedUpdateWithoutCantonesInput>
  }

  export type BarrioUpdateManyWithWhereWithoutCantonesInput = {
    where: BarrioScalarWhereInput
    data: XOR<BarrioUpdateManyMutationInput, BarrioUncheckedUpdateManyWithoutCantonesInput>
  }

  export type ProvinciaCreateWithoutDistritosInput = {
    nombre: string
    cantones?: CantonCreateNestedManyWithoutProvinciasInput
    barrios?: BarrioCreateNestedManyWithoutProvinciasInput
    ubicacion?: UbicacionCreateNestedOneWithoutProvinciaInput
  }

  export type ProvinciaUncheckedCreateWithoutDistritosInput = {
    id?: number
    nombre: string
    cantones?: CantonUncheckedCreateNestedManyWithoutProvinciasInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutProvinciasInput
  }

  export type ProvinciaCreateOrConnectWithoutDistritosInput = {
    where: ProvinciaWhereUniqueInput
    create: XOR<ProvinciaCreateWithoutDistritosInput, ProvinciaUncheckedCreateWithoutDistritosInput>
  }

  export type CantonCreateWithoutDistritosInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutCantonesInput
    ubicacion?: UbicacionCreateNestedOneWithoutCantonesInput
    barrios?: BarrioCreateNestedManyWithoutCantonesInput
  }

  export type CantonUncheckedCreateWithoutDistritosInput = {
    id?: number
    idProvincia: number
    nombre: string
    barrios?: BarrioUncheckedCreateNestedManyWithoutCantonesInput
  }

  export type CantonCreateOrConnectWithoutDistritosInput = {
    where: CantonWhereUniqueInput
    create: XOR<CantonCreateWithoutDistritosInput, CantonUncheckedCreateWithoutDistritosInput>
  }

  export type UbicacionCreateWithoutDistritosInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaCreateNestedManyWithoutUbicacionInput
    cantones?: CantonCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateWithoutDistritosInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioUncheckedCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaUncheckedCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaUncheckedCreateNestedManyWithoutUbicacionInput
    cantones?: CantonUncheckedCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionCreateOrConnectWithoutDistritosInput = {
    where: UbicacionWhereUniqueInput
    create: XOR<UbicacionCreateWithoutDistritosInput, UbicacionUncheckedCreateWithoutDistritosInput>
  }

  export type BarrioCreateWithoutDistritosInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutBarriosInput
    cantones: CantonCreateNestedOneWithoutBarriosInput
    ubicacion?: UbicacionCreateNestedOneWithoutBarriosInput
  }

  export type BarrioUncheckedCreateWithoutDistritosInput = {
    id?: number
    idProvincia: number
    idCanton: number
    nombre: string
  }

  export type BarrioCreateOrConnectWithoutDistritosInput = {
    where: BarrioWhereUniqueInput
    create: XOR<BarrioCreateWithoutDistritosInput, BarrioUncheckedCreateWithoutDistritosInput>
  }

  export type BarrioCreateManyDistritosInputEnvelope = {
    data: BarrioCreateManyDistritosInput | BarrioCreateManyDistritosInput[]
    skipDuplicates?: boolean
  }

  export type ProvinciaUpsertWithoutDistritosInput = {
    update: XOR<ProvinciaUpdateWithoutDistritosInput, ProvinciaUncheckedUpdateWithoutDistritosInput>
    create: XOR<ProvinciaCreateWithoutDistritosInput, ProvinciaUncheckedCreateWithoutDistritosInput>
    where?: ProvinciaWhereInput
  }

  export type ProvinciaUpdateToOneWithWhereWithoutDistritosInput = {
    where?: ProvinciaWhereInput
    data: XOR<ProvinciaUpdateWithoutDistritosInput, ProvinciaUncheckedUpdateWithoutDistritosInput>
  }

  export type ProvinciaUpdateWithoutDistritosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUpdateManyWithoutProvinciasNestedInput
    barrios?: BarrioUpdateManyWithoutProvinciasNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateWithoutDistritosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUncheckedUpdateManyWithoutProvinciasNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutProvinciasNestedInput
  }

  export type CantonUpsertWithoutDistritosInput = {
    update: XOR<CantonUpdateWithoutDistritosInput, CantonUncheckedUpdateWithoutDistritosInput>
    create: XOR<CantonCreateWithoutDistritosInput, CantonUncheckedCreateWithoutDistritosInput>
    where?: CantonWhereInput
  }

  export type CantonUpdateToOneWithWhereWithoutDistritosInput = {
    where?: CantonWhereInput
    data: XOR<CantonUpdateWithoutDistritosInput, CantonUncheckedUpdateWithoutDistritosInput>
  }

  export type CantonUpdateWithoutDistritosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutCantonesNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutCantonesNestedInput
    barrios?: BarrioUpdateManyWithoutCantonesNestedInput
  }

  export type CantonUncheckedUpdateWithoutDistritosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    barrios?: BarrioUncheckedUpdateManyWithoutCantonesNestedInput
  }

  export type UbicacionUpsertWithoutDistritosInput = {
    update: XOR<UbicacionUpdateWithoutDistritosInput, UbicacionUncheckedUpdateWithoutDistritosInput>
    create: XOR<UbicacionCreateWithoutDistritosInput, UbicacionUncheckedCreateWithoutDistritosInput>
    where?: UbicacionWhereInput
  }

  export type UbicacionUpdateToOneWithWhereWithoutDistritosInput = {
    where?: UbicacionWhereInput
    data: XOR<UbicacionUpdateWithoutDistritosInput, UbicacionUncheckedUpdateWithoutDistritosInput>
  }

  export type UbicacionUpdateWithoutDistritosInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateWithoutDistritosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUncheckedUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUncheckedUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUncheckedUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUncheckedUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type BarrioUpsertWithWhereUniqueWithoutDistritosInput = {
    where: BarrioWhereUniqueInput
    update: XOR<BarrioUpdateWithoutDistritosInput, BarrioUncheckedUpdateWithoutDistritosInput>
    create: XOR<BarrioCreateWithoutDistritosInput, BarrioUncheckedCreateWithoutDistritosInput>
  }

  export type BarrioUpdateWithWhereUniqueWithoutDistritosInput = {
    where: BarrioWhereUniqueInput
    data: XOR<BarrioUpdateWithoutDistritosInput, BarrioUncheckedUpdateWithoutDistritosInput>
  }

  export type BarrioUpdateManyWithWhereWithoutDistritosInput = {
    where: BarrioScalarWhereInput
    data: XOR<BarrioUpdateManyMutationInput, BarrioUncheckedUpdateManyWithoutDistritosInput>
  }

  export type ProvinciaCreateWithoutBarriosInput = {
    nombre: string
    cantones?: CantonCreateNestedManyWithoutProvinciasInput
    distritos?: DistritoCreateNestedManyWithoutProvinciasInput
    ubicacion?: UbicacionCreateNestedOneWithoutProvinciaInput
  }

  export type ProvinciaUncheckedCreateWithoutBarriosInput = {
    id?: number
    nombre: string
    cantones?: CantonUncheckedCreateNestedManyWithoutProvinciasInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutProvinciasInput
  }

  export type ProvinciaCreateOrConnectWithoutBarriosInput = {
    where: ProvinciaWhereUniqueInput
    create: XOR<ProvinciaCreateWithoutBarriosInput, ProvinciaUncheckedCreateWithoutBarriosInput>
  }

  export type CantonCreateWithoutBarriosInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutCantonesInput
    ubicacion?: UbicacionCreateNestedOneWithoutCantonesInput
    distritos?: DistritoCreateNestedManyWithoutCantonesInput
  }

  export type CantonUncheckedCreateWithoutBarriosInput = {
    id?: number
    idProvincia: number
    nombre: string
    distritos?: DistritoUncheckedCreateNestedManyWithoutCantonesInput
  }

  export type CantonCreateOrConnectWithoutBarriosInput = {
    where: CantonWhereUniqueInput
    create: XOR<CantonCreateWithoutBarriosInput, CantonUncheckedCreateWithoutBarriosInput>
  }

  export type DistritoCreateWithoutBarriosInput = {
    nombre: string
    provincias: ProvinciaCreateNestedOneWithoutDistritosInput
    cantones: CantonCreateNestedOneWithoutDistritosInput
    ubicacion?: UbicacionCreateNestedOneWithoutDistritosInput
  }

  export type DistritoUncheckedCreateWithoutBarriosInput = {
    id?: number
    idProvincia: number
    idCanton: number
    nombre: string
  }

  export type DistritoCreateOrConnectWithoutBarriosInput = {
    where: DistritoWhereUniqueInput
    create: XOR<DistritoCreateWithoutBarriosInput, DistritoUncheckedCreateWithoutBarriosInput>
  }

  export type UbicacionCreateWithoutBarriosInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaCreateNestedManyWithoutUbicacionInput
    cantones?: CantonCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateWithoutBarriosInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioUncheckedCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaUncheckedCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaUncheckedCreateNestedManyWithoutUbicacionInput
    cantones?: CantonUncheckedCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionCreateOrConnectWithoutBarriosInput = {
    where: UbicacionWhereUniqueInput
    create: XOR<UbicacionCreateWithoutBarriosInput, UbicacionUncheckedCreateWithoutBarriosInput>
  }

  export type ProvinciaUpsertWithoutBarriosInput = {
    update: XOR<ProvinciaUpdateWithoutBarriosInput, ProvinciaUncheckedUpdateWithoutBarriosInput>
    create: XOR<ProvinciaCreateWithoutBarriosInput, ProvinciaUncheckedCreateWithoutBarriosInput>
    where?: ProvinciaWhereInput
  }

  export type ProvinciaUpdateToOneWithWhereWithoutBarriosInput = {
    where?: ProvinciaWhereInput
    data: XOR<ProvinciaUpdateWithoutBarriosInput, ProvinciaUncheckedUpdateWithoutBarriosInput>
  }

  export type ProvinciaUpdateWithoutBarriosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUpdateManyWithoutProvinciasNestedInput
    distritos?: DistritoUpdateManyWithoutProvinciasNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateWithoutBarriosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUncheckedUpdateManyWithoutProvinciasNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutProvinciasNestedInput
  }

  export type CantonUpsertWithoutBarriosInput = {
    update: XOR<CantonUpdateWithoutBarriosInput, CantonUncheckedUpdateWithoutBarriosInput>
    create: XOR<CantonCreateWithoutBarriosInput, CantonUncheckedCreateWithoutBarriosInput>
    where?: CantonWhereInput
  }

  export type CantonUpdateToOneWithWhereWithoutBarriosInput = {
    where?: CantonWhereInput
    data: XOR<CantonUpdateWithoutBarriosInput, CantonUncheckedUpdateWithoutBarriosInput>
  }

  export type CantonUpdateWithoutBarriosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutCantonesNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutCantonesNestedInput
    distritos?: DistritoUpdateManyWithoutCantonesNestedInput
  }

  export type CantonUncheckedUpdateWithoutBarriosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    distritos?: DistritoUncheckedUpdateManyWithoutCantonesNestedInput
  }

  export type DistritoUpsertWithoutBarriosInput = {
    update: XOR<DistritoUpdateWithoutBarriosInput, DistritoUncheckedUpdateWithoutBarriosInput>
    create: XOR<DistritoCreateWithoutBarriosInput, DistritoUncheckedCreateWithoutBarriosInput>
    where?: DistritoWhereInput
  }

  export type DistritoUpdateToOneWithWhereWithoutBarriosInput = {
    where?: DistritoWhereInput
    data: XOR<DistritoUpdateWithoutBarriosInput, DistritoUncheckedUpdateWithoutBarriosInput>
  }

  export type DistritoUpdateWithoutBarriosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutDistritosNestedInput
    cantones?: CantonUpdateOneRequiredWithoutDistritosNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateWithoutBarriosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UbicacionUpsertWithoutBarriosInput = {
    update: XOR<UbicacionUpdateWithoutBarriosInput, UbicacionUncheckedUpdateWithoutBarriosInput>
    create: XOR<UbicacionCreateWithoutBarriosInput, UbicacionUncheckedCreateWithoutBarriosInput>
    where?: UbicacionWhereInput
  }

  export type UbicacionUpdateToOneWithWhereWithoutBarriosInput = {
    where?: UbicacionWhereInput
    data: XOR<UbicacionUpdateWithoutBarriosInput, UbicacionUncheckedUpdateWithoutBarriosInput>
  }

  export type UbicacionUpdateWithoutBarriosInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateWithoutBarriosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUncheckedUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUncheckedUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUncheckedUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUncheckedUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionCreateWithoutBodegaInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaCreateNestedManyWithoutUbicacionInput
    cantones?: CantonCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateWithoutBodegaInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    idBarrio: number
    usuario?: UsuarioUncheckedCreateNestedManyWithoutUbicacionInput
    provincia?: ProvinciaUncheckedCreateNestedManyWithoutUbicacionInput
    cantones?: CantonUncheckedCreateNestedManyWithoutUbicacionInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutUbicacionInput
    barrios?: BarrioUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionCreateOrConnectWithoutBodegaInput = {
    where: UbicacionWhereUniqueInput
    create: XOR<UbicacionCreateWithoutBodegaInput, UbicacionUncheckedCreateWithoutBodegaInput>
  }

  export type BodegaProductosCreateWithoutBodegasInput = {
    fechaRegistro?: Date | string
    cantidad: number
    producto: ProductoCreateNestedOneWithoutBodegaProductosInput
    usuario: UsuarioCreateNestedOneWithoutBodegaProductosInput
  }

  export type BodegaProductosUncheckedCreateWithoutBodegasInput = {
    idProducto: number
    idUsuario: number
    fechaRegistro?: Date | string
    cantidad: number
  }

  export type BodegaProductosCreateOrConnectWithoutBodegasInput = {
    where: BodegaProductosWhereUniqueInput
    create: XOR<BodegaProductosCreateWithoutBodegasInput, BodegaProductosUncheckedCreateWithoutBodegasInput>
  }

  export type BodegaProductosCreateManyBodegasInputEnvelope = {
    data: BodegaProductosCreateManyBodegasInput | BodegaProductosCreateManyBodegasInput[]
    skipDuplicates?: boolean
  }

  export type DetalleCompraCreateWithoutBodegasInput = {
    cantidad: number
    productos: ProductoCreateNestedOneWithoutDetalleComprasInput
    encabezadoCompras: EncabezadoCompraCreateNestedOneWithoutDetalleComprasInput
  }

  export type DetalleCompraUncheckedCreateWithoutBodegasInput = {
    id?: number
    idEncabezadoCompra: number
    idProducto: number
    cantidad: number
  }

  export type DetalleCompraCreateOrConnectWithoutBodegasInput = {
    where: DetalleCompraWhereUniqueInput
    create: XOR<DetalleCompraCreateWithoutBodegasInput, DetalleCompraUncheckedCreateWithoutBodegasInput>
  }

  export type DetalleCompraCreateManyBodegasInputEnvelope = {
    data: DetalleCompraCreateManyBodegasInput | DetalleCompraCreateManyBodegasInput[]
    skipDuplicates?: boolean
  }

  export type HistorialCreateWithoutBodegasInput = {
    fechaAjuste?: Date | string
    justificacion: string
    UsuarioRegistro: UsuarioCreateNestedOneWithoutHistorialInput
    productos: ProductoCreateNestedOneWithoutHistorialInput
  }

  export type HistorialUncheckedCreateWithoutBodegasInput = {
    id?: number
    idUsuarioRegistro: number
    idProducto: number
    fechaAjuste?: Date | string
    justificacion: string
  }

  export type HistorialCreateOrConnectWithoutBodegasInput = {
    where: HistorialWhereUniqueInput
    create: XOR<HistorialCreateWithoutBodegasInput, HistorialUncheckedCreateWithoutBodegasInput>
  }

  export type HistorialCreateManyBodegasInputEnvelope = {
    data: HistorialCreateManyBodegasInput | HistorialCreateManyBodegasInput[]
    skipDuplicates?: boolean
  }

  export type TrasladoDestinoCreateWithoutBodegasInput = {
    fechaRecibido?: Date | string
    estadoDestino: EstadoCreateNestedOneWithoutTrasladoDestinoInput
    TrasladoBodegas?: TrasladoBodegasCreateNestedManyWithoutDestinosInput
  }

  export type TrasladoDestinoUncheckedCreateWithoutBodegasInput = {
    id?: number
    fechaRecibido?: Date | string
    idEstado: number
    TrasladoBodegas?: TrasladoBodegasUncheckedCreateNestedManyWithoutDestinosInput
  }

  export type TrasladoDestinoCreateOrConnectWithoutBodegasInput = {
    where: TrasladoDestinoWhereUniqueInput
    create: XOR<TrasladoDestinoCreateWithoutBodegasInput, TrasladoDestinoUncheckedCreateWithoutBodegasInput>
  }

  export type TrasladoDestinoCreateManyBodegasInputEnvelope = {
    data: TrasladoDestinoCreateManyBodegasInput | TrasladoDestinoCreateManyBodegasInput[]
    skipDuplicates?: boolean
  }

  export type UbicacionUpsertWithoutBodegaInput = {
    update: XOR<UbicacionUpdateWithoutBodegaInput, UbicacionUncheckedUpdateWithoutBodegaInput>
    create: XOR<UbicacionCreateWithoutBodegaInput, UbicacionUncheckedCreateWithoutBodegaInput>
    where?: UbicacionWhereInput
  }

  export type UbicacionUpdateToOneWithWhereWithoutBodegaInput = {
    where?: UbicacionWhereInput
    data: XOR<UbicacionUpdateWithoutBodegaInput, UbicacionUncheckedUpdateWithoutBodegaInput>
  }

  export type UbicacionUpdateWithoutBodegaInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateWithoutBodegaInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    idBarrio?: IntFieldUpdateOperationsInput | number
    usuario?: UsuarioUncheckedUpdateManyWithoutUbicacionNestedInput
    provincia?: ProvinciaUncheckedUpdateManyWithoutUbicacionNestedInput
    cantones?: CantonUncheckedUpdateManyWithoutUbicacionNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutUbicacionNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type BodegaProductosUpsertWithWhereUniqueWithoutBodegasInput = {
    where: BodegaProductosWhereUniqueInput
    update: XOR<BodegaProductosUpdateWithoutBodegasInput, BodegaProductosUncheckedUpdateWithoutBodegasInput>
    create: XOR<BodegaProductosCreateWithoutBodegasInput, BodegaProductosUncheckedCreateWithoutBodegasInput>
  }

  export type BodegaProductosUpdateWithWhereUniqueWithoutBodegasInput = {
    where: BodegaProductosWhereUniqueInput
    data: XOR<BodegaProductosUpdateWithoutBodegasInput, BodegaProductosUncheckedUpdateWithoutBodegasInput>
  }

  export type BodegaProductosUpdateManyWithWhereWithoutBodegasInput = {
    where: BodegaProductosScalarWhereInput
    data: XOR<BodegaProductosUpdateManyMutationInput, BodegaProductosUncheckedUpdateManyWithoutBodegasInput>
  }

  export type DetalleCompraUpsertWithWhereUniqueWithoutBodegasInput = {
    where: DetalleCompraWhereUniqueInput
    update: XOR<DetalleCompraUpdateWithoutBodegasInput, DetalleCompraUncheckedUpdateWithoutBodegasInput>
    create: XOR<DetalleCompraCreateWithoutBodegasInput, DetalleCompraUncheckedCreateWithoutBodegasInput>
  }

  export type DetalleCompraUpdateWithWhereUniqueWithoutBodegasInput = {
    where: DetalleCompraWhereUniqueInput
    data: XOR<DetalleCompraUpdateWithoutBodegasInput, DetalleCompraUncheckedUpdateWithoutBodegasInput>
  }

  export type DetalleCompraUpdateManyWithWhereWithoutBodegasInput = {
    where: DetalleCompraScalarWhereInput
    data: XOR<DetalleCompraUpdateManyMutationInput, DetalleCompraUncheckedUpdateManyWithoutBodegasInput>
  }

  export type HistorialUpsertWithWhereUniqueWithoutBodegasInput = {
    where: HistorialWhereUniqueInput
    update: XOR<HistorialUpdateWithoutBodegasInput, HistorialUncheckedUpdateWithoutBodegasInput>
    create: XOR<HistorialCreateWithoutBodegasInput, HistorialUncheckedCreateWithoutBodegasInput>
  }

  export type HistorialUpdateWithWhereUniqueWithoutBodegasInput = {
    where: HistorialWhereUniqueInput
    data: XOR<HistorialUpdateWithoutBodegasInput, HistorialUncheckedUpdateWithoutBodegasInput>
  }

  export type HistorialUpdateManyWithWhereWithoutBodegasInput = {
    where: HistorialScalarWhereInput
    data: XOR<HistorialUpdateManyMutationInput, HistorialUncheckedUpdateManyWithoutBodegasInput>
  }

  export type TrasladoDestinoUpsertWithWhereUniqueWithoutBodegasInput = {
    where: TrasladoDestinoWhereUniqueInput
    update: XOR<TrasladoDestinoUpdateWithoutBodegasInput, TrasladoDestinoUncheckedUpdateWithoutBodegasInput>
    create: XOR<TrasladoDestinoCreateWithoutBodegasInput, TrasladoDestinoUncheckedCreateWithoutBodegasInput>
  }

  export type TrasladoDestinoUpdateWithWhereUniqueWithoutBodegasInput = {
    where: TrasladoDestinoWhereUniqueInput
    data: XOR<TrasladoDestinoUpdateWithoutBodegasInput, TrasladoDestinoUncheckedUpdateWithoutBodegasInput>
  }

  export type TrasladoDestinoUpdateManyWithWhereWithoutBodegasInput = {
    where: TrasladoDestinoScalarWhereInput
    data: XOR<TrasladoDestinoUpdateManyMutationInput, TrasladoDestinoUncheckedUpdateManyWithoutBodegasInput>
  }

  export type BodegaCreateWithoutBodegaProductosInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutBodegasInput
    Historial?: HistorialCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoCreateNestedManyWithoutBodegasInput
  }

  export type BodegaUncheckedCreateWithoutBodegaProductosInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutBodegasInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoUncheckedCreateNestedManyWithoutBodegasInput
  }

  export type BodegaCreateOrConnectWithoutBodegaProductosInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutBodegaProductosInput, BodegaUncheckedCreateWithoutBodegaProductosInput>
  }

  export type ProductoCreateWithoutBodegaProductosInput = {
    codigoProducto: string
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductosInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductosInput
    Historial?: HistorialCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutBodegaProductosInput = {
    id?: number
    codigoProducto: string
    nombre: string
    descripcion: string
    idSubCategoria: number
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedCreateNestedManyWithoutProductosInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductosInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoCreateOrConnectWithoutBodegaProductosInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutBodegaProductosInput, ProductoUncheckedCreateWithoutBodegaProductosInput>
  }

  export type UsuarioCreateWithoutBodegaProductosInput = {
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    ubicacion: UbicacionCreateNestedOneWithoutUsuarioInput
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioProveedorInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioUncheckedCreateWithoutBodegaProductosInput = {
    id?: number
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    idUbicacion: number
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioProveedorInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioCreateOrConnectWithoutBodegaProductosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutBodegaProductosInput, UsuarioUncheckedCreateWithoutBodegaProductosInput>
  }

  export type BodegaUpsertWithoutBodegaProductosInput = {
    update: XOR<BodegaUpdateWithoutBodegaProductosInput, BodegaUncheckedUpdateWithoutBodegaProductosInput>
    create: XOR<BodegaCreateWithoutBodegaProductosInput, BodegaUncheckedCreateWithoutBodegaProductosInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutBodegaProductosInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutBodegaProductosInput, BodegaUncheckedUpdateWithoutBodegaProductosInput>
  }

  export type BodegaUpdateWithoutBodegaProductosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUpdateManyWithoutBodegasNestedInput
  }

  export type BodegaUncheckedUpdateWithoutBodegaProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUncheckedUpdateManyWithoutBodegasNestedInput
  }

  export type ProductoUpsertWithoutBodegaProductosInput = {
    update: XOR<ProductoUpdateWithoutBodegaProductosInput, ProductoUncheckedUpdateWithoutBodegaProductosInput>
    create: XOR<ProductoCreateWithoutBodegaProductosInput, ProductoUncheckedCreateWithoutBodegaProductosInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutBodegaProductosInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutBodegaProductosInput, ProductoUncheckedUpdateWithoutBodegaProductosInput>
  }

  export type ProductoUpdateWithoutBodegaProductosInput = {
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductosNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductosNestedInput
    Historial?: HistorialUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutBodegaProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedUpdateManyWithoutProductosNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductosNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type UsuarioUpsertWithoutBodegaProductosInput = {
    update: XOR<UsuarioUpdateWithoutBodegaProductosInput, UsuarioUncheckedUpdateWithoutBodegaProductosInput>
    create: XOR<UsuarioCreateWithoutBodegaProductosInput, UsuarioUncheckedCreateWithoutBodegaProductosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutBodegaProductosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutBodegaProductosInput, UsuarioUncheckedUpdateWithoutBodegaProductosInput>
  }

  export type UsuarioUpdateWithoutBodegaProductosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ubicacion?: UbicacionUpdateOneRequiredWithoutUsuarioNestedInput
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioProveedorNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutBodegaProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idUbicacion?: IntFieldUpdateOperationsInput | number
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioProveedorNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type UsuarioCreateWithoutEncabezadoComprasInput = {
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    ubicacion: UbicacionCreateNestedOneWithoutUsuarioInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioUncheckedCreateWithoutEncabezadoComprasInput = {
    id?: number
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    idUbicacion: number
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioCreateOrConnectWithoutEncabezadoComprasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEncabezadoComprasInput, UsuarioUncheckedCreateWithoutEncabezadoComprasInput>
  }

  export type DetalleCompraCreateWithoutEncabezadoComprasInput = {
    cantidad: number
    productos: ProductoCreateNestedOneWithoutDetalleComprasInput
    bodegas: BodegaCreateNestedOneWithoutDetalleComprasInput
  }

  export type DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput = {
    id?: number
    idProducto: number
    idBodega: number
    cantidad: number
  }

  export type DetalleCompraCreateOrConnectWithoutEncabezadoComprasInput = {
    where: DetalleCompraWhereUniqueInput
    create: XOR<DetalleCompraCreateWithoutEncabezadoComprasInput, DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput>
  }

  export type DetalleCompraCreateManyEncabezadoComprasInputEnvelope = {
    data: DetalleCompraCreateManyEncabezadoComprasInput | DetalleCompraCreateManyEncabezadoComprasInput[]
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutEncabezadoComprasInput = {
    fechaPedido?: Date | string
    observaciones?: string | null
    estadoPedido: EstadoCreateNestedOneWithoutPedidosInput
    TrasladoBodegas?: TrasladoBodegasCreateNestedManyWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutEncabezadoComprasInput = {
    fechaPedido?: Date | string
    idEstado: number
    observaciones?: string | null
    TrasladoBodegas?: TrasladoBodegasUncheckedCreateNestedManyWithoutPedidosInput
  }

  export type PedidoCreateOrConnectWithoutEncabezadoComprasInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutEncabezadoComprasInput, PedidoUncheckedCreateWithoutEncabezadoComprasInput>
  }

  export type PedidoCreateManyEncabezadoComprasInputEnvelope = {
    data: PedidoCreateManyEncabezadoComprasInput | PedidoCreateManyEncabezadoComprasInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutEncabezadoComprasInput = {
    update: XOR<UsuarioUpdateWithoutEncabezadoComprasInput, UsuarioUncheckedUpdateWithoutEncabezadoComprasInput>
    create: XOR<UsuarioCreateWithoutEncabezadoComprasInput, UsuarioUncheckedCreateWithoutEncabezadoComprasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEncabezadoComprasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEncabezadoComprasInput, UsuarioUncheckedUpdateWithoutEncabezadoComprasInput>
  }

  export type UsuarioUpdateWithoutEncabezadoComprasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ubicacion?: UbicacionUpdateOneRequiredWithoutUsuarioNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEncabezadoComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idUbicacion?: IntFieldUpdateOperationsInput | number
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoComprasInput = {
    where: DetalleCompraWhereUniqueInput
    update: XOR<DetalleCompraUpdateWithoutEncabezadoComprasInput, DetalleCompraUncheckedUpdateWithoutEncabezadoComprasInput>
    create: XOR<DetalleCompraCreateWithoutEncabezadoComprasInput, DetalleCompraUncheckedCreateWithoutEncabezadoComprasInput>
  }

  export type DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoComprasInput = {
    where: DetalleCompraWhereUniqueInput
    data: XOR<DetalleCompraUpdateWithoutEncabezadoComprasInput, DetalleCompraUncheckedUpdateWithoutEncabezadoComprasInput>
  }

  export type DetalleCompraUpdateManyWithWhereWithoutEncabezadoComprasInput = {
    where: DetalleCompraScalarWhereInput
    data: XOR<DetalleCompraUpdateManyMutationInput, DetalleCompraUncheckedUpdateManyWithoutEncabezadoComprasInput>
  }

  export type PedidoUpsertWithWhereUniqueWithoutEncabezadoComprasInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutEncabezadoComprasInput, PedidoUncheckedUpdateWithoutEncabezadoComprasInput>
    create: XOR<PedidoCreateWithoutEncabezadoComprasInput, PedidoUncheckedCreateWithoutEncabezadoComprasInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutEncabezadoComprasInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutEncabezadoComprasInput, PedidoUncheckedUpdateWithoutEncabezadoComprasInput>
  }

  export type PedidoUpdateManyWithWhereWithoutEncabezadoComprasInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutEncabezadoComprasInput>
  }

  export type ProductoCreateWithoutDetalleComprasInput = {
    codigoProducto: string
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductosInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutProductoInput
    Historial?: HistorialCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutDetalleComprasInput = {
    id?: number
    codigoProducto: string
    nombre: string
    descripcion: string
    idSubCategoria: number
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedCreateNestedManyWithoutProductosInput
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutProductoInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoCreateOrConnectWithoutDetalleComprasInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutDetalleComprasInput, ProductoUncheckedCreateWithoutDetalleComprasInput>
  }

  export type EncabezadoCompraCreateWithoutDetalleComprasInput = {
    fechaCompra?: Date | string
    idUsuarioRegistro: number
    usuarioProveedor: UsuarioCreateNestedOneWithoutEncabezadoComprasInput
    pedidos?: PedidoCreateNestedManyWithoutEncabezadoComprasInput
  }

  export type EncabezadoCompraUncheckedCreateWithoutDetalleComprasInput = {
    id?: number
    fechaCompra?: Date | string
    idUsuarioProveedor: number
    idUsuarioRegistro: number
    pedidos?: PedidoUncheckedCreateNestedManyWithoutEncabezadoComprasInput
  }

  export type EncabezadoCompraCreateOrConnectWithoutDetalleComprasInput = {
    where: EncabezadoCompraWhereUniqueInput
    create: XOR<EncabezadoCompraCreateWithoutDetalleComprasInput, EncabezadoCompraUncheckedCreateWithoutDetalleComprasInput>
  }

  export type BodegaCreateWithoutDetalleComprasInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutBodegasInput
    Historial?: HistorialCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoCreateNestedManyWithoutBodegasInput
  }

  export type BodegaUncheckedCreateWithoutDetalleComprasInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutBodegasInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoUncheckedCreateNestedManyWithoutBodegasInput
  }

  export type BodegaCreateOrConnectWithoutDetalleComprasInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutDetalleComprasInput, BodegaUncheckedCreateWithoutDetalleComprasInput>
  }

  export type ProductoUpsertWithoutDetalleComprasInput = {
    update: XOR<ProductoUpdateWithoutDetalleComprasInput, ProductoUncheckedUpdateWithoutDetalleComprasInput>
    create: XOR<ProductoCreateWithoutDetalleComprasInput, ProductoUncheckedCreateWithoutDetalleComprasInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutDetalleComprasInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutDetalleComprasInput, ProductoUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type ProductoUpdateWithoutDetalleComprasInput = {
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductosNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutDetalleComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedUpdateManyWithoutProductosNestedInput
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type EncabezadoCompraUpsertWithoutDetalleComprasInput = {
    update: XOR<EncabezadoCompraUpdateWithoutDetalleComprasInput, EncabezadoCompraUncheckedUpdateWithoutDetalleComprasInput>
    create: XOR<EncabezadoCompraCreateWithoutDetalleComprasInput, EncabezadoCompraUncheckedCreateWithoutDetalleComprasInput>
    where?: EncabezadoCompraWhereInput
  }

  export type EncabezadoCompraUpdateToOneWithWhereWithoutDetalleComprasInput = {
    where?: EncabezadoCompraWhereInput
    data: XOR<EncabezadoCompraUpdateWithoutDetalleComprasInput, EncabezadoCompraUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type EncabezadoCompraUpdateWithoutDetalleComprasInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    usuarioProveedor?: UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput
    pedidos?: PedidoUpdateManyWithoutEncabezadoComprasNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateWithoutDetalleComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioProveedor?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    pedidos?: PedidoUncheckedUpdateManyWithoutEncabezadoComprasNestedInput
  }

  export type BodegaUpsertWithoutDetalleComprasInput = {
    update: XOR<BodegaUpdateWithoutDetalleComprasInput, BodegaUncheckedUpdateWithoutDetalleComprasInput>
    create: XOR<BodegaCreateWithoutDetalleComprasInput, BodegaUncheckedCreateWithoutDetalleComprasInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutDetalleComprasInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutDetalleComprasInput, BodegaUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type BodegaUpdateWithoutDetalleComprasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUpdateManyWithoutBodegasNestedInput
  }

  export type BodegaUncheckedUpdateWithoutDetalleComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUncheckedUpdateManyWithoutBodegasNestedInput
  }

  export type EstadoCreateWithoutPedidosInput = {
    estado: string
    TrasladoDestino?: TrasladoDestinoCreateNestedManyWithoutEstadoDestinoInput
  }

  export type EstadoUncheckedCreateWithoutPedidosInput = {
    id?: number
    estado: string
    TrasladoDestino?: TrasladoDestinoUncheckedCreateNestedManyWithoutEstadoDestinoInput
  }

  export type EstadoCreateOrConnectWithoutPedidosInput = {
    where: EstadoWhereUniqueInput
    create: XOR<EstadoCreateWithoutPedidosInput, EstadoUncheckedCreateWithoutPedidosInput>
  }

  export type EncabezadoCompraCreateWithoutPedidosInput = {
    fechaCompra?: Date | string
    idUsuarioRegistro: number
    usuarioProveedor: UsuarioCreateNestedOneWithoutEncabezadoComprasInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutEncabezadoComprasInput
  }

  export type EncabezadoCompraUncheckedCreateWithoutPedidosInput = {
    id?: number
    fechaCompra?: Date | string
    idUsuarioProveedor: number
    idUsuarioRegistro: number
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoComprasInput
  }

  export type EncabezadoCompraCreateOrConnectWithoutPedidosInput = {
    where: EncabezadoCompraWhereUniqueInput
    create: XOR<EncabezadoCompraCreateWithoutPedidosInput, EncabezadoCompraUncheckedCreateWithoutPedidosInput>
  }

  export type TrasladoBodegasCreateWithoutPedidosInput = {
    destinos: TrasladoDestinoCreateNestedOneWithoutTrasladoBodegasInput
  }

  export type TrasladoBodegasUncheckedCreateWithoutPedidosInput = {
    idDestino: number
  }

  export type TrasladoBodegasCreateOrConnectWithoutPedidosInput = {
    where: TrasladoBodegasWhereUniqueInput
    create: XOR<TrasladoBodegasCreateWithoutPedidosInput, TrasladoBodegasUncheckedCreateWithoutPedidosInput>
  }

  export type TrasladoBodegasCreateManyPedidosInputEnvelope = {
    data: TrasladoBodegasCreateManyPedidosInput | TrasladoBodegasCreateManyPedidosInput[]
    skipDuplicates?: boolean
  }

  export type EstadoUpsertWithoutPedidosInput = {
    update: XOR<EstadoUpdateWithoutPedidosInput, EstadoUncheckedUpdateWithoutPedidosInput>
    create: XOR<EstadoCreateWithoutPedidosInput, EstadoUncheckedCreateWithoutPedidosInput>
    where?: EstadoWhereInput
  }

  export type EstadoUpdateToOneWithWhereWithoutPedidosInput = {
    where?: EstadoWhereInput
    data: XOR<EstadoUpdateWithoutPedidosInput, EstadoUncheckedUpdateWithoutPedidosInput>
  }

  export type EstadoUpdateWithoutPedidosInput = {
    estado?: StringFieldUpdateOperationsInput | string
    TrasladoDestino?: TrasladoDestinoUpdateManyWithoutEstadoDestinoNestedInput
  }

  export type EstadoUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    TrasladoDestino?: TrasladoDestinoUncheckedUpdateManyWithoutEstadoDestinoNestedInput
  }

  export type EncabezadoCompraUpsertWithoutPedidosInput = {
    update: XOR<EncabezadoCompraUpdateWithoutPedidosInput, EncabezadoCompraUncheckedUpdateWithoutPedidosInput>
    create: XOR<EncabezadoCompraCreateWithoutPedidosInput, EncabezadoCompraUncheckedCreateWithoutPedidosInput>
    where?: EncabezadoCompraWhereInput
  }

  export type EncabezadoCompraUpdateToOneWithWhereWithoutPedidosInput = {
    where?: EncabezadoCompraWhereInput
    data: XOR<EncabezadoCompraUpdateWithoutPedidosInput, EncabezadoCompraUncheckedUpdateWithoutPedidosInput>
  }

  export type EncabezadoCompraUpdateWithoutPedidosInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    usuarioProveedor?: UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutEncabezadoComprasNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioProveedor?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutEncabezadoComprasNestedInput
  }

  export type TrasladoBodegasUpsertWithWhereUniqueWithoutPedidosInput = {
    where: TrasladoBodegasWhereUniqueInput
    update: XOR<TrasladoBodegasUpdateWithoutPedidosInput, TrasladoBodegasUncheckedUpdateWithoutPedidosInput>
    create: XOR<TrasladoBodegasCreateWithoutPedidosInput, TrasladoBodegasUncheckedCreateWithoutPedidosInput>
  }

  export type TrasladoBodegasUpdateWithWhereUniqueWithoutPedidosInput = {
    where: TrasladoBodegasWhereUniqueInput
    data: XOR<TrasladoBodegasUpdateWithoutPedidosInput, TrasladoBodegasUncheckedUpdateWithoutPedidosInput>
  }

  export type TrasladoBodegasUpdateManyWithWhereWithoutPedidosInput = {
    where: TrasladoBodegasScalarWhereInput
    data: XOR<TrasladoBodegasUpdateManyMutationInput, TrasladoBodegasUncheckedUpdateManyWithoutPedidosInput>
  }

  export type TrasladoBodegasScalarWhereInput = {
    AND?: TrasladoBodegasScalarWhereInput | TrasladoBodegasScalarWhereInput[]
    OR?: TrasladoBodegasScalarWhereInput[]
    NOT?: TrasladoBodegasScalarWhereInput | TrasladoBodegasScalarWhereInput[]
    idPedido?: IntFilter<"TrasladoBodegas"> | number
    idDestino?: IntFilter<"TrasladoBodegas"> | number
  }

  export type PedidoCreateWithoutTrasladoBodegasInput = {
    fechaPedido?: Date | string
    observaciones?: string | null
    estadoPedido: EstadoCreateNestedOneWithoutPedidosInput
    encabezadoCompras: EncabezadoCompraCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutTrasladoBodegasInput = {
    idEncabezadoCompra: number
    fechaPedido?: Date | string
    idEstado: number
    observaciones?: string | null
  }

  export type PedidoCreateOrConnectWithoutTrasladoBodegasInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutTrasladoBodegasInput, PedidoUncheckedCreateWithoutTrasladoBodegasInput>
  }

  export type TrasladoDestinoCreateWithoutTrasladoBodegasInput = {
    fechaRecibido?: Date | string
    bodegas: BodegaCreateNestedOneWithoutTrasladoDestinoInput
    estadoDestino: EstadoCreateNestedOneWithoutTrasladoDestinoInput
  }

  export type TrasladoDestinoUncheckedCreateWithoutTrasladoBodegasInput = {
    id?: number
    idBodegaDestino: number
    fechaRecibido?: Date | string
    idEstado: number
  }

  export type TrasladoDestinoCreateOrConnectWithoutTrasladoBodegasInput = {
    where: TrasladoDestinoWhereUniqueInput
    create: XOR<TrasladoDestinoCreateWithoutTrasladoBodegasInput, TrasladoDestinoUncheckedCreateWithoutTrasladoBodegasInput>
  }

  export type PedidoUpsertWithoutTrasladoBodegasInput = {
    update: XOR<PedidoUpdateWithoutTrasladoBodegasInput, PedidoUncheckedUpdateWithoutTrasladoBodegasInput>
    create: XOR<PedidoCreateWithoutTrasladoBodegasInput, PedidoUncheckedCreateWithoutTrasladoBodegasInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutTrasladoBodegasInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutTrasladoBodegasInput, PedidoUncheckedUpdateWithoutTrasladoBodegasInput>
  }

  export type PedidoUpdateWithoutTrasladoBodegasInput = {
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estadoPedido?: EstadoUpdateOneRequiredWithoutPedidosNestedInput
    encabezadoCompras?: EncabezadoCompraUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutTrasladoBodegasInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrasladoDestinoUpsertWithoutTrasladoBodegasInput = {
    update: XOR<TrasladoDestinoUpdateWithoutTrasladoBodegasInput, TrasladoDestinoUncheckedUpdateWithoutTrasladoBodegasInput>
    create: XOR<TrasladoDestinoCreateWithoutTrasladoBodegasInput, TrasladoDestinoUncheckedCreateWithoutTrasladoBodegasInput>
    where?: TrasladoDestinoWhereInput
  }

  export type TrasladoDestinoUpdateToOneWithWhereWithoutTrasladoBodegasInput = {
    where?: TrasladoDestinoWhereInput
    data: XOR<TrasladoDestinoUpdateWithoutTrasladoBodegasInput, TrasladoDestinoUncheckedUpdateWithoutTrasladoBodegasInput>
  }

  export type TrasladoDestinoUpdateWithoutTrasladoBodegasInput = {
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegas?: BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    estadoDestino?: EstadoUpdateOneRequiredWithoutTrasladoDestinoNestedInput
  }

  export type TrasladoDestinoUncheckedUpdateWithoutTrasladoBodegasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
  }

  export type BodegaCreateWithoutTrasladoDestinoInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutBodegasInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutBodegasInput
    Historial?: HistorialCreateNestedManyWithoutBodegasInput
  }

  export type BodegaUncheckedCreateWithoutTrasladoDestinoInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutBodegasInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegasInput
  }

  export type BodegaCreateOrConnectWithoutTrasladoDestinoInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutTrasladoDestinoInput, BodegaUncheckedCreateWithoutTrasladoDestinoInput>
  }

  export type EstadoCreateWithoutTrasladoDestinoInput = {
    estado: string
    pedidos?: PedidoCreateNestedManyWithoutEstadoPedidoInput
  }

  export type EstadoUncheckedCreateWithoutTrasladoDestinoInput = {
    id?: number
    estado: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutEstadoPedidoInput
  }

  export type EstadoCreateOrConnectWithoutTrasladoDestinoInput = {
    where: EstadoWhereUniqueInput
    create: XOR<EstadoCreateWithoutTrasladoDestinoInput, EstadoUncheckedCreateWithoutTrasladoDestinoInput>
  }

  export type TrasladoBodegasCreateWithoutDestinosInput = {
    pedidos: PedidoCreateNestedOneWithoutTrasladoBodegasInput
  }

  export type TrasladoBodegasUncheckedCreateWithoutDestinosInput = {
    idPedido: number
  }

  export type TrasladoBodegasCreateOrConnectWithoutDestinosInput = {
    where: TrasladoBodegasWhereUniqueInput
    create: XOR<TrasladoBodegasCreateWithoutDestinosInput, TrasladoBodegasUncheckedCreateWithoutDestinosInput>
  }

  export type TrasladoBodegasCreateManyDestinosInputEnvelope = {
    data: TrasladoBodegasCreateManyDestinosInput | TrasladoBodegasCreateManyDestinosInput[]
    skipDuplicates?: boolean
  }

  export type BodegaUpsertWithoutTrasladoDestinoInput = {
    update: XOR<BodegaUpdateWithoutTrasladoDestinoInput, BodegaUncheckedUpdateWithoutTrasladoDestinoInput>
    create: XOR<BodegaCreateWithoutTrasladoDestinoInput, BodegaUncheckedCreateWithoutTrasladoDestinoInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutTrasladoDestinoInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutTrasladoDestinoInput, BodegaUncheckedUpdateWithoutTrasladoDestinoInput>
  }

  export type BodegaUpdateWithoutTrasladoDestinoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutBodegasNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUpdateManyWithoutBodegasNestedInput
  }

  export type BodegaUncheckedUpdateWithoutTrasladoDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegasNestedInput
  }

  export type EstadoUpsertWithoutTrasladoDestinoInput = {
    update: XOR<EstadoUpdateWithoutTrasladoDestinoInput, EstadoUncheckedUpdateWithoutTrasladoDestinoInput>
    create: XOR<EstadoCreateWithoutTrasladoDestinoInput, EstadoUncheckedCreateWithoutTrasladoDestinoInput>
    where?: EstadoWhereInput
  }

  export type EstadoUpdateToOneWithWhereWithoutTrasladoDestinoInput = {
    where?: EstadoWhereInput
    data: XOR<EstadoUpdateWithoutTrasladoDestinoInput, EstadoUncheckedUpdateWithoutTrasladoDestinoInput>
  }

  export type EstadoUpdateWithoutTrasladoDestinoInput = {
    estado?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutEstadoPedidoNestedInput
  }

  export type EstadoUncheckedUpdateWithoutTrasladoDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutEstadoPedidoNestedInput
  }

  export type TrasladoBodegasUpsertWithWhereUniqueWithoutDestinosInput = {
    where: TrasladoBodegasWhereUniqueInput
    update: XOR<TrasladoBodegasUpdateWithoutDestinosInput, TrasladoBodegasUncheckedUpdateWithoutDestinosInput>
    create: XOR<TrasladoBodegasCreateWithoutDestinosInput, TrasladoBodegasUncheckedCreateWithoutDestinosInput>
  }

  export type TrasladoBodegasUpdateWithWhereUniqueWithoutDestinosInput = {
    where: TrasladoBodegasWhereUniqueInput
    data: XOR<TrasladoBodegasUpdateWithoutDestinosInput, TrasladoBodegasUncheckedUpdateWithoutDestinosInput>
  }

  export type TrasladoBodegasUpdateManyWithWhereWithoutDestinosInput = {
    where: TrasladoBodegasScalarWhereInput
    data: XOR<TrasladoBodegasUpdateManyMutationInput, TrasladoBodegasUncheckedUpdateManyWithoutDestinosInput>
  }

  export type BodegaCreateWithoutHistorialInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutBodegasInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoCreateNestedManyWithoutBodegasInput
  }

  export type BodegaUncheckedCreateWithoutHistorialInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutBodegasInput
    TrasladoDestino?: TrasladoDestinoUncheckedCreateNestedManyWithoutBodegasInput
  }

  export type BodegaCreateOrConnectWithoutHistorialInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutHistorialInput, BodegaUncheckedCreateWithoutHistorialInput>
  }

  export type UsuarioCreateWithoutHistorialInput = {
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    ubicacion: UbicacionCreateNestedOneWithoutUsuarioInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutUsuarioInput
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioProveedorInput
  }

  export type UsuarioUncheckedCreateWithoutHistorialInput = {
    id?: number
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
    idUbicacion: number
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutUsuarioInput
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioProveedorInput
  }

  export type UsuarioCreateOrConnectWithoutHistorialInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutHistorialInput, UsuarioUncheckedCreateWithoutHistorialInput>
  }

  export type ProductoCreateWithoutHistorialInput = {
    codigoProducto: string
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductosInput
    bodegaProductos?: BodegaProductosCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutHistorialInput = {
    id?: number
    codigoProducto: string
    nombre: string
    descripcion: string
    idSubCategoria: number
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedCreateNestedManyWithoutProductosInput
    bodegaProductos?: BodegaProductosUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoCreateOrConnectWithoutHistorialInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutHistorialInput, ProductoUncheckedCreateWithoutHistorialInput>
  }

  export type BodegaUpsertWithoutHistorialInput = {
    update: XOR<BodegaUpdateWithoutHistorialInput, BodegaUncheckedUpdateWithoutHistorialInput>
    create: XOR<BodegaCreateWithoutHistorialInput, BodegaUncheckedCreateWithoutHistorialInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutHistorialInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutHistorialInput, BodegaUncheckedUpdateWithoutHistorialInput>
  }

  export type BodegaUpdateWithoutHistorialInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutBodegasNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUpdateManyWithoutBodegasNestedInput
  }

  export type BodegaUncheckedUpdateWithoutHistorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUncheckedUpdateManyWithoutBodegasNestedInput
  }

  export type UsuarioUpsertWithoutHistorialInput = {
    update: XOR<UsuarioUpdateWithoutHistorialInput, UsuarioUncheckedUpdateWithoutHistorialInput>
    create: XOR<UsuarioCreateWithoutHistorialInput, UsuarioUncheckedCreateWithoutHistorialInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutHistorialInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutHistorialInput, UsuarioUncheckedUpdateWithoutHistorialInput>
  }

  export type UsuarioUpdateWithoutHistorialInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ubicacion?: UbicacionUpdateOneRequiredWithoutUsuarioNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutUsuarioNestedInput
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioProveedorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutHistorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idUbicacion?: IntFieldUpdateOperationsInput | number
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutUsuarioNestedInput
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioProveedorNestedInput
  }

  export type ProductoUpsertWithoutHistorialInput = {
    update: XOR<ProductoUpdateWithoutHistorialInput, ProductoUncheckedUpdateWithoutHistorialInput>
    create: XOR<ProductoCreateWithoutHistorialInput, ProductoUncheckedCreateWithoutHistorialInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutHistorialInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutHistorialInput, ProductoUncheckedUpdateWithoutHistorialInput>
  }

  export type ProductoUpdateWithoutHistorialInput = {
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductosNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutHistorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedUpdateManyWithoutProductosNestedInput
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type BodegaProductosCreateManyUsuarioInput = {
    idBodega: number
    idProducto: number
    fechaRegistro?: Date | string
    cantidad: number
  }

  export type EncabezadoCompraCreateManyUsuarioProveedorInput = {
    id?: number
    fechaCompra?: Date | string
    idUsuarioRegistro: number
  }

  export type HistorialCreateManyUsuarioRegistroInput = {
    id?: number
    idBodega: number
    idProducto: number
    fechaAjuste?: Date | string
    justificacion: string
  }

  export type BodegaProductosUpdateWithoutUsuarioInput = {
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    bodegas?: BodegaUpdateOneRequiredWithoutBodegaProductosNestedInput
    producto?: ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput
  }

  export type BodegaProductosUncheckedUpdateWithoutUsuarioInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type BodegaProductosUncheckedUpdateManyWithoutUsuarioInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type EncabezadoCompraUpdateWithoutUsuarioProveedorInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    detalleCompras?: DetalleCompraUpdateManyWithoutEncabezadoComprasNestedInput
    pedidos?: PedidoUpdateManyWithoutEncabezadoComprasNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateWithoutUsuarioProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutEncabezadoComprasNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutEncabezadoComprasNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateManyWithoutUsuarioProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
  }

  export type HistorialUpdateWithoutUsuarioRegistroInput = {
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
    bodegas?: BodegaUpdateOneRequiredWithoutHistorialNestedInput
    productos?: ProductoUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialUncheckedUpdateWithoutUsuarioRegistroInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type HistorialUncheckedUpdateManyWithoutUsuarioRegistroInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoCreateManyEstadoPedidoInput = {
    idEncabezadoCompra: number
    fechaPedido?: Date | string
    observaciones?: string | null
  }

  export type TrasladoDestinoCreateManyEstadoDestinoInput = {
    id?: number
    idBodegaDestino: number
    fechaRecibido?: Date | string
  }

  export type PedidoUpdateWithoutEstadoPedidoInput = {
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    encabezadoCompras?: EncabezadoCompraUpdateOneRequiredWithoutPedidosNestedInput
    TrasladoBodegas?: TrasladoBodegasUpdateManyWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutEstadoPedidoInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    TrasladoBodegas?: TrasladoBodegasUncheckedUpdateManyWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutEstadoPedidoInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrasladoDestinoUpdateWithoutEstadoDestinoInput = {
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegas?: BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    TrasladoBodegas?: TrasladoBodegasUpdateManyWithoutDestinosNestedInput
  }

  export type TrasladoDestinoUncheckedUpdateWithoutEstadoDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    TrasladoBodegas?: TrasladoBodegasUncheckedUpdateManyWithoutDestinosNestedInput
  }

  export type TrasladoDestinoUncheckedUpdateManyWithoutEstadoDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoriaUpdateWithoutCategoriasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUpdateManyWithoutSubCategoriasNestedInput
  }

  export type SubCategoriaUncheckedUpdateWithoutCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUncheckedUpdateManyWithoutSubCategoriasNestedInput
  }

  export type SubCategoriaUncheckedUpdateManyWithoutCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoCreateManySubCategoriasInput = {
    id?: number
    codigoProducto: string
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
  }

  export type ProductoUpdateWithoutSubCategoriasInput = {
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    foto?: FotoUpdateManyWithoutProductosNestedInput
    bodegaProductos?: BodegaProductosUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductosNestedInput
    Historial?: HistorialUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutSubCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    foto?: FotoUncheckedUpdateManyWithoutProductosNestedInput
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductosNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateManyWithoutSubCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CategoriaUpdateWithoutSubCategoriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateWithoutSubCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyWithoutSubCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type FotoCreateManyProductosInput = {
    id?: number
    foto: Buffer
  }

  export type BodegaProductosCreateManyProductoInput = {
    idBodega: number
    idUsuario: number
    fechaRegistro?: Date | string
    cantidad: number
  }

  export type DetalleCompraCreateManyProductosInput = {
    id?: number
    idEncabezadoCompra: number
    idBodega: number
    cantidad: number
  }

  export type HistorialCreateManyProductosInput = {
    id?: number
    idBodega: number
    idUsuarioRegistro: number
    fechaAjuste?: Date | string
    justificacion: string
  }

  export type FotoUpdateWithoutProductosInput = {
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type FotoUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type FotoUncheckedUpdateManyWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type BodegaProductosUpdateWithoutProductoInput = {
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    bodegas?: BodegaUpdateOneRequiredWithoutBodegaProductosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutBodegaProductosNestedInput
  }

  export type BodegaProductosUncheckedUpdateWithoutProductoInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type BodegaProductosUncheckedUpdateManyWithoutProductoInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUpdateWithoutProductosInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    encabezadoCompras?: EncabezadoCompraUpdateOneRequiredWithoutDetalleComprasNestedInput
    bodegas?: BodegaUpdateOneRequiredWithoutDetalleComprasNestedInput
  }

  export type DetalleCompraUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUncheckedUpdateManyWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type HistorialUpdateWithoutProductosInput = {
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
    bodegas?: BodegaUpdateOneRequiredWithoutHistorialNestedInput
    UsuarioRegistro?: UsuarioUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type HistorialUncheckedUpdateManyWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateManyUbicacionInput = {
    id?: number
    nombre: string
    apellidos: string
    nombreProveedor?: string | null
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol: $Enums.Rol
  }

  export type BodegaCreateManyUbicacionInput = {
    id?: number
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
  }

  export type ProvinciaCreateManyUbicacionInput = {
    nombre: string
  }

  export type CantonCreateManyUbicacionInput = {
    idProvincia: number
    nombre: string
  }

  export type DistritoCreateManyUbicacionInput = {
    idProvincia: number
    idCanton: number
    nombre: string
  }

  export type BarrioCreateManyUbicacionInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    nombre: string
  }

  export type UsuarioUpdateWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    bodegaProductos?: BodegaProductosUpdateManyWithoutUsuarioNestedInput
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioProveedorNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutUbicacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutUsuarioNestedInput
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioProveedorNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutUbicacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    nombreProveedor?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
  }

  export type BodegaUpdateWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    bodegaProductos?: BodegaProductosUpdateManyWithoutBodegasNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUpdateManyWithoutBodegasNestedInput
  }

  export type BodegaUncheckedUpdateWithoutUbicacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    bodegaProductos?: BodegaProductosUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegasNestedInput
    TrasladoDestino?: TrasladoDestinoUncheckedUpdateManyWithoutBodegasNestedInput
  }

  export type BodegaUncheckedUpdateManyWithoutUbicacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProvinciaUpdateWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUpdateManyWithoutProvinciasNestedInput
    distritos?: DistritoUpdateManyWithoutProvinciasNestedInput
    barrios?: BarrioUpdateManyWithoutProvinciasNestedInput
  }

  export type ProvinciaUncheckedUpdateWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUncheckedUpdateManyWithoutProvinciasNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutProvinciasNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutProvinciasNestedInput
  }

  export type ProvinciaUncheckedUpdateManyWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CantonUpdateWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutCantonesNestedInput
    distritos?: DistritoUpdateManyWithoutCantonesNestedInput
    barrios?: BarrioUpdateManyWithoutCantonesNestedInput
  }

  export type CantonUncheckedUpdateWithoutUbicacionInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    distritos?: DistritoUncheckedUpdateManyWithoutCantonesNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutCantonesNestedInput
  }

  export type CantonUncheckedUpdateManyWithoutUbicacionInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DistritoUpdateWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutDistritosNestedInput
    cantones?: CantonUpdateOneRequiredWithoutDistritosNestedInput
    barrios?: BarrioUpdateManyWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateWithoutUbicacionInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    barrios?: BarrioUncheckedUpdateManyWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateManyWithoutUbicacionInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioUpdateWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutBarriosNestedInput
    cantones?: CantonUpdateOneRequiredWithoutBarriosNestedInput
    distritos?: DistritoUpdateOneRequiredWithoutBarriosNestedInput
  }

  export type BarrioUncheckedUpdateWithoutUbicacionInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioUncheckedUpdateManyWithoutUbicacionInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CantonCreateManyProvinciasInput = {
    id?: number
    nombre: string
  }

  export type DistritoCreateManyProvinciasInput = {
    id?: number
    idCanton: number
    nombre: string
  }

  export type BarrioCreateManyProvinciasInput = {
    id?: number
    idCanton: number
    idDistrito: number
    nombre: string
  }

  export type CantonUpdateWithoutProvinciasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: UbicacionUpdateOneRequiredWithoutCantonesNestedInput
    distritos?: DistritoUpdateManyWithoutCantonesNestedInput
    barrios?: BarrioUpdateManyWithoutCantonesNestedInput
  }

  export type CantonUncheckedUpdateWithoutProvinciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    distritos?: DistritoUncheckedUpdateManyWithoutCantonesNestedInput
    barrios?: BarrioUncheckedUpdateManyWithoutCantonesNestedInput
  }

  export type CantonUncheckedUpdateManyWithoutProvinciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DistritoUpdateWithoutProvinciasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUpdateOneRequiredWithoutDistritosNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutDistritosNestedInput
    barrios?: BarrioUpdateManyWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateWithoutProvinciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    barrios?: BarrioUncheckedUpdateManyWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateManyWithoutProvinciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioUpdateWithoutProvinciasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantones?: CantonUpdateOneRequiredWithoutBarriosNestedInput
    distritos?: DistritoUpdateOneRequiredWithoutBarriosNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBarriosNestedInput
  }

  export type BarrioUncheckedUpdateWithoutProvinciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioUncheckedUpdateManyWithoutProvinciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DistritoCreateManyCantonesInput = {
    id?: number
    idProvincia: number
    nombre: string
  }

  export type BarrioCreateManyCantonesInput = {
    id?: number
    idProvincia: number
    idDistrito: number
    nombre: string
  }

  export type DistritoUpdateWithoutCantonesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutDistritosNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutDistritosNestedInput
    barrios?: BarrioUpdateManyWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateWithoutCantonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    barrios?: BarrioUncheckedUpdateManyWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateManyWithoutCantonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioUpdateWithoutCantonesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutBarriosNestedInput
    distritos?: DistritoUpdateOneRequiredWithoutBarriosNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBarriosNestedInput
  }

  export type BarrioUncheckedUpdateWithoutCantonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioUncheckedUpdateManyWithoutCantonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioCreateManyDistritosInput = {
    id?: number
    idProvincia: number
    idCanton: number
    nombre: string
  }

  export type BarrioUpdateWithoutDistritosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    provincias?: ProvinciaUpdateOneRequiredWithoutBarriosNestedInput
    cantones?: CantonUpdateOneRequiredWithoutBarriosNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBarriosNestedInput
  }

  export type BarrioUncheckedUpdateWithoutDistritosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BarrioUncheckedUpdateManyWithoutDistritosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BodegaProductosCreateManyBodegasInput = {
    idProducto: number
    idUsuario: number
    fechaRegistro?: Date | string
    cantidad: number
  }

  export type DetalleCompraCreateManyBodegasInput = {
    id?: number
    idEncabezadoCompra: number
    idProducto: number
    cantidad: number
  }

  export type HistorialCreateManyBodegasInput = {
    id?: number
    idUsuarioRegistro: number
    idProducto: number
    fechaAjuste?: Date | string
    justificacion: string
  }

  export type TrasladoDestinoCreateManyBodegasInput = {
    id?: number
    fechaRecibido?: Date | string
    idEstado: number
  }

  export type BodegaProductosUpdateWithoutBodegasInput = {
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutBodegaProductosNestedInput
  }

  export type BodegaProductosUncheckedUpdateWithoutBodegasInput = {
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type BodegaProductosUncheckedUpdateManyWithoutBodegasInput = {
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUpdateWithoutBodegasInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUpdateOneRequiredWithoutDetalleComprasNestedInput
    encabezadoCompras?: EncabezadoCompraUpdateOneRequiredWithoutDetalleComprasNestedInput
  }

  export type DetalleCompraUncheckedUpdateWithoutBodegasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUncheckedUpdateManyWithoutBodegasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type HistorialUpdateWithoutBodegasInput = {
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
    UsuarioRegistro?: UsuarioUpdateOneRequiredWithoutHistorialNestedInput
    productos?: ProductoUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialUncheckedUpdateWithoutBodegasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type HistorialUncheckedUpdateManyWithoutBodegasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    justificacion?: StringFieldUpdateOperationsInput | string
  }

  export type TrasladoDestinoUpdateWithoutBodegasInput = {
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoDestino?: EstadoUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    TrasladoBodegas?: TrasladoBodegasUpdateManyWithoutDestinosNestedInput
  }

  export type TrasladoDestinoUncheckedUpdateWithoutBodegasInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    TrasladoBodegas?: TrasladoBodegasUncheckedUpdateManyWithoutDestinosNestedInput
  }

  export type TrasladoDestinoUncheckedUpdateManyWithoutBodegasInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaRecibido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraCreateManyEncabezadoComprasInput = {
    id?: number
    idProducto: number
    idBodega: number
    cantidad: number
  }

  export type PedidoCreateManyEncabezadoComprasInput = {
    fechaPedido?: Date | string
    idEstado: number
    observaciones?: string | null
  }

  export type DetalleCompraUpdateWithoutEncabezadoComprasInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUpdateOneRequiredWithoutDetalleComprasNestedInput
    bodegas?: BodegaUpdateOneRequiredWithoutDetalleComprasNestedInput
  }

  export type DetalleCompraUncheckedUpdateWithoutEncabezadoComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUncheckedUpdateManyWithoutEncabezadoComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoUpdateWithoutEncabezadoComprasInput = {
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estadoPedido?: EstadoUpdateOneRequiredWithoutPedidosNestedInput
    TrasladoBodegas?: TrasladoBodegasUpdateManyWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutEncabezadoComprasInput = {
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    TrasladoBodegas?: TrasladoBodegasUncheckedUpdateManyWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutEncabezadoComprasInput = {
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrasladoBodegasCreateManyPedidosInput = {
    idDestino: number
  }

  export type TrasladoBodegasUpdateWithoutPedidosInput = {
    destinos?: TrasladoDestinoUpdateOneRequiredWithoutTrasladoBodegasNestedInput
  }

  export type TrasladoBodegasUncheckedUpdateWithoutPedidosInput = {
    idDestino?: IntFieldUpdateOperationsInput | number
  }

  export type TrasladoBodegasUncheckedUpdateManyWithoutPedidosInput = {
    idDestino?: IntFieldUpdateOperationsInput | number
  }

  export type TrasladoBodegasCreateManyDestinosInput = {
    idPedido: number
  }

  export type TrasladoBodegasUpdateWithoutDestinosInput = {
    pedidos?: PedidoUpdateOneRequiredWithoutTrasladoBodegasNestedInput
  }

  export type TrasladoBodegasUncheckedUpdateWithoutDestinosInput = {
    idPedido?: IntFieldUpdateOperationsInput | number
  }

  export type TrasladoBodegasUncheckedUpdateManyWithoutDestinosInput = {
    idPedido?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoCountOutputTypeDefaultArgs instead
     */
    export type EstadoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaCountOutputTypeDefaultArgs instead
     */
    export type CategoriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoriaCountOutputTypeDefaultArgs instead
     */
    export type SubCategoriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductoCountOutputTypeDefaultArgs instead
     */
    export type ProductoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UbicacionCountOutputTypeDefaultArgs instead
     */
    export type UbicacionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UbicacionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProvinciaCountOutputTypeDefaultArgs instead
     */
    export type ProvinciaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProvinciaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CantonCountOutputTypeDefaultArgs instead
     */
    export type CantonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CantonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistritoCountOutputTypeDefaultArgs instead
     */
    export type DistritoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistritoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BodegaCountOutputTypeDefaultArgs instead
     */
    export type BodegaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BodegaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncabezadoCompraCountOutputTypeDefaultArgs instead
     */
    export type EncabezadoCompraCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncabezadoCompraCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoCountOutputTypeDefaultArgs instead
     */
    export type PedidoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrasladoDestinoCountOutputTypeDefaultArgs instead
     */
    export type TrasladoDestinoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrasladoDestinoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoDefaultArgs instead
     */
    export type EstadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaDefaultArgs instead
     */
    export type CategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoriaDefaultArgs instead
     */
    export type SubCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductoDefaultArgs instead
     */
    export type ProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FotoDefaultArgs instead
     */
    export type FotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UbicacionDefaultArgs instead
     */
    export type UbicacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UbicacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProvinciaDefaultArgs instead
     */
    export type ProvinciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProvinciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CantonDefaultArgs instead
     */
    export type CantonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CantonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistritoDefaultArgs instead
     */
    export type DistritoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistritoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BarrioDefaultArgs instead
     */
    export type BarrioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BarrioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BodegaDefaultArgs instead
     */
    export type BodegaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BodegaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BodegaProductosDefaultArgs instead
     */
    export type BodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BodegaProductosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncabezadoCompraDefaultArgs instead
     */
    export type EncabezadoCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncabezadoCompraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetalleCompraDefaultArgs instead
     */
    export type DetalleCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetalleCompraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoDefaultArgs instead
     */
    export type PedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrasladoBodegasDefaultArgs instead
     */
    export type TrasladoBodegasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrasladoBodegasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrasladoDestinoDefaultArgs instead
     */
    export type TrasladoDestinoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrasladoDestinoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistorialDefaultArgs instead
     */
    export type HistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistorialDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}