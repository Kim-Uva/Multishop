
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Estado
 * 
 */
export type Estado = $Result.DefaultSelection<Prisma.$EstadoPayload>
/**
 * Model Categoria
 * 
 */
export type Categoria = $Result.DefaultSelection<Prisma.$CategoriaPayload>
/**
 * Model SubCategoria
 * 
 */
export type SubCategoria = $Result.DefaultSelection<Prisma.$SubCategoriaPayload>
/**
 * Model Producto
 * 
 */
export type Producto = $Result.DefaultSelection<Prisma.$ProductoPayload>
/**
 * Model Foto
 * 
 */
export type Foto = $Result.DefaultSelection<Prisma.$FotoPayload>
/**
 * Model Ubicacion
 * 
 */
export type Ubicacion = $Result.DefaultSelection<Prisma.$UbicacionPayload>
/**
 * Model Bodega
 * 
 */
export type Bodega = $Result.DefaultSelection<Prisma.$BodegaPayload>
/**
 * Model Inventario
 * 
 */
export type Inventario = $Result.DefaultSelection<Prisma.$InventarioPayload>
/**
 * Model Proveedor
 * 
 */
export type Proveedor = $Result.DefaultSelection<Prisma.$ProveedorPayload>
/**
 * Model EncabezadoCompra
 * 
 */
export type EncabezadoCompra = $Result.DefaultSelection<Prisma.$EncabezadoCompraPayload>
/**
 * Model DetalleCompra
 * 
 */
export type DetalleCompra = $Result.DefaultSelection<Prisma.$DetalleCompraPayload>
/**
 * Model Pedido
 * 
 */
export type Pedido = $Result.DefaultSelection<Prisma.$PedidoPayload>
/**
 * Model Traslado
 * 
 */
export type Traslado = $Result.DefaultSelection<Prisma.$TrasladoPayload>
/**
 * Model Historial
 * 
 */
export type Historial = $Result.DefaultSelection<Prisma.$HistorialPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  Administrador: 'Administrador',
  Encargado: 'Encargado'
};

export type Rol = (typeof Rol)[keyof typeof Rol]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.estado`: Exposes CRUD operations for the **Estado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estados
    * const estados = await prisma.estado.findMany()
    * ```
    */
  get estado(): Prisma.EstadoDelegate<ExtArgs>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<ExtArgs>;

  /**
   * `prisma.subCategoria`: Exposes CRUD operations for the **SubCategoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategorias
    * const subCategorias = await prisma.subCategoria.findMany()
    * ```
    */
  get subCategoria(): Prisma.SubCategoriaDelegate<ExtArgs>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<ExtArgs>;

  /**
   * `prisma.foto`: Exposes CRUD operations for the **Foto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fotos
    * const fotos = await prisma.foto.findMany()
    * ```
    */
  get foto(): Prisma.FotoDelegate<ExtArgs>;

  /**
   * `prisma.ubicacion`: Exposes CRUD operations for the **Ubicacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ubicacions
    * const ubicacions = await prisma.ubicacion.findMany()
    * ```
    */
  get ubicacion(): Prisma.UbicacionDelegate<ExtArgs>;

  /**
   * `prisma.bodega`: Exposes CRUD operations for the **Bodega** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bodegas
    * const bodegas = await prisma.bodega.findMany()
    * ```
    */
  get bodega(): Prisma.BodegaDelegate<ExtArgs>;

  /**
   * `prisma.inventario`: Exposes CRUD operations for the **Inventario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventarios
    * const inventarios = await prisma.inventario.findMany()
    * ```
    */
  get inventario(): Prisma.InventarioDelegate<ExtArgs>;

  /**
   * `prisma.proveedor`: Exposes CRUD operations for the **Proveedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedors
    * const proveedors = await prisma.proveedor.findMany()
    * ```
    */
  get proveedor(): Prisma.ProveedorDelegate<ExtArgs>;

  /**
   * `prisma.encabezadoCompra`: Exposes CRUD operations for the **EncabezadoCompra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncabezadoCompras
    * const encabezadoCompras = await prisma.encabezadoCompra.findMany()
    * ```
    */
  get encabezadoCompra(): Prisma.EncabezadoCompraDelegate<ExtArgs>;

  /**
   * `prisma.detalleCompra`: Exposes CRUD operations for the **DetalleCompra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetalleCompras
    * const detalleCompras = await prisma.detalleCompra.findMany()
    * ```
    */
  get detalleCompra(): Prisma.DetalleCompraDelegate<ExtArgs>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<ExtArgs>;

  /**
   * `prisma.traslado`: Exposes CRUD operations for the **Traslado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Traslados
    * const traslados = await prisma.traslado.findMany()
    * ```
    */
  get traslado(): Prisma.TrasladoDelegate<ExtArgs>;

  /**
   * `prisma.historial`: Exposes CRUD operations for the **Historial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historials
    * const historials = await prisma.historial.findMany()
    * ```
    */
  get historial(): Prisma.HistorialDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Estado: 'Estado',
    Categoria: 'Categoria',
    SubCategoria: 'SubCategoria',
    Producto: 'Producto',
    Foto: 'Foto',
    Ubicacion: 'Ubicacion',
    Bodega: 'Bodega',
    Inventario: 'Inventario',
    Proveedor: 'Proveedor',
    EncabezadoCompra: 'EncabezadoCompra',
    DetalleCompra: 'DetalleCompra',
    Pedido: 'Pedido',
    Traslado: 'Traslado',
    Historial: 'Historial'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'usuario' | 'estado' | 'categoria' | 'subCategoria' | 'producto' | 'foto' | 'ubicacion' | 'bodega' | 'inventario' | 'proveedor' | 'encabezadoCompra' | 'detalleCompra' | 'pedido' | 'traslado' | 'historial'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Estado: {
        payload: Prisma.$EstadoPayload<ExtArgs>
        fields: Prisma.EstadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstadoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstadoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          findFirst: {
            args: Prisma.EstadoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstadoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          findMany: {
            args: Prisma.EstadoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>[]
          }
          create: {
            args: Prisma.EstadoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          createMany: {
            args: Prisma.EstadoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EstadoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          update: {
            args: Prisma.EstadoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          deleteMany: {
            args: Prisma.EstadoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EstadoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EstadoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          aggregate: {
            args: Prisma.EstadoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEstado>
          }
          groupBy: {
            args: Prisma.EstadoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EstadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstadoCountArgs<ExtArgs>,
            result: $Utils.Optional<EstadoCountAggregateOutputType> | number
          }
        }
      }
      Categoria: {
        payload: Prisma.$CategoriaPayload<ExtArgs>
        fields: Prisma.CategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findFirst: {
            args: Prisma.CategoriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findMany: {
            args: Prisma.CategoriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          create: {
            args: Prisma.CategoriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          createMany: {
            args: Prisma.CategoriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          update: {
            args: Prisma.CategoriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.CategoriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      SubCategoria: {
        payload: Prisma.$SubCategoriaPayload<ExtArgs>
        fields: Prisma.SubCategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubCategoriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubCategoriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          findFirst: {
            args: Prisma.SubCategoriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubCategoriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          findMany: {
            args: Prisma.SubCategoriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>[]
          }
          create: {
            args: Prisma.SubCategoriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          createMany: {
            args: Prisma.SubCategoriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubCategoriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          update: {
            args: Prisma.SubCategoriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          deleteMany: {
            args: Prisma.SubCategoriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubCategoriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubCategoriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
          }
          aggregate: {
            args: Prisma.SubCategoriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubCategoria>
          }
          groupBy: {
            args: Prisma.SubCategoriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubCategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubCategoriaCountArgs<ExtArgs>,
            result: $Utils.Optional<SubCategoriaCountAggregateOutputType> | number
          }
        }
      }
      Producto: {
        payload: Prisma.$ProductoPayload<ExtArgs>
        fields: Prisma.ProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findFirst: {
            args: Prisma.ProductoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findMany: {
            args: Prisma.ProductoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          create: {
            args: Prisma.ProductoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          createMany: {
            args: Prisma.ProductoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          update: {
            args: Prisma.ProductoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          deleteMany: {
            args: Prisma.ProductoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          aggregate: {
            args: Prisma.ProductoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProducto>
          }
          groupBy: {
            args: Prisma.ProductoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductoCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductoCountAggregateOutputType> | number
          }
        }
      }
      Foto: {
        payload: Prisma.$FotoPayload<ExtArgs>
        fields: Prisma.FotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          findFirst: {
            args: Prisma.FotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          findMany: {
            args: Prisma.FotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>[]
          }
          create: {
            args: Prisma.FotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          createMany: {
            args: Prisma.FotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          update: {
            args: Prisma.FotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          deleteMany: {
            args: Prisma.FotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FotoPayload>
          }
          aggregate: {
            args: Prisma.FotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFoto>
          }
          groupBy: {
            args: Prisma.FotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FotoCountArgs<ExtArgs>,
            result: $Utils.Optional<FotoCountAggregateOutputType> | number
          }
        }
      }
      Ubicacion: {
        payload: Prisma.$UbicacionPayload<ExtArgs>
        fields: Prisma.UbicacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UbicacionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UbicacionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          findFirst: {
            args: Prisma.UbicacionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UbicacionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          findMany: {
            args: Prisma.UbicacionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>[]
          }
          create: {
            args: Prisma.UbicacionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          createMany: {
            args: Prisma.UbicacionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UbicacionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          update: {
            args: Prisma.UbicacionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          deleteMany: {
            args: Prisma.UbicacionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UbicacionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UbicacionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UbicacionPayload>
          }
          aggregate: {
            args: Prisma.UbicacionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUbicacion>
          }
          groupBy: {
            args: Prisma.UbicacionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UbicacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UbicacionCountArgs<ExtArgs>,
            result: $Utils.Optional<UbicacionCountAggregateOutputType> | number
          }
        }
      }
      Bodega: {
        payload: Prisma.$BodegaPayload<ExtArgs>
        fields: Prisma.BodegaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BodegaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BodegaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          findFirst: {
            args: Prisma.BodegaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BodegaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          findMany: {
            args: Prisma.BodegaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>[]
          }
          create: {
            args: Prisma.BodegaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          createMany: {
            args: Prisma.BodegaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BodegaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          update: {
            args: Prisma.BodegaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          deleteMany: {
            args: Prisma.BodegaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BodegaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BodegaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodegaPayload>
          }
          aggregate: {
            args: Prisma.BodegaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBodega>
          }
          groupBy: {
            args: Prisma.BodegaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BodegaGroupByOutputType>[]
          }
          count: {
            args: Prisma.BodegaCountArgs<ExtArgs>,
            result: $Utils.Optional<BodegaCountAggregateOutputType> | number
          }
        }
      }
      Inventario: {
        payload: Prisma.$InventarioPayload<ExtArgs>
        fields: Prisma.InventarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          findFirst: {
            args: Prisma.InventarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          findMany: {
            args: Prisma.InventarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>[]
          }
          create: {
            args: Prisma.InventarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          createMany: {
            args: Prisma.InventarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          update: {
            args: Prisma.InventarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          deleteMany: {
            args: Prisma.InventarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          aggregate: {
            args: Prisma.InventarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventario>
          }
          groupBy: {
            args: Prisma.InventarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventarioCountArgs<ExtArgs>,
            result: $Utils.Optional<InventarioCountAggregateOutputType> | number
          }
        }
      }
      Proveedor: {
        payload: Prisma.$ProveedorPayload<ExtArgs>
        fields: Prisma.ProveedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProveedorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProveedorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          findFirst: {
            args: Prisma.ProveedorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProveedorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          findMany: {
            args: Prisma.ProveedorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>[]
          }
          create: {
            args: Prisma.ProveedorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          createMany: {
            args: Prisma.ProveedorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProveedorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          update: {
            args: Prisma.ProveedorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          deleteMany: {
            args: Prisma.ProveedorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProveedorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProveedorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          aggregate: {
            args: Prisma.ProveedorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProveedor>
          }
          groupBy: {
            args: Prisma.ProveedorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProveedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProveedorCountArgs<ExtArgs>,
            result: $Utils.Optional<ProveedorCountAggregateOutputType> | number
          }
        }
      }
      EncabezadoCompra: {
        payload: Prisma.$EncabezadoCompraPayload<ExtArgs>
        fields: Prisma.EncabezadoCompraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncabezadoCompraFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncabezadoCompraFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          findFirst: {
            args: Prisma.EncabezadoCompraFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncabezadoCompraFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          findMany: {
            args: Prisma.EncabezadoCompraFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>[]
          }
          create: {
            args: Prisma.EncabezadoCompraCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          createMany: {
            args: Prisma.EncabezadoCompraCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EncabezadoCompraDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          update: {
            args: Prisma.EncabezadoCompraUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          deleteMany: {
            args: Prisma.EncabezadoCompraDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EncabezadoCompraUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EncabezadoCompraUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncabezadoCompraPayload>
          }
          aggregate: {
            args: Prisma.EncabezadoCompraAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEncabezadoCompra>
          }
          groupBy: {
            args: Prisma.EncabezadoCompraGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EncabezadoCompraGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncabezadoCompraCountArgs<ExtArgs>,
            result: $Utils.Optional<EncabezadoCompraCountAggregateOutputType> | number
          }
        }
      }
      DetalleCompra: {
        payload: Prisma.$DetalleCompraPayload<ExtArgs>
        fields: Prisma.DetalleCompraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetalleCompraFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetalleCompraFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          findFirst: {
            args: Prisma.DetalleCompraFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetalleCompraFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          findMany: {
            args: Prisma.DetalleCompraFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>[]
          }
          create: {
            args: Prisma.DetalleCompraCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          createMany: {
            args: Prisma.DetalleCompraCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DetalleCompraDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          update: {
            args: Prisma.DetalleCompraUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          deleteMany: {
            args: Prisma.DetalleCompraDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DetalleCompraUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DetalleCompraUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DetalleCompraPayload>
          }
          aggregate: {
            args: Prisma.DetalleCompraAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetalleCompra>
          }
          groupBy: {
            args: Prisma.DetalleCompraGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DetalleCompraGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetalleCompraCountArgs<ExtArgs>,
            result: $Utils.Optional<DetalleCompraCountAggregateOutputType> | number
          }
        }
      }
      Pedido: {
        payload: Prisma.$PedidoPayload<ExtArgs>
        fields: Prisma.PedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findFirst: {
            args: Prisma.PedidoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findMany: {
            args: Prisma.PedidoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          create: {
            args: Prisma.PedidoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          createMany: {
            args: Prisma.PedidoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PedidoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          update: {
            args: Prisma.PedidoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PedidoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          aggregate: {
            args: Prisma.PedidoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePedido>
          }
          groupBy: {
            args: Prisma.PedidoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoCountArgs<ExtArgs>,
            result: $Utils.Optional<PedidoCountAggregateOutputType> | number
          }
        }
      }
      Traslado: {
        payload: Prisma.$TrasladoPayload<ExtArgs>
        fields: Prisma.TrasladoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrasladoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrasladoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload>
          }
          findFirst: {
            args: Prisma.TrasladoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrasladoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload>
          }
          findMany: {
            args: Prisma.TrasladoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload>[]
          }
          create: {
            args: Prisma.TrasladoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload>
          }
          createMany: {
            args: Prisma.TrasladoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrasladoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload>
          }
          update: {
            args: Prisma.TrasladoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload>
          }
          deleteMany: {
            args: Prisma.TrasladoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrasladoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrasladoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrasladoPayload>
          }
          aggregate: {
            args: Prisma.TrasladoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTraslado>
          }
          groupBy: {
            args: Prisma.TrasladoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrasladoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrasladoCountArgs<ExtArgs>,
            result: $Utils.Optional<TrasladoCountAggregateOutputType> | number
          }
        }
      }
      Historial: {
        payload: Prisma.$HistorialPayload<ExtArgs>
        fields: Prisma.HistorialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistorialFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistorialFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          findFirst: {
            args: Prisma.HistorialFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistorialFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          findMany: {
            args: Prisma.HistorialFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>[]
          }
          create: {
            args: Prisma.HistorialCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          createMany: {
            args: Prisma.HistorialCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HistorialDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          update: {
            args: Prisma.HistorialUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          deleteMany: {
            args: Prisma.HistorialDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HistorialUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HistorialUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialPayload>
          }
          aggregate: {
            args: Prisma.HistorialAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial>
          }
          groupBy: {
            args: Prisma.HistorialGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HistorialGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistorialCountArgs<ExtArgs>,
            result: $Utils.Optional<HistorialCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    encabezadoCompras: number
    Traslado: number
    Historial: number
    invUsuarioRegistro: number
    invUsuarioActualizo: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encabezadoCompras?: boolean | UsuarioCountOutputTypeCountEncabezadoComprasArgs
    Traslado?: boolean | UsuarioCountOutputTypeCountTrasladoArgs
    Historial?: boolean | UsuarioCountOutputTypeCountHistorialArgs
    invUsuarioRegistro?: boolean | UsuarioCountOutputTypeCountInvUsuarioRegistroArgs
    invUsuarioActualizo?: boolean | UsuarioCountOutputTypeCountInvUsuarioActualizoArgs
  }

  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEncabezadoComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoCompraWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountTrasladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountInvUsuarioRegistroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountInvUsuarioActualizoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }



  /**
   * Count Type EstadoCountOutputType
   */

  export type EstadoCountOutputType = {
    pedidos: number
    Traslado: number
  }

  export type EstadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | EstadoCountOutputTypeCountPedidosArgs
    Traslado?: boolean | EstadoCountOutputTypeCountTrasladoArgs
  }

  // Custom InputTypes

  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCountOutputType
     */
    select?: EstadoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }


  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeCountTrasladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoWhereInput
  }



  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    subCategoria: number
    producto: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategoria?: boolean | CategoriaCountOutputTypeCountSubCategoriaArgs
    producto?: boolean | CategoriaCountOutputTypeCountProductoArgs
  }

  // Custom InputTypes

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountSubCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoriaWhereInput
  }


  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
  }



  /**
   * Count Type SubCategoriaCountOutputType
   */

  export type SubCategoriaCountOutputType = {
    producto: number
    categorias: number
  }

  export type SubCategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | SubCategoriaCountOutputTypeCountProductoArgs
    categorias?: boolean | SubCategoriaCountOutputTypeCountCategoriasArgs
  }

  // Custom InputTypes

  /**
   * SubCategoriaCountOutputType without action
   */
  export type SubCategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoriaCountOutputType
     */
    select?: SubCategoriaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SubCategoriaCountOutputType without action
   */
  export type SubCategoriaCountOutputTypeCountProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
  }


  /**
   * SubCategoriaCountOutputType without action
   */
  export type SubCategoriaCountOutputTypeCountCategoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
  }



  /**
   * Count Type ProductoCountOutputType
   */

  export type ProductoCountOutputType = {
    foto: number
    bodegaProductos: number
    detalleCompras: number
    Historial: number
    Traslado: number
  }

  export type ProductoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foto?: boolean | ProductoCountOutputTypeCountFotoArgs
    bodegaProductos?: boolean | ProductoCountOutputTypeCountBodegaProductosArgs
    detalleCompras?: boolean | ProductoCountOutputTypeCountDetalleComprasArgs
    Historial?: boolean | ProductoCountOutputTypeCountHistorialArgs
    Traslado?: boolean | ProductoCountOutputTypeCountTrasladoArgs
  }

  // Custom InputTypes

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     */
    select?: ProductoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountFotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FotoWhereInput
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountBodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountDetalleComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleCompraWhereInput
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialWhereInput
  }


  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountTrasladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoWhereInput
  }



  /**
   * Count Type UbicacionCountOutputType
   */

  export type UbicacionCountOutputType = {
    proveedor: number
    bodega: number
  }

  export type UbicacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proveedor?: boolean | UbicacionCountOutputTypeCountProveedorArgs
    bodega?: boolean | UbicacionCountOutputTypeCountBodegaArgs
  }

  // Custom InputTypes

  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UbicacionCountOutputType
     */
    select?: UbicacionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeCountProveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProveedorWhereInput
  }


  /**
   * UbicacionCountOutputType without action
   */
  export type UbicacionCountOutputTypeCountBodegaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodegaWhereInput
  }



  /**
   * Count Type BodegaCountOutputType
   */

  export type BodegaCountOutputType = {
    usuario: number
    inventario: number
    detalleCompra: number
    Historial: number
    TrasladoOrigen: number
    TrasladoDestino: number
  }

  export type BodegaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | BodegaCountOutputTypeCountUsuarioArgs
    inventario?: boolean | BodegaCountOutputTypeCountInventarioArgs
    detalleCompra?: boolean | BodegaCountOutputTypeCountDetalleCompraArgs
    Historial?: boolean | BodegaCountOutputTypeCountHistorialArgs
    TrasladoOrigen?: boolean | BodegaCountOutputTypeCountTrasladoOrigenArgs
    TrasladoDestino?: boolean | BodegaCountOutputTypeCountTrasladoDestinoArgs
  }

  // Custom InputTypes

  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodegaCountOutputType
     */
    select?: BodegaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountInventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountDetalleCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleCompraWhereInput
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialWhereInput
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountTrasladoOrigenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoWhereInput
  }


  /**
   * BodegaCountOutputType without action
   */
  export type BodegaCountOutputTypeCountTrasladoDestinoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoWhereInput
  }



  /**
   * Count Type ProveedorCountOutputType
   */

  export type ProveedorCountOutputType = {
    encabezadoCompra: number
  }

  export type ProveedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encabezadoCompra?: boolean | ProveedorCountOutputTypeCountEncabezadoCompraArgs
  }

  // Custom InputTypes

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProveedorCountOutputType
     */
    select?: ProveedorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeCountEncabezadoCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoCompraWhereInput
  }



  /**
   * Count Type EncabezadoCompraCountOutputType
   */

  export type EncabezadoCompraCountOutputType = {
    detalleCompra: number
    pedido: number
  }

  export type EncabezadoCompraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalleCompra?: boolean | EncabezadoCompraCountOutputTypeCountDetalleCompraArgs
    pedido?: boolean | EncabezadoCompraCountOutputTypeCountPedidoArgs
  }

  // Custom InputTypes

  /**
   * EncabezadoCompraCountOutputType without action
   */
  export type EncabezadoCompraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompraCountOutputType
     */
    select?: EncabezadoCompraCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EncabezadoCompraCountOutputType without action
   */
  export type EncabezadoCompraCountOutputTypeCountDetalleCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleCompraWhereInput
  }


  /**
   * EncabezadoCompraCountOutputType without action
   */
  export type EncabezadoCompraCountOutputTypeCountPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    idBodega: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    idBodega: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    correo: string | null
    contrasenna: string | null
    fechaRegistro: Date | null
    rol: $Enums.Rol | null
    idBodega: number | null
    estado: boolean | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    correo: string | null
    contrasenna: string | null
    fechaRegistro: Date | null
    rol: $Enums.Rol | null
    idBodega: number | null
    estado: boolean | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    apellidos: number
    correo: number
    contrasenna: number
    fechaRegistro: number
    rol: number
    idBodega: number
    estado: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    idBodega?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    idBodega?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    correo?: true
    contrasenna?: true
    fechaRegistro?: true
    rol?: true
    idBodega?: true
    estado?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    correo?: true
    contrasenna?: true
    fechaRegistro?: true
    rol?: true
    idBodega?: true
    estado?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    correo?: true
    contrasenna?: true
    fechaRegistro?: true
    rol?: true
    idBodega?: true
    estado?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro: Date
    rol: $Enums.Rol
    idBodega: number | null
    estado: boolean
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    correo?: boolean
    contrasenna?: boolean
    fechaRegistro?: boolean
    rol?: boolean
    idBodega?: boolean
    estado?: boolean
    encabezadoCompras?: boolean | Usuario$encabezadoComprasArgs<ExtArgs>
    Traslado?: boolean | Usuario$TrasladoArgs<ExtArgs>
    Historial?: boolean | Usuario$HistorialArgs<ExtArgs>
    invUsuarioRegistro?: boolean | Usuario$invUsuarioRegistroArgs<ExtArgs>
    invUsuarioActualizo?: boolean | Usuario$invUsuarioActualizoArgs<ExtArgs>
    bodega?: boolean | Usuario$bodegaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    correo?: boolean
    contrasenna?: boolean
    fechaRegistro?: boolean
    rol?: boolean
    idBodega?: boolean
    estado?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encabezadoCompras?: boolean | Usuario$encabezadoComprasArgs<ExtArgs>
    Traslado?: boolean | Usuario$TrasladoArgs<ExtArgs>
    Historial?: boolean | Usuario$HistorialArgs<ExtArgs>
    invUsuarioRegistro?: boolean | Usuario$invUsuarioRegistroArgs<ExtArgs>
    invUsuarioActualizo?: boolean | Usuario$invUsuarioActualizoArgs<ExtArgs>
    bodega?: boolean | Usuario$bodegaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      encabezadoCompras: Prisma.$EncabezadoCompraPayload<ExtArgs>[]
      Traslado: Prisma.$TrasladoPayload<ExtArgs>[]
      Historial: Prisma.$HistorialPayload<ExtArgs>[]
      invUsuarioRegistro: Prisma.$InventarioPayload<ExtArgs>[]
      invUsuarioActualizo: Prisma.$InventarioPayload<ExtArgs>[]
      bodega: Prisma.$BodegaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellidos: string
      correo: string
      contrasenna: string
      fechaRegistro: Date
      rol: $Enums.Rol
      idBodega: number | null
      estado: boolean
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }


  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    encabezadoCompras<T extends Usuario$encabezadoComprasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$encabezadoComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    Traslado<T extends Usuario$TrasladoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$TrasladoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findMany'> | Null>;

    Historial<T extends Usuario$HistorialArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$HistorialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findMany'> | Null>;

    invUsuarioRegistro<T extends Usuario$invUsuarioRegistroArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$invUsuarioRegistroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    invUsuarioActualizo<T extends Usuario$invUsuarioActualizoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$invUsuarioActualizoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    bodega<T extends Usuario$bodegaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$bodegaArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellidos: FieldRef<"Usuario", 'String'>
    readonly correo: FieldRef<"Usuario", 'String'>
    readonly contrasenna: FieldRef<"Usuario", 'String'>
    readonly fechaRegistro: FieldRef<"Usuario", 'DateTime'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly idBodega: FieldRef<"Usuario", 'Int'>
    readonly estado: FieldRef<"Usuario", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario.encabezadoCompras
   */
  export type Usuario$encabezadoComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    where?: EncabezadoCompraWhereInput
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    cursor?: EncabezadoCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * Usuario.Traslado
   */
  export type Usuario$TrasladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    where?: TrasladoWhereInput
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    cursor?: TrasladoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoScalarFieldEnum | TrasladoScalarFieldEnum[]
  }


  /**
   * Usuario.Historial
   */
  export type Usuario$HistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    where?: HistorialWhereInput
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    cursor?: HistorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Usuario.invUsuarioRegistro
   */
  export type Usuario$invUsuarioRegistroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * Usuario.invUsuarioActualizo
   */
  export type Usuario$invUsuarioActualizoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * Usuario.bodega
   */
  export type Usuario$bodegaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    where?: BodegaWhereInput
  }


  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
  }



  /**
   * Model Estado
   */

  export type AggregateEstado = {
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  export type EstadoAvgAggregateOutputType = {
    id: number | null
  }

  export type EstadoSumAggregateOutputType = {
    id: number | null
  }

  export type EstadoMinAggregateOutputType = {
    id: number | null
    estado: string | null
  }

  export type EstadoMaxAggregateOutputType = {
    id: number | null
    estado: string | null
  }

  export type EstadoCountAggregateOutputType = {
    id: number
    estado: number
    _all: number
  }


  export type EstadoAvgAggregateInputType = {
    id?: true
  }

  export type EstadoSumAggregateInputType = {
    id?: true
  }

  export type EstadoMinAggregateInputType = {
    id?: true
    estado?: true
  }

  export type EstadoMaxAggregateInputType = {
    id?: true
    estado?: true
  }

  export type EstadoCountAggregateInputType = {
    id?: true
    estado?: true
    _all?: true
  }

  export type EstadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estado to aggregate.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estados
    **/
    _count?: true | EstadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoMaxAggregateInputType
  }

  export type GetEstadoAggregateType<T extends EstadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEstado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstado[P]>
      : GetScalarType<T[P], AggregateEstado[P]>
  }




  export type EstadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstadoWhereInput
    orderBy?: EstadoOrderByWithAggregationInput | EstadoOrderByWithAggregationInput[]
    by: EstadoScalarFieldEnum[] | EstadoScalarFieldEnum
    having?: EstadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoCountAggregateInputType | true
    _avg?: EstadoAvgAggregateInputType
    _sum?: EstadoSumAggregateInputType
    _min?: EstadoMinAggregateInputType
    _max?: EstadoMaxAggregateInputType
  }

  export type EstadoGroupByOutputType = {
    id: number
    estado: string
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  type GetEstadoGroupByPayload<T extends EstadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoGroupByOutputType[P]>
        }
      >
    >


  export type EstadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estado?: boolean
    pedidos?: boolean | Estado$pedidosArgs<ExtArgs>
    Traslado?: boolean | Estado$TrasladoArgs<ExtArgs>
    _count?: boolean | EstadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estado"]>

  export type EstadoSelectScalar = {
    id?: boolean
    estado?: boolean
  }

  export type EstadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | Estado$pedidosArgs<ExtArgs>
    Traslado?: boolean | Estado$TrasladoArgs<ExtArgs>
    _count?: boolean | EstadoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EstadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estado"
    objects: {
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
      Traslado: Prisma.$TrasladoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      estado: string
    }, ExtArgs["result"]["estado"]>
    composites: {}
  }


  type EstadoGetPayload<S extends boolean | null | undefined | EstadoDefaultArgs> = $Result.GetResult<Prisma.$EstadoPayload, S>

  type EstadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstadoCountAggregateInputType | true
    }

  export interface EstadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estado'], meta: { name: 'Estado' } }
    /**
     * Find zero or one Estado that matches the filter.
     * @param {EstadoFindUniqueArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EstadoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoFindUniqueArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Estado that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EstadoFindUniqueOrThrowArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EstadoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Estado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindFirstArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EstadoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoFindFirstArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Estado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindFirstOrThrowArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EstadoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estados
     * const estados = await prisma.estado.findMany()
     * 
     * // Get first 10 Estados
     * const estados = await prisma.estado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadoWithIdOnly = await prisma.estado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EstadoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Estado.
     * @param {EstadoCreateArgs} args - Arguments to create a Estado.
     * @example
     * // Create one Estado
     * const Estado = await prisma.estado.create({
     *   data: {
     *     // ... data to create a Estado
     *   }
     * })
     * 
    **/
    create<T extends EstadoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoCreateArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Estados.
     *     @param {EstadoCreateManyArgs} args - Arguments to create many Estados.
     *     @example
     *     // Create many Estados
     *     const estado = await prisma.estado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EstadoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estado.
     * @param {EstadoDeleteArgs} args - Arguments to delete one Estado.
     * @example
     * // Delete one Estado
     * const Estado = await prisma.estado.delete({
     *   where: {
     *     // ... filter to delete one Estado
     *   }
     * })
     * 
    **/
    delete<T extends EstadoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoDeleteArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Estado.
     * @param {EstadoUpdateArgs} args - Arguments to update one Estado.
     * @example
     * // Update one Estado
     * const estado = await prisma.estado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstadoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoUpdateArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Estados.
     * @param {EstadoDeleteManyArgs} args - Arguments to filter Estados to delete.
     * @example
     * // Delete a few Estados
     * const { count } = await prisma.estado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstadoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EstadoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estados
     * const estado = await prisma.estado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstadoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estado.
     * @param {EstadoUpsertArgs} args - Arguments to update or create a Estado.
     * @example
     * // Update or create a Estado
     * const estado = await prisma.estado.upsert({
     *   create: {
     *     // ... data to create a Estado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estado we want to update
     *   }
     * })
    **/
    upsert<T extends EstadoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EstadoUpsertArgs<ExtArgs>>
    ): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCountArgs} args - Arguments to filter Estados to count.
     * @example
     * // Count the number of Estados
     * const count = await prisma.estado.count({
     *   where: {
     *     // ... the filter for the Estados we want to count
     *   }
     * })
    **/
    count<T extends EstadoCountArgs>(
      args?: Subset<T, EstadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoAggregateArgs>(args: Subset<T, EstadoAggregateArgs>): Prisma.PrismaPromise<GetEstadoAggregateType<T>>

    /**
     * Group by Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoGroupByArgs['orderBy'] }
        : { orderBy?: EstadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estado model
   */
  readonly fields: EstadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pedidos<T extends Estado$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, Estado$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'> | Null>;

    Traslado<T extends Estado$TrasladoArgs<ExtArgs> = {}>(args?: Subset<T, Estado$TrasladoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Estado model
   */ 
  interface EstadoFieldRefs {
    readonly id: FieldRef<"Estado", 'Int'>
    readonly estado: FieldRef<"Estado", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Estado findUnique
   */
  export type EstadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado findUniqueOrThrow
   */
  export type EstadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado findFirst
   */
  export type EstadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estados.
     */
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }


  /**
   * Estado findFirstOrThrow
   */
  export type EstadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estados.
     */
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }


  /**
   * Estado findMany
   */
  export type EstadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estados to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }


  /**
   * Estado create
   */
  export type EstadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The data needed to create a Estado.
     */
    data: XOR<EstadoCreateInput, EstadoUncheckedCreateInput>
  }


  /**
   * Estado createMany
   */
  export type EstadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estados.
     */
    data: EstadoCreateManyInput | EstadoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Estado update
   */
  export type EstadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The data needed to update a Estado.
     */
    data: XOR<EstadoUpdateInput, EstadoUncheckedUpdateInput>
    /**
     * Choose, which Estado to update.
     */
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado updateMany
   */
  export type EstadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estados.
     */
    data: XOR<EstadoUpdateManyMutationInput, EstadoUncheckedUpdateManyInput>
    /**
     * Filter which Estados to update
     */
    where?: EstadoWhereInput
  }


  /**
   * Estado upsert
   */
  export type EstadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The filter to search for the Estado to update in case it exists.
     */
    where: EstadoWhereUniqueInput
    /**
     * In case the Estado found by the `where` argument doesn't exist, create a new Estado with this data.
     */
    create: XOR<EstadoCreateInput, EstadoUncheckedCreateInput>
    /**
     * In case the Estado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstadoUpdateInput, EstadoUncheckedUpdateInput>
  }


  /**
   * Estado delete
   */
  export type EstadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter which Estado to delete.
     */
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado deleteMany
   */
  export type EstadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estados to delete
     */
    where?: EstadoWhereInput
  }


  /**
   * Estado.pedidos
   */
  export type Estado$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Estado.Traslado
   */
  export type Estado$TrasladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    where?: TrasladoWhereInput
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    cursor?: TrasladoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoScalarFieldEnum | TrasladoScalarFieldEnum[]
  }


  /**
   * Estado without action
   */
  export type EstadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EstadoInclude<ExtArgs> | null
  }



  /**
   * Model Categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithAggregationInput | CategoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    id: number
    nombre: string
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    subCategoria?: boolean | Categoria$subCategoriaArgs<ExtArgs>
    producto?: boolean | Categoria$productoArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type CategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategoria?: boolean | Categoria$subCategoriaArgs<ExtArgs>
    producto?: boolean | Categoria$productoArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categoria"
    objects: {
      subCategoria: Prisma.$SubCategoriaPayload<ExtArgs>[]
      producto: Prisma.$ProductoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }


  type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaDefaultArgs> = $Result.GetResult<Prisma.$CategoriaPayload, S>

  type CategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface CategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categoria'], meta: { name: 'Categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Categoria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaFindFirstArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
    **/
    create<T extends CategoriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaCreateArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categorias.
     *     @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     *     @example
     *     // Create many Categorias
     *     const categoria = await prisma.categoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
    **/
    delete<T extends CategoriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaDeleteArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaUpdateArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriaUpsertArgs<ExtArgs>>
    ): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categoria model
   */
  readonly fields: CategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    subCategoria<T extends Categoria$subCategoriaArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$subCategoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findMany'> | Null>;

    producto<T extends Categoria$productoArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$productoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Categoria model
   */ 
  interface CategoriaFieldRefs {
    readonly id: FieldRef<"Categoria", 'Int'>
    readonly nombre: FieldRef<"Categoria", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * Categoria create
   */
  export type CategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }


  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
  }


  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }


  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput
  }


  /**
   * Categoria.subCategoria
   */
  export type Categoria$subCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    where?: SubCategoriaWhereInput
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    cursor?: SubCategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoriaScalarFieldEnum | SubCategoriaScalarFieldEnum[]
  }


  /**
   * Categoria.producto
   */
  export type Categoria$productoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    cursor?: ProductoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * Categoria without action
   */
  export type CategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
  }



  /**
   * Model SubCategoria
   */

  export type AggregateSubCategoria = {
    _count: SubCategoriaCountAggregateOutputType | null
    _avg: SubCategoriaAvgAggregateOutputType | null
    _sum: SubCategoriaSumAggregateOutputType | null
    _min: SubCategoriaMinAggregateOutputType | null
    _max: SubCategoriaMaxAggregateOutputType | null
  }

  export type SubCategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type SubCategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type SubCategoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type SubCategoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type SubCategoriaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type SubCategoriaAvgAggregateInputType = {
    id?: true
  }

  export type SubCategoriaSumAggregateInputType = {
    id?: true
  }

  export type SubCategoriaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type SubCategoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type SubCategoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type SubCategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategoria to aggregate.
     */
    where?: SubCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategorias to fetch.
     */
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategorias
    **/
    _count?: true | SubCategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubCategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubCategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoriaMaxAggregateInputType
  }

  export type GetSubCategoriaAggregateType<T extends SubCategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategoria[P]>
      : GetScalarType<T[P], AggregateSubCategoria[P]>
  }




  export type SubCategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoriaWhereInput
    orderBy?: SubCategoriaOrderByWithAggregationInput | SubCategoriaOrderByWithAggregationInput[]
    by: SubCategoriaScalarFieldEnum[] | SubCategoriaScalarFieldEnum
    having?: SubCategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoriaCountAggregateInputType | true
    _avg?: SubCategoriaAvgAggregateInputType
    _sum?: SubCategoriaSumAggregateInputType
    _min?: SubCategoriaMinAggregateInputType
    _max?: SubCategoriaMaxAggregateInputType
  }

  export type SubCategoriaGroupByOutputType = {
    id: number
    nombre: string
    _count: SubCategoriaCountAggregateOutputType | null
    _avg: SubCategoriaAvgAggregateOutputType | null
    _sum: SubCategoriaSumAggregateOutputType | null
    _min: SubCategoriaMinAggregateOutputType | null
    _max: SubCategoriaMaxAggregateOutputType | null
  }

  type GetSubCategoriaGroupByPayload<T extends SubCategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubCategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoriaGroupByOutputType[P]>
        }
      >
    >


  export type SubCategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    producto?: boolean | SubCategoria$productoArgs<ExtArgs>
    categorias?: boolean | SubCategoria$categoriasArgs<ExtArgs>
    _count?: boolean | SubCategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategoria"]>

  export type SubCategoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type SubCategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | SubCategoria$productoArgs<ExtArgs>
    categorias?: boolean | SubCategoria$categoriasArgs<ExtArgs>
    _count?: boolean | SubCategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SubCategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubCategoria"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>[]
      categorias: Prisma.$CategoriaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["subCategoria"]>
    composites: {}
  }


  type SubCategoriaGetPayload<S extends boolean | null | undefined | SubCategoriaDefaultArgs> = $Result.GetResult<Prisma.$SubCategoriaPayload, S>

  type SubCategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubCategoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubCategoriaCountAggregateInputType | true
    }

  export interface SubCategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubCategoria'], meta: { name: 'SubCategoria' } }
    /**
     * Find zero or one SubCategoria that matches the filter.
     * @param {SubCategoriaFindUniqueArgs} args - Arguments to find a SubCategoria
     * @example
     * // Get one SubCategoria
     * const subCategoria = await prisma.subCategoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubCategoriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaFindUniqueArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SubCategoria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubCategoriaFindUniqueOrThrowArgs} args - Arguments to find a SubCategoria
     * @example
     * // Get one SubCategoria
     * const subCategoria = await prisma.subCategoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubCategoriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SubCategoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaFindFirstArgs} args - Arguments to find a SubCategoria
     * @example
     * // Get one SubCategoria
     * const subCategoria = await prisma.subCategoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubCategoriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaFindFirstArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SubCategoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaFindFirstOrThrowArgs} args - Arguments to find a SubCategoria
     * @example
     * // Get one SubCategoria
     * const subCategoria = await prisma.subCategoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubCategoriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SubCategorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategorias
     * const subCategorias = await prisma.subCategoria.findMany()
     * 
     * // Get first 10 SubCategorias
     * const subCategorias = await prisma.subCategoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoriaWithIdOnly = await prisma.subCategoria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubCategoriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SubCategoria.
     * @param {SubCategoriaCreateArgs} args - Arguments to create a SubCategoria.
     * @example
     * // Create one SubCategoria
     * const SubCategoria = await prisma.subCategoria.create({
     *   data: {
     *     // ... data to create a SubCategoria
     *   }
     * })
     * 
    **/
    create<T extends SubCategoriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaCreateArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SubCategorias.
     *     @param {SubCategoriaCreateManyArgs} args - Arguments to create many SubCategorias.
     *     @example
     *     // Create many SubCategorias
     *     const subCategoria = await prisma.subCategoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubCategoriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategoria.
     * @param {SubCategoriaDeleteArgs} args - Arguments to delete one SubCategoria.
     * @example
     * // Delete one SubCategoria
     * const SubCategoria = await prisma.subCategoria.delete({
     *   where: {
     *     // ... filter to delete one SubCategoria
     *   }
     * })
     * 
    **/
    delete<T extends SubCategoriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaDeleteArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SubCategoria.
     * @param {SubCategoriaUpdateArgs} args - Arguments to update one SubCategoria.
     * @example
     * // Update one SubCategoria
     * const subCategoria = await prisma.subCategoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubCategoriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaUpdateArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SubCategorias.
     * @param {SubCategoriaDeleteManyArgs} args - Arguments to filter SubCategorias to delete.
     * @example
     * // Delete a few SubCategorias
     * const { count } = await prisma.subCategoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubCategoriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategorias
     * const subCategoria = await prisma.subCategoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubCategoriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategoria.
     * @param {SubCategoriaUpsertArgs} args - Arguments to update or create a SubCategoria.
     * @example
     * // Update or create a SubCategoria
     * const subCategoria = await prisma.subCategoria.upsert({
     *   create: {
     *     // ... data to create a SubCategoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategoria we want to update
     *   }
     * })
    **/
    upsert<T extends SubCategoriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoriaUpsertArgs<ExtArgs>>
    ): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SubCategorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaCountArgs} args - Arguments to filter SubCategorias to count.
     * @example
     * // Count the number of SubCategorias
     * const count = await prisma.subCategoria.count({
     *   where: {
     *     // ... the filter for the SubCategorias we want to count
     *   }
     * })
    **/
    count<T extends SubCategoriaCountArgs>(
      args?: Subset<T, SubCategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoriaAggregateArgs>(args: Subset<T, SubCategoriaAggregateArgs>): Prisma.PrismaPromise<GetSubCategoriaAggregateType<T>>

    /**
     * Group by SubCategoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoriaGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubCategoria model
   */
  readonly fields: SubCategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubCategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    producto<T extends SubCategoria$productoArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoria$productoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findMany'> | Null>;

    categorias<T extends SubCategoria$categoriasArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoria$categoriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SubCategoria model
   */ 
  interface SubCategoriaFieldRefs {
    readonly id: FieldRef<"SubCategoria", 'Int'>
    readonly nombre: FieldRef<"SubCategoria", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SubCategoria findUnique
   */
  export type SubCategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoria to fetch.
     */
    where: SubCategoriaWhereUniqueInput
  }


  /**
   * SubCategoria findUniqueOrThrow
   */
  export type SubCategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoria to fetch.
     */
    where: SubCategoriaWhereUniqueInput
  }


  /**
   * SubCategoria findFirst
   */
  export type SubCategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoria to fetch.
     */
    where?: SubCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategorias to fetch.
     */
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategorias.
     */
    cursor?: SubCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategorias.
     */
    distinct?: SubCategoriaScalarFieldEnum | SubCategoriaScalarFieldEnum[]
  }


  /**
   * SubCategoria findFirstOrThrow
   */
  export type SubCategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoria to fetch.
     */
    where?: SubCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategorias to fetch.
     */
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategorias.
     */
    cursor?: SubCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategorias.
     */
    distinct?: SubCategoriaScalarFieldEnum | SubCategoriaScalarFieldEnum[]
  }


  /**
   * SubCategoria findMany
   */
  export type SubCategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which SubCategorias to fetch.
     */
    where?: SubCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategorias to fetch.
     */
    orderBy?: SubCategoriaOrderByWithRelationInput | SubCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategorias.
     */
    cursor?: SubCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategorias.
     */
    skip?: number
    distinct?: SubCategoriaScalarFieldEnum | SubCategoriaScalarFieldEnum[]
  }


  /**
   * SubCategoria create
   */
  export type SubCategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a SubCategoria.
     */
    data: XOR<SubCategoriaCreateInput, SubCategoriaUncheckedCreateInput>
  }


  /**
   * SubCategoria createMany
   */
  export type SubCategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubCategorias.
     */
    data: SubCategoriaCreateManyInput | SubCategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SubCategoria update
   */
  export type SubCategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a SubCategoria.
     */
    data: XOR<SubCategoriaUpdateInput, SubCategoriaUncheckedUpdateInput>
    /**
     * Choose, which SubCategoria to update.
     */
    where: SubCategoriaWhereUniqueInput
  }


  /**
   * SubCategoria updateMany
   */
  export type SubCategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubCategorias.
     */
    data: XOR<SubCategoriaUpdateManyMutationInput, SubCategoriaUncheckedUpdateManyInput>
    /**
     * Filter which SubCategorias to update
     */
    where?: SubCategoriaWhereInput
  }


  /**
   * SubCategoria upsert
   */
  export type SubCategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the SubCategoria to update in case it exists.
     */
    where: SubCategoriaWhereUniqueInput
    /**
     * In case the SubCategoria found by the `where` argument doesn't exist, create a new SubCategoria with this data.
     */
    create: XOR<SubCategoriaCreateInput, SubCategoriaUncheckedCreateInput>
    /**
     * In case the SubCategoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoriaUpdateInput, SubCategoriaUncheckedUpdateInput>
  }


  /**
   * SubCategoria delete
   */
  export type SubCategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
    /**
     * Filter which SubCategoria to delete.
     */
    where: SubCategoriaWhereUniqueInput
  }


  /**
   * SubCategoria deleteMany
   */
  export type SubCategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategorias to delete
     */
    where?: SubCategoriaWhereInput
  }


  /**
   * SubCategoria.producto
   */
  export type SubCategoria$productoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    cursor?: ProductoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * SubCategoria.categorias
   */
  export type SubCategoria$categoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    cursor?: CategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * SubCategoria without action
   */
  export type SubCategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoria
     */
    select?: SubCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoriaInclude<ExtArgs> | null
  }



  /**
   * Model Producto
   */

  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    id: number | null
    stock: number | null
    precio: Decimal | null
    idCategoria: number | null
    idSubCategoria: number | null
  }

  export type ProductoSumAggregateOutputType = {
    id: number | null
    stock: number | null
    precio: Decimal | null
    idCategoria: number | null
    idSubCategoria: number | null
  }

  export type ProductoMinAggregateOutputType = {
    id: number | null
    codigoProducto: string | null
    nombre: string | null
    descripcion: string | null
    stock: number | null
    precio: Decimal | null
    estadoProducto: boolean | null
    idCategoria: number | null
    idSubCategoria: number | null
  }

  export type ProductoMaxAggregateOutputType = {
    id: number | null
    codigoProducto: string | null
    nombre: string | null
    descripcion: string | null
    stock: number | null
    precio: Decimal | null
    estadoProducto: boolean | null
    idCategoria: number | null
    idSubCategoria: number | null
  }

  export type ProductoCountAggregateOutputType = {
    id: number
    codigoProducto: number
    nombre: number
    descripcion: number
    stock: number
    precio: number
    estadoProducto: number
    idCategoria: number
    idSubCategoria: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    id?: true
    stock?: true
    precio?: true
    idCategoria?: true
    idSubCategoria?: true
  }

  export type ProductoSumAggregateInputType = {
    id?: true
    stock?: true
    precio?: true
    idCategoria?: true
    idSubCategoria?: true
  }

  export type ProductoMinAggregateInputType = {
    id?: true
    codigoProducto?: true
    nombre?: true
    descripcion?: true
    stock?: true
    precio?: true
    estadoProducto?: true
    idCategoria?: true
    idSubCategoria?: true
  }

  export type ProductoMaxAggregateInputType = {
    id?: true
    codigoProducto?: true
    nombre?: true
    descripcion?: true
    stock?: true
    precio?: true
    estadoProducto?: true
    idCategoria?: true
    idSubCategoria?: true
  }

  export type ProductoCountAggregateInputType = {
    id?: true
    codigoProducto?: true
    nombre?: true
    descripcion?: true
    stock?: true
    precio?: true
    estadoProducto?: true
    idCategoria?: true
    idSubCategoria?: true
    _all?: true
  }

  export type ProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Producto to aggregate.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithAggregationInput | ProductoOrderByWithAggregationInput[]
    by: ProductoScalarFieldEnum[] | ProductoScalarFieldEnum
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }

  export type ProductoGroupByOutputType = {
    id: number
    codigoProducto: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal
    estadoProducto: boolean
    idCategoria: number
    idSubCategoria: number
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoProducto?: boolean
    nombre?: boolean
    descripcion?: boolean
    stock?: boolean
    precio?: boolean
    estadoProducto?: boolean
    idCategoria?: boolean
    idSubCategoria?: boolean
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    foto?: boolean | Producto$fotoArgs<ExtArgs>
    bodegaProductos?: boolean | Producto$bodegaProductosArgs<ExtArgs>
    detalleCompras?: boolean | Producto$detalleComprasArgs<ExtArgs>
    Historial?: boolean | Producto$HistorialArgs<ExtArgs>
    Traslado?: boolean | Producto$TrasladoArgs<ExtArgs>
    subCategorias?: boolean | SubCategoriaDefaultArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>

  export type ProductoSelectScalar = {
    id?: boolean
    codigoProducto?: boolean
    nombre?: boolean
    descripcion?: boolean
    stock?: boolean
    precio?: boolean
    estadoProducto?: boolean
    idCategoria?: boolean
    idSubCategoria?: boolean
  }

  export type ProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    foto?: boolean | Producto$fotoArgs<ExtArgs>
    bodegaProductos?: boolean | Producto$bodegaProductosArgs<ExtArgs>
    detalleCompras?: boolean | Producto$detalleComprasArgs<ExtArgs>
    Historial?: boolean | Producto$HistorialArgs<ExtArgs>
    Traslado?: boolean | Producto$TrasladoArgs<ExtArgs>
    subCategorias?: boolean | SubCategoriaDefaultArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Producto"
    objects: {
      categoria: Prisma.$CategoriaPayload<ExtArgs>
      foto: Prisma.$FotoPayload<ExtArgs>[]
      bodegaProductos: Prisma.$InventarioPayload<ExtArgs>[]
      detalleCompras: Prisma.$DetalleCompraPayload<ExtArgs>[]
      Historial: Prisma.$HistorialPayload<ExtArgs>[]
      Traslado: Prisma.$TrasladoPayload<ExtArgs>[]
      subCategorias: Prisma.$SubCategoriaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigoProducto: string | null
      nombre: string
      descripcion: string
      stock: number
      precio: Prisma.Decimal
      estadoProducto: boolean
      idCategoria: number
      idSubCategoria: number
    }, ExtArgs["result"]["producto"]>
    composites: {}
  }


  type ProductoGetPayload<S extends boolean | null | undefined | ProductoDefaultArgs> = $Result.GetResult<Prisma.$ProductoPayload, S>

  type ProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductoCountAggregateInputType | true
    }

  export interface ProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Producto'], meta: { name: 'Producto' } }
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Producto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoFindFirstArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Producto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
    **/
    create<T extends ProductoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoCreateArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Productos.
     *     @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     *     @example
     *     // Create many Productos
     *     const producto = await prisma.producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
    **/
    delete<T extends ProductoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoDeleteArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoUpdateArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
    **/
    upsert<T extends ProductoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductoUpsertArgs<ExtArgs>>
    ): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): Prisma.PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Producto model
   */
  readonly fields: ProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    categoria<T extends CategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaDefaultArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    foto<T extends Producto$fotoArgs<ExtArgs> = {}>(args?: Subset<T, Producto$fotoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    bodegaProductos<T extends Producto$bodegaProductosArgs<ExtArgs> = {}>(args?: Subset<T, Producto$bodegaProductosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    detalleCompras<T extends Producto$detalleComprasArgs<ExtArgs> = {}>(args?: Subset<T, Producto$detalleComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    Historial<T extends Producto$HistorialArgs<ExtArgs> = {}>(args?: Subset<T, Producto$HistorialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findMany'> | Null>;

    Traslado<T extends Producto$TrasladoArgs<ExtArgs> = {}>(args?: Subset<T, Producto$TrasladoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findMany'> | Null>;

    subCategorias<T extends SubCategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoriaDefaultArgs<ExtArgs>>): Prisma__SubCategoriaClient<$Result.GetResult<Prisma.$SubCategoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Producto model
   */ 
  interface ProductoFieldRefs {
    readonly id: FieldRef<"Producto", 'Int'>
    readonly codigoProducto: FieldRef<"Producto", 'String'>
    readonly nombre: FieldRef<"Producto", 'String'>
    readonly descripcion: FieldRef<"Producto", 'String'>
    readonly stock: FieldRef<"Producto", 'Int'>
    readonly precio: FieldRef<"Producto", 'Decimal'>
    readonly estadoProducto: FieldRef<"Producto", 'Boolean'>
    readonly idCategoria: FieldRef<"Producto", 'Int'>
    readonly idSubCategoria: FieldRef<"Producto", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Producto findUnique
   */
  export type ProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto findFirst
   */
  export type ProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * Producto findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }


  /**
   * Producto create
   */
  export type ProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a Producto.
     */
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }


  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Producto update
   */
  export type ProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a Producto.
     */
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     */
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productos.
     */
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     */
    where?: ProductoWhereInput
  }


  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the Producto to update in case it exists.
     */
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     */
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }


  /**
   * Producto delete
   */
  export type ProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter which Producto to delete.
     */
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productos to delete
     */
    where?: ProductoWhereInput
  }


  /**
   * Producto.foto
   */
  export type Producto$fotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    where?: FotoWhereInput
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    cursor?: FotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FotoScalarFieldEnum | FotoScalarFieldEnum[]
  }


  /**
   * Producto.bodegaProductos
   */
  export type Producto$bodegaProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * Producto.detalleCompras
   */
  export type Producto$detalleComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    where?: DetalleCompraWhereInput
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    cursor?: DetalleCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * Producto.Historial
   */
  export type Producto$HistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    where?: HistorialWhereInput
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    cursor?: HistorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Producto.Traslado
   */
  export type Producto$TrasladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    where?: TrasladoWhereInput
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    cursor?: TrasladoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoScalarFieldEnum | TrasladoScalarFieldEnum[]
  }


  /**
   * Producto without action
   */
  export type ProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductoInclude<ExtArgs> | null
  }



  /**
   * Model Foto
   */

  export type AggregateFoto = {
    _count: FotoCountAggregateOutputType | null
    _avg: FotoAvgAggregateOutputType | null
    _sum: FotoSumAggregateOutputType | null
    _min: FotoMinAggregateOutputType | null
    _max: FotoMaxAggregateOutputType | null
  }

  export type FotoAvgAggregateOutputType = {
    id: number | null
    idProducto: number | null
  }

  export type FotoSumAggregateOutputType = {
    id: number | null
    idProducto: number | null
  }

  export type FotoMinAggregateOutputType = {
    id: number | null
    idProducto: number | null
    foto: Buffer | null
  }

  export type FotoMaxAggregateOutputType = {
    id: number | null
    idProducto: number | null
    foto: Buffer | null
  }

  export type FotoCountAggregateOutputType = {
    id: number
    idProducto: number
    foto: number
    _all: number
  }


  export type FotoAvgAggregateInputType = {
    id?: true
    idProducto?: true
  }

  export type FotoSumAggregateInputType = {
    id?: true
    idProducto?: true
  }

  export type FotoMinAggregateInputType = {
    id?: true
    idProducto?: true
    foto?: true
  }

  export type FotoMaxAggregateInputType = {
    id?: true
    idProducto?: true
    foto?: true
  }

  export type FotoCountAggregateInputType = {
    id?: true
    idProducto?: true
    foto?: true
    _all?: true
  }

  export type FotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foto to aggregate.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fotos
    **/
    _count?: true | FotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FotoMaxAggregateInputType
  }

  export type GetFotoAggregateType<T extends FotoAggregateArgs> = {
        [P in keyof T & keyof AggregateFoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoto[P]>
      : GetScalarType<T[P], AggregateFoto[P]>
  }




  export type FotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FotoWhereInput
    orderBy?: FotoOrderByWithAggregationInput | FotoOrderByWithAggregationInput[]
    by: FotoScalarFieldEnum[] | FotoScalarFieldEnum
    having?: FotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FotoCountAggregateInputType | true
    _avg?: FotoAvgAggregateInputType
    _sum?: FotoSumAggregateInputType
    _min?: FotoMinAggregateInputType
    _max?: FotoMaxAggregateInputType
  }

  export type FotoGroupByOutputType = {
    id: number
    idProducto: number
    foto: Buffer
    _count: FotoCountAggregateOutputType | null
    _avg: FotoAvgAggregateOutputType | null
    _sum: FotoSumAggregateOutputType | null
    _min: FotoMinAggregateOutputType | null
    _max: FotoMaxAggregateOutputType | null
  }

  type GetFotoGroupByPayload<T extends FotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FotoGroupByOutputType[P]>
            : GetScalarType<T[P], FotoGroupByOutputType[P]>
        }
      >
    >


  export type FotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProducto?: boolean
    foto?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foto"]>

  export type FotoSelectScalar = {
    id?: boolean
    idProducto?: boolean
    foto?: boolean
  }

  export type FotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }


  export type $FotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Foto"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idProducto: number
      foto: Buffer
    }, ExtArgs["result"]["foto"]>
    composites: {}
  }


  type FotoGetPayload<S extends boolean | null | undefined | FotoDefaultArgs> = $Result.GetResult<Prisma.$FotoPayload, S>

  type FotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FotoCountAggregateInputType | true
    }

  export interface FotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Foto'], meta: { name: 'Foto' } }
    /**
     * Find zero or one Foto that matches the filter.
     * @param {FotoFindUniqueArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FotoFindUniqueArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Foto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FotoFindUniqueOrThrowArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Foto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindFirstArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoFindFirstArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Foto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindFirstOrThrowArgs} args - Arguments to find a Foto
     * @example
     * // Get one Foto
     * const foto = await prisma.foto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fotos
     * const fotos = await prisma.foto.findMany()
     * 
     * // Get first 10 Fotos
     * const fotos = await prisma.foto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fotoWithIdOnly = await prisma.foto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Foto.
     * @param {FotoCreateArgs} args - Arguments to create a Foto.
     * @example
     * // Create one Foto
     * const Foto = await prisma.foto.create({
     *   data: {
     *     // ... data to create a Foto
     *   }
     * })
     * 
    **/
    create<T extends FotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FotoCreateArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Fotos.
     *     @param {FotoCreateManyArgs} args - Arguments to create many Fotos.
     *     @example
     *     // Create many Fotos
     *     const foto = await prisma.foto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Foto.
     * @param {FotoDeleteArgs} args - Arguments to delete one Foto.
     * @example
     * // Delete one Foto
     * const Foto = await prisma.foto.delete({
     *   where: {
     *     // ... filter to delete one Foto
     *   }
     * })
     * 
    **/
    delete<T extends FotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FotoDeleteArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Foto.
     * @param {FotoUpdateArgs} args - Arguments to update one Foto.
     * @example
     * // Update one Foto
     * const foto = await prisma.foto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FotoUpdateArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fotos.
     * @param {FotoDeleteManyArgs} args - Arguments to filter Fotos to delete.
     * @example
     * // Delete a few Fotos
     * const { count } = await prisma.foto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fotos
     * const foto = await prisma.foto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foto.
     * @param {FotoUpsertArgs} args - Arguments to update or create a Foto.
     * @example
     * // Update or create a Foto
     * const foto = await prisma.foto.upsert({
     *   create: {
     *     // ... data to create a Foto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foto we want to update
     *   }
     * })
    **/
    upsert<T extends FotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FotoUpsertArgs<ExtArgs>>
    ): Prisma__FotoClient<$Result.GetResult<Prisma.$FotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoCountArgs} args - Arguments to filter Fotos to count.
     * @example
     * // Count the number of Fotos
     * const count = await prisma.foto.count({
     *   where: {
     *     // ... the filter for the Fotos we want to count
     *   }
     * })
    **/
    count<T extends FotoCountArgs>(
      args?: Subset<T, FotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FotoAggregateArgs>(args: Subset<T, FotoAggregateArgs>): Prisma.PrismaPromise<GetFotoAggregateType<T>>

    /**
     * Group by Foto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FotoGroupByArgs['orderBy'] }
        : { orderBy?: FotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Foto model
   */
  readonly fields: FotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Foto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Foto model
   */ 
  interface FotoFieldRefs {
    readonly id: FieldRef<"Foto", 'Int'>
    readonly idProducto: FieldRef<"Foto", 'Int'>
    readonly foto: FieldRef<"Foto", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * Foto findUnique
   */
  export type FotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Foto to fetch.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto findUniqueOrThrow
   */
  export type FotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Foto to fetch.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto findFirst
   */
  export type FotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Foto to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fotos.
     */
    distinct?: FotoScalarFieldEnum | FotoScalarFieldEnum[]
  }


  /**
   * Foto findFirstOrThrow
   */
  export type FotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Foto to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fotos.
     */
    distinct?: FotoScalarFieldEnum | FotoScalarFieldEnum[]
  }


  /**
   * Foto findMany
   */
  export type FotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter, which Fotos to fetch.
     */
    where?: FotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fotos to fetch.
     */
    orderBy?: FotoOrderByWithRelationInput | FotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fotos.
     */
    cursor?: FotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fotos.
     */
    skip?: number
    distinct?: FotoScalarFieldEnum | FotoScalarFieldEnum[]
  }


  /**
   * Foto create
   */
  export type FotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Foto.
     */
    data: XOR<FotoCreateInput, FotoUncheckedCreateInput>
  }


  /**
   * Foto createMany
   */
  export type FotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fotos.
     */
    data: FotoCreateManyInput | FotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Foto update
   */
  export type FotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Foto.
     */
    data: XOR<FotoUpdateInput, FotoUncheckedUpdateInput>
    /**
     * Choose, which Foto to update.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto updateMany
   */
  export type FotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fotos.
     */
    data: XOR<FotoUpdateManyMutationInput, FotoUncheckedUpdateManyInput>
    /**
     * Filter which Fotos to update
     */
    where?: FotoWhereInput
  }


  /**
   * Foto upsert
   */
  export type FotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Foto to update in case it exists.
     */
    where: FotoWhereUniqueInput
    /**
     * In case the Foto found by the `where` argument doesn't exist, create a new Foto with this data.
     */
    create: XOR<FotoCreateInput, FotoUncheckedCreateInput>
    /**
     * In case the Foto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FotoUpdateInput, FotoUncheckedUpdateInput>
  }


  /**
   * Foto delete
   */
  export type FotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
    /**
     * Filter which Foto to delete.
     */
    where: FotoWhereUniqueInput
  }


  /**
   * Foto deleteMany
   */
  export type FotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fotos to delete
     */
    where?: FotoWhereInput
  }


  /**
   * Foto without action
   */
  export type FotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foto
     */
    select?: FotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FotoInclude<ExtArgs> | null
  }



  /**
   * Model Ubicacion
   */

  export type AggregateUbicacion = {
    _count: UbicacionCountAggregateOutputType | null
    _avg: UbicacionAvgAggregateOutputType | null
    _sum: UbicacionSumAggregateOutputType | null
    _min: UbicacionMinAggregateOutputType | null
    _max: UbicacionMaxAggregateOutputType | null
  }

  export type UbicacionAvgAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
  }

  export type UbicacionSumAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
  }

  export type UbicacionMinAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
    direccionExacta: string | null
  }

  export type UbicacionMaxAggregateOutputType = {
    id: number | null
    idProvincia: number | null
    idCanton: number | null
    idDistrito: number | null
    direccionExacta: string | null
  }

  export type UbicacionCountAggregateOutputType = {
    id: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta: number
    _all: number
  }


  export type UbicacionAvgAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
  }

  export type UbicacionSumAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
  }

  export type UbicacionMinAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    direccionExacta?: true
  }

  export type UbicacionMaxAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    direccionExacta?: true
  }

  export type UbicacionCountAggregateInputType = {
    id?: true
    idProvincia?: true
    idCanton?: true
    idDistrito?: true
    direccionExacta?: true
    _all?: true
  }

  export type UbicacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ubicacion to aggregate.
     */
    where?: UbicacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ubicacions to fetch.
     */
    orderBy?: UbicacionOrderByWithRelationInput | UbicacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UbicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ubicacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ubicacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ubicacions
    **/
    _count?: true | UbicacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UbicacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UbicacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UbicacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UbicacionMaxAggregateInputType
  }

  export type GetUbicacionAggregateType<T extends UbicacionAggregateArgs> = {
        [P in keyof T & keyof AggregateUbicacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUbicacion[P]>
      : GetScalarType<T[P], AggregateUbicacion[P]>
  }




  export type UbicacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UbicacionWhereInput
    orderBy?: UbicacionOrderByWithAggregationInput | UbicacionOrderByWithAggregationInput[]
    by: UbicacionScalarFieldEnum[] | UbicacionScalarFieldEnum
    having?: UbicacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UbicacionCountAggregateInputType | true
    _avg?: UbicacionAvgAggregateInputType
    _sum?: UbicacionSumAggregateInputType
    _min?: UbicacionMinAggregateInputType
    _max?: UbicacionMaxAggregateInputType
  }

  export type UbicacionGroupByOutputType = {
    id: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta: string | null
    _count: UbicacionCountAggregateOutputType | null
    _avg: UbicacionAvgAggregateOutputType | null
    _sum: UbicacionSumAggregateOutputType | null
    _min: UbicacionMinAggregateOutputType | null
    _max: UbicacionMaxAggregateOutputType | null
  }

  type GetUbicacionGroupByPayload<T extends UbicacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UbicacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UbicacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UbicacionGroupByOutputType[P]>
            : GetScalarType<T[P], UbicacionGroupByOutputType[P]>
        }
      >
    >


  export type UbicacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProvincia?: boolean
    idCanton?: boolean
    idDistrito?: boolean
    direccionExacta?: boolean
    proveedor?: boolean | Ubicacion$proveedorArgs<ExtArgs>
    bodega?: boolean | Ubicacion$bodegaArgs<ExtArgs>
    _count?: boolean | UbicacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ubicacion"]>

  export type UbicacionSelectScalar = {
    id?: boolean
    idProvincia?: boolean
    idCanton?: boolean
    idDistrito?: boolean
    direccionExacta?: boolean
  }

  export type UbicacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proveedor?: boolean | Ubicacion$proveedorArgs<ExtArgs>
    bodega?: boolean | Ubicacion$bodegaArgs<ExtArgs>
    _count?: boolean | UbicacionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UbicacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ubicacion"
    objects: {
      proveedor: Prisma.$ProveedorPayload<ExtArgs>[]
      bodega: Prisma.$BodegaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idProvincia: number
      idCanton: number
      idDistrito: number
      direccionExacta: string | null
    }, ExtArgs["result"]["ubicacion"]>
    composites: {}
  }


  type UbicacionGetPayload<S extends boolean | null | undefined | UbicacionDefaultArgs> = $Result.GetResult<Prisma.$UbicacionPayload, S>

  type UbicacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UbicacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UbicacionCountAggregateInputType | true
    }

  export interface UbicacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ubicacion'], meta: { name: 'Ubicacion' } }
    /**
     * Find zero or one Ubicacion that matches the filter.
     * @param {UbicacionFindUniqueArgs} args - Arguments to find a Ubicacion
     * @example
     * // Get one Ubicacion
     * const ubicacion = await prisma.ubicacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UbicacionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionFindUniqueArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ubicacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UbicacionFindUniqueOrThrowArgs} args - Arguments to find a Ubicacion
     * @example
     * // Get one Ubicacion
     * const ubicacion = await prisma.ubicacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UbicacionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ubicacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionFindFirstArgs} args - Arguments to find a Ubicacion
     * @example
     * // Get one Ubicacion
     * const ubicacion = await prisma.ubicacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UbicacionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionFindFirstArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ubicacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionFindFirstOrThrowArgs} args - Arguments to find a Ubicacion
     * @example
     * // Get one Ubicacion
     * const ubicacion = await prisma.ubicacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UbicacionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ubicacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ubicacions
     * const ubicacions = await prisma.ubicacion.findMany()
     * 
     * // Get first 10 Ubicacions
     * const ubicacions = await prisma.ubicacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ubicacionWithIdOnly = await prisma.ubicacion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UbicacionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ubicacion.
     * @param {UbicacionCreateArgs} args - Arguments to create a Ubicacion.
     * @example
     * // Create one Ubicacion
     * const Ubicacion = await prisma.ubicacion.create({
     *   data: {
     *     // ... data to create a Ubicacion
     *   }
     * })
     * 
    **/
    create<T extends UbicacionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionCreateArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ubicacions.
     *     @param {UbicacionCreateManyArgs} args - Arguments to create many Ubicacions.
     *     @example
     *     // Create many Ubicacions
     *     const ubicacion = await prisma.ubicacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UbicacionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ubicacion.
     * @param {UbicacionDeleteArgs} args - Arguments to delete one Ubicacion.
     * @example
     * // Delete one Ubicacion
     * const Ubicacion = await prisma.ubicacion.delete({
     *   where: {
     *     // ... filter to delete one Ubicacion
     *   }
     * })
     * 
    **/
    delete<T extends UbicacionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionDeleteArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ubicacion.
     * @param {UbicacionUpdateArgs} args - Arguments to update one Ubicacion.
     * @example
     * // Update one Ubicacion
     * const ubicacion = await prisma.ubicacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UbicacionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionUpdateArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ubicacions.
     * @param {UbicacionDeleteManyArgs} args - Arguments to filter Ubicacions to delete.
     * @example
     * // Delete a few Ubicacions
     * const { count } = await prisma.ubicacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UbicacionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UbicacionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ubicacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ubicacions
     * const ubicacion = await prisma.ubicacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UbicacionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ubicacion.
     * @param {UbicacionUpsertArgs} args - Arguments to update or create a Ubicacion.
     * @example
     * // Update or create a Ubicacion
     * const ubicacion = await prisma.ubicacion.upsert({
     *   create: {
     *     // ... data to create a Ubicacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ubicacion we want to update
     *   }
     * })
    **/
    upsert<T extends UbicacionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UbicacionUpsertArgs<ExtArgs>>
    ): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ubicacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionCountArgs} args - Arguments to filter Ubicacions to count.
     * @example
     * // Count the number of Ubicacions
     * const count = await prisma.ubicacion.count({
     *   where: {
     *     // ... the filter for the Ubicacions we want to count
     *   }
     * })
    **/
    count<T extends UbicacionCountArgs>(
      args?: Subset<T, UbicacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UbicacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ubicacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UbicacionAggregateArgs>(args: Subset<T, UbicacionAggregateArgs>): Prisma.PrismaPromise<GetUbicacionAggregateType<T>>

    /**
     * Group by Ubicacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UbicacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UbicacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UbicacionGroupByArgs['orderBy'] }
        : { orderBy?: UbicacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UbicacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUbicacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ubicacion model
   */
  readonly fields: UbicacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ubicacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UbicacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    proveedor<T extends Ubicacion$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, Ubicacion$proveedorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'findMany'> | Null>;

    bodega<T extends Ubicacion$bodegaArgs<ExtArgs> = {}>(args?: Subset<T, Ubicacion$bodegaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ubicacion model
   */ 
  interface UbicacionFieldRefs {
    readonly id: FieldRef<"Ubicacion", 'Int'>
    readonly idProvincia: FieldRef<"Ubicacion", 'Int'>
    readonly idCanton: FieldRef<"Ubicacion", 'Int'>
    readonly idDistrito: FieldRef<"Ubicacion", 'Int'>
    readonly direccionExacta: FieldRef<"Ubicacion", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Ubicacion findUnique
   */
  export type UbicacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacion to fetch.
     */
    where: UbicacionWhereUniqueInput
  }


  /**
   * Ubicacion findUniqueOrThrow
   */
  export type UbicacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacion to fetch.
     */
    where: UbicacionWhereUniqueInput
  }


  /**
   * Ubicacion findFirst
   */
  export type UbicacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacion to fetch.
     */
    where?: UbicacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ubicacions to fetch.
     */
    orderBy?: UbicacionOrderByWithRelationInput | UbicacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ubicacions.
     */
    cursor?: UbicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ubicacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ubicacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ubicacions.
     */
    distinct?: UbicacionScalarFieldEnum | UbicacionScalarFieldEnum[]
  }


  /**
   * Ubicacion findFirstOrThrow
   */
  export type UbicacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacion to fetch.
     */
    where?: UbicacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ubicacions to fetch.
     */
    orderBy?: UbicacionOrderByWithRelationInput | UbicacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ubicacions.
     */
    cursor?: UbicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ubicacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ubicacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ubicacions.
     */
    distinct?: UbicacionScalarFieldEnum | UbicacionScalarFieldEnum[]
  }


  /**
   * Ubicacion findMany
   */
  export type UbicacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter, which Ubicacions to fetch.
     */
    where?: UbicacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ubicacions to fetch.
     */
    orderBy?: UbicacionOrderByWithRelationInput | UbicacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ubicacions.
     */
    cursor?: UbicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ubicacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ubicacions.
     */
    skip?: number
    distinct?: UbicacionScalarFieldEnum | UbicacionScalarFieldEnum[]
  }


  /**
   * Ubicacion create
   */
  export type UbicacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Ubicacion.
     */
    data: XOR<UbicacionCreateInput, UbicacionUncheckedCreateInput>
  }


  /**
   * Ubicacion createMany
   */
  export type UbicacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ubicacions.
     */
    data: UbicacionCreateManyInput | UbicacionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ubicacion update
   */
  export type UbicacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Ubicacion.
     */
    data: XOR<UbicacionUpdateInput, UbicacionUncheckedUpdateInput>
    /**
     * Choose, which Ubicacion to update.
     */
    where: UbicacionWhereUniqueInput
  }


  /**
   * Ubicacion updateMany
   */
  export type UbicacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ubicacions.
     */
    data: XOR<UbicacionUpdateManyMutationInput, UbicacionUncheckedUpdateManyInput>
    /**
     * Filter which Ubicacions to update
     */
    where?: UbicacionWhereInput
  }


  /**
   * Ubicacion upsert
   */
  export type UbicacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Ubicacion to update in case it exists.
     */
    where: UbicacionWhereUniqueInput
    /**
     * In case the Ubicacion found by the `where` argument doesn't exist, create a new Ubicacion with this data.
     */
    create: XOR<UbicacionCreateInput, UbicacionUncheckedCreateInput>
    /**
     * In case the Ubicacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UbicacionUpdateInput, UbicacionUncheckedUpdateInput>
  }


  /**
   * Ubicacion delete
   */
  export type UbicacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
    /**
     * Filter which Ubicacion to delete.
     */
    where: UbicacionWhereUniqueInput
  }


  /**
   * Ubicacion deleteMany
   */
  export type UbicacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ubicacions to delete
     */
    where?: UbicacionWhereInput
  }


  /**
   * Ubicacion.proveedor
   */
  export type Ubicacion$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    where?: ProveedorWhereInput
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    cursor?: ProveedorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * Ubicacion.bodega
   */
  export type Ubicacion$bodegaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    where?: BodegaWhereInput
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    cursor?: BodegaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BodegaScalarFieldEnum | BodegaScalarFieldEnum[]
  }


  /**
   * Ubicacion without action
   */
  export type UbicacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ubicacion
     */
    select?: UbicacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UbicacionInclude<ExtArgs> | null
  }



  /**
   * Model Bodega
   */

  export type AggregateBodega = {
    _count: BodegaCountAggregateOutputType | null
    _avg: BodegaAvgAggregateOutputType | null
    _sum: BodegaSumAggregateOutputType | null
    _min: BodegaMinAggregateOutputType | null
    _max: BodegaMaxAggregateOutputType | null
  }

  export type BodegaAvgAggregateOutputType = {
    id: number | null
    idUbicacion: number | null
    tamanno: number | null
    capacidad: number | null
  }

  export type BodegaSumAggregateOutputType = {
    id: number | null
    idUbicacion: number | null
    tamanno: number | null
    capacidad: number | null
  }

  export type BodegaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    idUbicacion: number | null
    tamanno: number | null
    capacidad: number | null
    seguridad: boolean | null
  }

  export type BodegaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    idUbicacion: number | null
    tamanno: number | null
    capacidad: number | null
    seguridad: boolean | null
  }

  export type BodegaCountAggregateOutputType = {
    id: number
    nombre: number
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: number
    _all: number
  }


  export type BodegaAvgAggregateInputType = {
    id?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
  }

  export type BodegaSumAggregateInputType = {
    id?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
  }

  export type BodegaMinAggregateInputType = {
    id?: true
    nombre?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
    seguridad?: true
  }

  export type BodegaMaxAggregateInputType = {
    id?: true
    nombre?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
    seguridad?: true
  }

  export type BodegaCountAggregateInputType = {
    id?: true
    nombre?: true
    idUbicacion?: true
    tamanno?: true
    capacidad?: true
    seguridad?: true
    _all?: true
  }

  export type BodegaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bodega to aggregate.
     */
    where?: BodegaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bodegas to fetch.
     */
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BodegaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bodegas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bodegas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bodegas
    **/
    _count?: true | BodegaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BodegaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BodegaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BodegaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BodegaMaxAggregateInputType
  }

  export type GetBodegaAggregateType<T extends BodegaAggregateArgs> = {
        [P in keyof T & keyof AggregateBodega]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBodega[P]>
      : GetScalarType<T[P], AggregateBodega[P]>
  }




  export type BodegaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodegaWhereInput
    orderBy?: BodegaOrderByWithAggregationInput | BodegaOrderByWithAggregationInput[]
    by: BodegaScalarFieldEnum[] | BodegaScalarFieldEnum
    having?: BodegaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BodegaCountAggregateInputType | true
    _avg?: BodegaAvgAggregateInputType
    _sum?: BodegaSumAggregateInputType
    _min?: BodegaMinAggregateInputType
    _max?: BodegaMaxAggregateInputType
  }

  export type BodegaGroupByOutputType = {
    id: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    _count: BodegaCountAggregateOutputType | null
    _avg: BodegaAvgAggregateOutputType | null
    _sum: BodegaSumAggregateOutputType | null
    _min: BodegaMinAggregateOutputType | null
    _max: BodegaMaxAggregateOutputType | null
  }

  type GetBodegaGroupByPayload<T extends BodegaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BodegaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BodegaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BodegaGroupByOutputType[P]>
            : GetScalarType<T[P], BodegaGroupByOutputType[P]>
        }
      >
    >


  export type BodegaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    idUbicacion?: boolean
    tamanno?: boolean
    capacidad?: boolean
    seguridad?: boolean
    usuario?: boolean | Bodega$usuarioArgs<ExtArgs>
    inventario?: boolean | Bodega$inventarioArgs<ExtArgs>
    detalleCompra?: boolean | Bodega$detalleCompraArgs<ExtArgs>
    Historial?: boolean | Bodega$HistorialArgs<ExtArgs>
    TrasladoOrigen?: boolean | Bodega$TrasladoOrigenArgs<ExtArgs>
    TrasladoDestino?: boolean | Bodega$TrasladoDestinoArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    _count?: boolean | BodegaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bodega"]>

  export type BodegaSelectScalar = {
    id?: boolean
    nombre?: boolean
    idUbicacion?: boolean
    tamanno?: boolean
    capacidad?: boolean
    seguridad?: boolean
  }

  export type BodegaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | Bodega$usuarioArgs<ExtArgs>
    inventario?: boolean | Bodega$inventarioArgs<ExtArgs>
    detalleCompra?: boolean | Bodega$detalleCompraArgs<ExtArgs>
    Historial?: boolean | Bodega$HistorialArgs<ExtArgs>
    TrasladoOrigen?: boolean | Bodega$TrasladoOrigenArgs<ExtArgs>
    TrasladoDestino?: boolean | Bodega$TrasladoDestinoArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    _count?: boolean | BodegaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BodegaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bodega"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>[]
      inventario: Prisma.$InventarioPayload<ExtArgs>[]
      detalleCompra: Prisma.$DetalleCompraPayload<ExtArgs>[]
      Historial: Prisma.$HistorialPayload<ExtArgs>[]
      TrasladoOrigen: Prisma.$TrasladoPayload<ExtArgs>[]
      TrasladoDestino: Prisma.$TrasladoPayload<ExtArgs>[]
      ubicacion: Prisma.$UbicacionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      idUbicacion: number
      tamanno: number
      capacidad: number
      seguridad: boolean
    }, ExtArgs["result"]["bodega"]>
    composites: {}
  }


  type BodegaGetPayload<S extends boolean | null | undefined | BodegaDefaultArgs> = $Result.GetResult<Prisma.$BodegaPayload, S>

  type BodegaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BodegaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BodegaCountAggregateInputType | true
    }

  export interface BodegaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bodega'], meta: { name: 'Bodega' } }
    /**
     * Find zero or one Bodega that matches the filter.
     * @param {BodegaFindUniqueArgs} args - Arguments to find a Bodega
     * @example
     * // Get one Bodega
     * const bodega = await prisma.bodega.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BodegaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaFindUniqueArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bodega that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BodegaFindUniqueOrThrowArgs} args - Arguments to find a Bodega
     * @example
     * // Get one Bodega
     * const bodega = await prisma.bodega.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BodegaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bodega that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaFindFirstArgs} args - Arguments to find a Bodega
     * @example
     * // Get one Bodega
     * const bodega = await prisma.bodega.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BodegaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaFindFirstArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bodega that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaFindFirstOrThrowArgs} args - Arguments to find a Bodega
     * @example
     * // Get one Bodega
     * const bodega = await prisma.bodega.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BodegaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bodegas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bodegas
     * const bodegas = await prisma.bodega.findMany()
     * 
     * // Get first 10 Bodegas
     * const bodegas = await prisma.bodega.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bodegaWithIdOnly = await prisma.bodega.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BodegaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bodega.
     * @param {BodegaCreateArgs} args - Arguments to create a Bodega.
     * @example
     * // Create one Bodega
     * const Bodega = await prisma.bodega.create({
     *   data: {
     *     // ... data to create a Bodega
     *   }
     * })
     * 
    **/
    create<T extends BodegaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaCreateArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bodegas.
     *     @param {BodegaCreateManyArgs} args - Arguments to create many Bodegas.
     *     @example
     *     // Create many Bodegas
     *     const bodega = await prisma.bodega.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BodegaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bodega.
     * @param {BodegaDeleteArgs} args - Arguments to delete one Bodega.
     * @example
     * // Delete one Bodega
     * const Bodega = await prisma.bodega.delete({
     *   where: {
     *     // ... filter to delete one Bodega
     *   }
     * })
     * 
    **/
    delete<T extends BodegaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaDeleteArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bodega.
     * @param {BodegaUpdateArgs} args - Arguments to update one Bodega.
     * @example
     * // Update one Bodega
     * const bodega = await prisma.bodega.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BodegaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaUpdateArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bodegas.
     * @param {BodegaDeleteManyArgs} args - Arguments to filter Bodegas to delete.
     * @example
     * // Delete a few Bodegas
     * const { count } = await prisma.bodega.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BodegaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodegaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bodegas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bodegas
     * const bodega = await prisma.bodega.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BodegaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bodega.
     * @param {BodegaUpsertArgs} args - Arguments to update or create a Bodega.
     * @example
     * // Update or create a Bodega
     * const bodega = await prisma.bodega.upsert({
     *   create: {
     *     // ... data to create a Bodega
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bodega we want to update
     *   }
     * })
    **/
    upsert<T extends BodegaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BodegaUpsertArgs<ExtArgs>>
    ): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bodegas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaCountArgs} args - Arguments to filter Bodegas to count.
     * @example
     * // Count the number of Bodegas
     * const count = await prisma.bodega.count({
     *   where: {
     *     // ... the filter for the Bodegas we want to count
     *   }
     * })
    **/
    count<T extends BodegaCountArgs>(
      args?: Subset<T, BodegaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BodegaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bodega.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BodegaAggregateArgs>(args: Subset<T, BodegaAggregateArgs>): Prisma.PrismaPromise<GetBodegaAggregateType<T>>

    /**
     * Group by Bodega.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodegaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BodegaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BodegaGroupByArgs['orderBy'] }
        : { orderBy?: BodegaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BodegaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBodegaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bodega model
   */
  readonly fields: BodegaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bodega.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BodegaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuario<T extends Bodega$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    inventario<T extends Bodega$inventarioArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$inventarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    detalleCompra<T extends Bodega$detalleCompraArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$detalleCompraArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    Historial<T extends Bodega$HistorialArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$HistorialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findMany'> | Null>;

    TrasladoOrigen<T extends Bodega$TrasladoOrigenArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$TrasladoOrigenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findMany'> | Null>;

    TrasladoDestino<T extends Bodega$TrasladoDestinoArgs<ExtArgs> = {}>(args?: Subset<T, Bodega$TrasladoDestinoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findMany'> | Null>;

    ubicacion<T extends UbicacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UbicacionDefaultArgs<ExtArgs>>): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Bodega model
   */ 
  interface BodegaFieldRefs {
    readonly id: FieldRef<"Bodega", 'Int'>
    readonly nombre: FieldRef<"Bodega", 'String'>
    readonly idUbicacion: FieldRef<"Bodega", 'Int'>
    readonly tamanno: FieldRef<"Bodega", 'Float'>
    readonly capacidad: FieldRef<"Bodega", 'Float'>
    readonly seguridad: FieldRef<"Bodega", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Bodega findUnique
   */
  export type BodegaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodega to fetch.
     */
    where: BodegaWhereUniqueInput
  }


  /**
   * Bodega findUniqueOrThrow
   */
  export type BodegaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodega to fetch.
     */
    where: BodegaWhereUniqueInput
  }


  /**
   * Bodega findFirst
   */
  export type BodegaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodega to fetch.
     */
    where?: BodegaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bodegas to fetch.
     */
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bodegas.
     */
    cursor?: BodegaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bodegas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bodegas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bodegas.
     */
    distinct?: BodegaScalarFieldEnum | BodegaScalarFieldEnum[]
  }


  /**
   * Bodega findFirstOrThrow
   */
  export type BodegaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodega to fetch.
     */
    where?: BodegaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bodegas to fetch.
     */
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bodegas.
     */
    cursor?: BodegaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bodegas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bodegas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bodegas.
     */
    distinct?: BodegaScalarFieldEnum | BodegaScalarFieldEnum[]
  }


  /**
   * Bodega findMany
   */
  export type BodegaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter, which Bodegas to fetch.
     */
    where?: BodegaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bodegas to fetch.
     */
    orderBy?: BodegaOrderByWithRelationInput | BodegaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bodegas.
     */
    cursor?: BodegaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bodegas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bodegas.
     */
    skip?: number
    distinct?: BodegaScalarFieldEnum | BodegaScalarFieldEnum[]
  }


  /**
   * Bodega create
   */
  export type BodegaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * The data needed to create a Bodega.
     */
    data: XOR<BodegaCreateInput, BodegaUncheckedCreateInput>
  }


  /**
   * Bodega createMany
   */
  export type BodegaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bodegas.
     */
    data: BodegaCreateManyInput | BodegaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Bodega update
   */
  export type BodegaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * The data needed to update a Bodega.
     */
    data: XOR<BodegaUpdateInput, BodegaUncheckedUpdateInput>
    /**
     * Choose, which Bodega to update.
     */
    where: BodegaWhereUniqueInput
  }


  /**
   * Bodega updateMany
   */
  export type BodegaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bodegas.
     */
    data: XOR<BodegaUpdateManyMutationInput, BodegaUncheckedUpdateManyInput>
    /**
     * Filter which Bodegas to update
     */
    where?: BodegaWhereInput
  }


  /**
   * Bodega upsert
   */
  export type BodegaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * The filter to search for the Bodega to update in case it exists.
     */
    where: BodegaWhereUniqueInput
    /**
     * In case the Bodega found by the `where` argument doesn't exist, create a new Bodega with this data.
     */
    create: XOR<BodegaCreateInput, BodegaUncheckedCreateInput>
    /**
     * In case the Bodega was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BodegaUpdateInput, BodegaUncheckedUpdateInput>
  }


  /**
   * Bodega delete
   */
  export type BodegaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
    /**
     * Filter which Bodega to delete.
     */
    where: BodegaWhereUniqueInput
  }


  /**
   * Bodega deleteMany
   */
  export type BodegaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bodegas to delete
     */
    where?: BodegaWhereInput
  }


  /**
   * Bodega.usuario
   */
  export type Bodega$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Bodega.inventario
   */
  export type Bodega$inventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * Bodega.detalleCompra
   */
  export type Bodega$detalleCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    where?: DetalleCompraWhereInput
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    cursor?: DetalleCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * Bodega.Historial
   */
  export type Bodega$HistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    where?: HistorialWhereInput
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    cursor?: HistorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Bodega.TrasladoOrigen
   */
  export type Bodega$TrasladoOrigenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    where?: TrasladoWhereInput
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    cursor?: TrasladoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoScalarFieldEnum | TrasladoScalarFieldEnum[]
  }


  /**
   * Bodega.TrasladoDestino
   */
  export type Bodega$TrasladoDestinoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    where?: TrasladoWhereInput
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    cursor?: TrasladoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrasladoScalarFieldEnum | TrasladoScalarFieldEnum[]
  }


  /**
   * Bodega without action
   */
  export type BodegaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bodega
     */
    select?: BodegaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BodegaInclude<ExtArgs> | null
  }



  /**
   * Model Inventario
   */

  export type AggregateInventario = {
    _count: InventarioCountAggregateOutputType | null
    _avg: InventarioAvgAggregateOutputType | null
    _sum: InventarioSumAggregateOutputType | null
    _min: InventarioMinAggregateOutputType | null
    _max: InventarioMaxAggregateOutputType | null
  }

  export type InventarioAvgAggregateOutputType = {
    idBodega: number | null
    idProducto: number | null
    idUsuarioRegistro: number | null
    idUsuarioActualizo: number | null
    cantidad: number | null
    cantidadMinima: number | null
    cantidadMaxima: number | null
  }

  export type InventarioSumAggregateOutputType = {
    idBodega: number | null
    idProducto: number | null
    idUsuarioRegistro: number | null
    idUsuarioActualizo: number | null
    cantidad: number | null
    cantidadMinima: number | null
    cantidadMaxima: number | null
  }

  export type InventarioMinAggregateOutputType = {
    idBodega: number | null
    idProducto: number | null
    idUsuarioRegistro: number | null
    idUsuarioActualizo: number | null
    cantidad: number | null
    cantidadMinima: number | null
    cantidadMaxima: number | null
    fechaRegistro: Date | null
  }

  export type InventarioMaxAggregateOutputType = {
    idBodega: number | null
    idProducto: number | null
    idUsuarioRegistro: number | null
    idUsuarioActualizo: number | null
    cantidad: number | null
    cantidadMinima: number | null
    cantidadMaxima: number | null
    fechaRegistro: Date | null
  }

  export type InventarioCountAggregateOutputType = {
    idBodega: number
    idProducto: number
    idUsuarioRegistro: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro: number
    _all: number
  }


  export type InventarioAvgAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuarioRegistro?: true
    idUsuarioActualizo?: true
    cantidad?: true
    cantidadMinima?: true
    cantidadMaxima?: true
  }

  export type InventarioSumAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuarioRegistro?: true
    idUsuarioActualizo?: true
    cantidad?: true
    cantidadMinima?: true
    cantidadMaxima?: true
  }

  export type InventarioMinAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuarioRegistro?: true
    idUsuarioActualizo?: true
    cantidad?: true
    cantidadMinima?: true
    cantidadMaxima?: true
    fechaRegistro?: true
  }

  export type InventarioMaxAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuarioRegistro?: true
    idUsuarioActualizo?: true
    cantidad?: true
    cantidadMinima?: true
    cantidadMaxima?: true
    fechaRegistro?: true
  }

  export type InventarioCountAggregateInputType = {
    idBodega?: true
    idProducto?: true
    idUsuarioRegistro?: true
    idUsuarioActualizo?: true
    cantidad?: true
    cantidadMinima?: true
    cantidadMaxima?: true
    fechaRegistro?: true
    _all?: true
  }

  export type InventarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventario to aggregate.
     */
    where?: InventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarios to fetch.
     */
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventarios
    **/
    _count?: true | InventarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventarioMaxAggregateInputType
  }

  export type GetInventarioAggregateType<T extends InventarioAggregateArgs> = {
        [P in keyof T & keyof AggregateInventario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventario[P]>
      : GetScalarType<T[P], AggregateInventario[P]>
  }




  export type InventarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithAggregationInput | InventarioOrderByWithAggregationInput[]
    by: InventarioScalarFieldEnum[] | InventarioScalarFieldEnum
    having?: InventarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventarioCountAggregateInputType | true
    _avg?: InventarioAvgAggregateInputType
    _sum?: InventarioSumAggregateInputType
    _min?: InventarioMinAggregateInputType
    _max?: InventarioMaxAggregateInputType
  }

  export type InventarioGroupByOutputType = {
    idBodega: number
    idProducto: number
    idUsuarioRegistro: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro: Date
    _count: InventarioCountAggregateOutputType | null
    _avg: InventarioAvgAggregateOutputType | null
    _sum: InventarioSumAggregateOutputType | null
    _min: InventarioMinAggregateOutputType | null
    _max: InventarioMaxAggregateOutputType | null
  }

  type GetInventarioGroupByPayload<T extends InventarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventarioGroupByOutputType[P]>
            : GetScalarType<T[P], InventarioGroupByOutputType[P]>
        }
      >
    >


  export type InventarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBodega?: boolean
    idProducto?: boolean
    idUsuarioRegistro?: boolean
    idUsuarioActualizo?: boolean
    cantidad?: boolean
    cantidadMinima?: boolean
    cantidadMaxima?: boolean
    fechaRegistro?: boolean
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    usuarioRegistro?: boolean | UsuarioDefaultArgs<ExtArgs>
    usuarioActualizo?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventario"]>

  export type InventarioSelectScalar = {
    idBodega?: boolean
    idProducto?: boolean
    idUsuarioRegistro?: boolean
    idUsuarioActualizo?: boolean
    cantidad?: boolean
    cantidadMinima?: boolean
    cantidadMaxima?: boolean
    fechaRegistro?: boolean
  }

  export type InventarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodegas?: boolean | BodegaDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    usuarioRegistro?: boolean | UsuarioDefaultArgs<ExtArgs>
    usuarioActualizo?: boolean | UsuarioDefaultArgs<ExtArgs>
  }


  export type $InventarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventario"
    objects: {
      bodegas: Prisma.$BodegaPayload<ExtArgs>
      producto: Prisma.$ProductoPayload<ExtArgs>
      usuarioRegistro: Prisma.$UsuarioPayload<ExtArgs>
      usuarioActualizo: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBodega: number
      idProducto: number
      idUsuarioRegistro: number
      idUsuarioActualizo: number
      cantidad: number
      cantidadMinima: number
      cantidadMaxima: number
      fechaRegistro: Date
    }, ExtArgs["result"]["inventario"]>
    composites: {}
  }


  type InventarioGetPayload<S extends boolean | null | undefined | InventarioDefaultArgs> = $Result.GetResult<Prisma.$InventarioPayload, S>

  type InventarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventarioCountAggregateInputType | true
    }

  export interface InventarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventario'], meta: { name: 'Inventario' } }
    /**
     * Find zero or one Inventario that matches the filter.
     * @param {InventarioFindUniqueArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventarioFindUniqueArgs<ExtArgs>>
    ): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inventario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventarioFindUniqueOrThrowArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inventario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioFindFirstArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventarioFindFirstArgs<ExtArgs>>
    ): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inventario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioFindFirstOrThrowArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inventarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventarios
     * const inventarios = await prisma.inventario.findMany()
     * 
     * // Get first 10 Inventarios
     * const inventarios = await prisma.inventario.findMany({ take: 10 })
     * 
     * // Only select the `idBodega`
     * const inventarioWithIdBodegaOnly = await prisma.inventario.findMany({ select: { idBodega: true } })
     * 
    **/
    findMany<T extends InventarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inventario.
     * @param {InventarioCreateArgs} args - Arguments to create a Inventario.
     * @example
     * // Create one Inventario
     * const Inventario = await prisma.inventario.create({
     *   data: {
     *     // ... data to create a Inventario
     *   }
     * })
     * 
    **/
    create<T extends InventarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventarioCreateArgs<ExtArgs>>
    ): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inventarios.
     *     @param {InventarioCreateManyArgs} args - Arguments to create many Inventarios.
     *     @example
     *     // Create many Inventarios
     *     const inventario = await prisma.inventario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventario.
     * @param {InventarioDeleteArgs} args - Arguments to delete one Inventario.
     * @example
     * // Delete one Inventario
     * const Inventario = await prisma.inventario.delete({
     *   where: {
     *     // ... filter to delete one Inventario
     *   }
     * })
     * 
    **/
    delete<T extends InventarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventarioDeleteArgs<ExtArgs>>
    ): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inventario.
     * @param {InventarioUpdateArgs} args - Arguments to update one Inventario.
     * @example
     * // Update one Inventario
     * const inventario = await prisma.inventario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventarioUpdateArgs<ExtArgs>>
    ): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inventarios.
     * @param {InventarioDeleteManyArgs} args - Arguments to filter Inventarios to delete.
     * @example
     * // Delete a few Inventarios
     * const { count } = await prisma.inventario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventarios
     * const inventario = await prisma.inventario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventario.
     * @param {InventarioUpsertArgs} args - Arguments to update or create a Inventario.
     * @example
     * // Update or create a Inventario
     * const inventario = await prisma.inventario.upsert({
     *   create: {
     *     // ... data to create a Inventario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventario we want to update
     *   }
     * })
    **/
    upsert<T extends InventarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventarioUpsertArgs<ExtArgs>>
    ): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inventarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioCountArgs} args - Arguments to filter Inventarios to count.
     * @example
     * // Count the number of Inventarios
     * const count = await prisma.inventario.count({
     *   where: {
     *     // ... the filter for the Inventarios we want to count
     *   }
     * })
    **/
    count<T extends InventarioCountArgs>(
      args?: Subset<T, InventarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventarioAggregateArgs>(args: Subset<T, InventarioAggregateArgs>): Prisma.PrismaPromise<GetInventarioAggregateType<T>>

    /**
     * Group by Inventario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventarioGroupByArgs['orderBy'] }
        : { orderBy?: InventarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventario model
   */
  readonly fields: InventarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bodegas<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuarioRegistro<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuarioActualizo<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Inventario model
   */ 
  interface InventarioFieldRefs {
    readonly idBodega: FieldRef<"Inventario", 'Int'>
    readonly idProducto: FieldRef<"Inventario", 'Int'>
    readonly idUsuarioRegistro: FieldRef<"Inventario", 'Int'>
    readonly idUsuarioActualizo: FieldRef<"Inventario", 'Int'>
    readonly cantidad: FieldRef<"Inventario", 'Int'>
    readonly cantidadMinima: FieldRef<"Inventario", 'Int'>
    readonly cantidadMaxima: FieldRef<"Inventario", 'Int'>
    readonly fechaRegistro: FieldRef<"Inventario", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Inventario findUnique
   */
  export type InventarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventario to fetch.
     */
    where: InventarioWhereUniqueInput
  }


  /**
   * Inventario findUniqueOrThrow
   */
  export type InventarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventario to fetch.
     */
    where: InventarioWhereUniqueInput
  }


  /**
   * Inventario findFirst
   */
  export type InventarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventario to fetch.
     */
    where?: InventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarios to fetch.
     */
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventarios.
     */
    cursor?: InventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventarios.
     */
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * Inventario findFirstOrThrow
   */
  export type InventarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventario to fetch.
     */
    where?: InventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarios to fetch.
     */
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventarios.
     */
    cursor?: InventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventarios.
     */
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * Inventario findMany
   */
  export type InventarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventarios to fetch.
     */
    where?: InventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarios to fetch.
     */
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventarios.
     */
    cursor?: InventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarios.
     */
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }


  /**
   * Inventario create
   */
  export type InventarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventario.
     */
    data: XOR<InventarioCreateInput, InventarioUncheckedCreateInput>
  }


  /**
   * Inventario createMany
   */
  export type InventarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventarios.
     */
    data: InventarioCreateManyInput | InventarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Inventario update
   */
  export type InventarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventario.
     */
    data: XOR<InventarioUpdateInput, InventarioUncheckedUpdateInput>
    /**
     * Choose, which Inventario to update.
     */
    where: InventarioWhereUniqueInput
  }


  /**
   * Inventario updateMany
   */
  export type InventarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventarios.
     */
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyInput>
    /**
     * Filter which Inventarios to update
     */
    where?: InventarioWhereInput
  }


  /**
   * Inventario upsert
   */
  export type InventarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventario to update in case it exists.
     */
    where: InventarioWhereUniqueInput
    /**
     * In case the Inventario found by the `where` argument doesn't exist, create a new Inventario with this data.
     */
    create: XOR<InventarioCreateInput, InventarioUncheckedCreateInput>
    /**
     * In case the Inventario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventarioUpdateInput, InventarioUncheckedUpdateInput>
  }


  /**
   * Inventario delete
   */
  export type InventarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter which Inventario to delete.
     */
    where: InventarioWhereUniqueInput
  }


  /**
   * Inventario deleteMany
   */
  export type InventarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventarios to delete
     */
    where?: InventarioWhereInput
  }


  /**
   * Inventario without action
   */
  export type InventarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventarioInclude<ExtArgs> | null
  }



  /**
   * Model Proveedor
   */

  export type AggregateProveedor = {
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  export type ProveedorAvgAggregateOutputType = {
    id: number | null
    identificacion: number | null
    idUbicacion: number | null
    telefono: number | null
  }

  export type ProveedorSumAggregateOutputType = {
    id: number | null
    identificacion: number | null
    idUbicacion: number | null
    telefono: number | null
  }

  export type ProveedorMinAggregateOutputType = {
    id: number | null
    identificacion: number | null
    nombreProveedor: string | null
    idUbicacion: number | null
    correoElectronico: string | null
    telefono: number | null
  }

  export type ProveedorMaxAggregateOutputType = {
    id: number | null
    identificacion: number | null
    nombreProveedor: string | null
    idUbicacion: number | null
    correoElectronico: string | null
    telefono: number | null
  }

  export type ProveedorCountAggregateOutputType = {
    id: number
    identificacion: number
    nombreProveedor: number
    idUbicacion: number
    correoElectronico: number
    telefono: number
    _all: number
  }


  export type ProveedorAvgAggregateInputType = {
    id?: true
    identificacion?: true
    idUbicacion?: true
    telefono?: true
  }

  export type ProveedorSumAggregateInputType = {
    id?: true
    identificacion?: true
    idUbicacion?: true
    telefono?: true
  }

  export type ProveedorMinAggregateInputType = {
    id?: true
    identificacion?: true
    nombreProveedor?: true
    idUbicacion?: true
    correoElectronico?: true
    telefono?: true
  }

  export type ProveedorMaxAggregateInputType = {
    id?: true
    identificacion?: true
    nombreProveedor?: true
    idUbicacion?: true
    correoElectronico?: true
    telefono?: true
  }

  export type ProveedorCountAggregateInputType = {
    id?: true
    identificacion?: true
    nombreProveedor?: true
    idUbicacion?: true
    correoElectronico?: true
    telefono?: true
    _all?: true
  }

  export type ProveedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proveedor to aggregate.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proveedors
    **/
    _count?: true | ProveedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedorMaxAggregateInputType
  }

  export type GetProveedorAggregateType<T extends ProveedorAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedor[P]>
      : GetScalarType<T[P], AggregateProveedor[P]>
  }




  export type ProveedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProveedorWhereInput
    orderBy?: ProveedorOrderByWithAggregationInput | ProveedorOrderByWithAggregationInput[]
    by: ProveedorScalarFieldEnum[] | ProveedorScalarFieldEnum
    having?: ProveedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedorCountAggregateInputType | true
    _avg?: ProveedorAvgAggregateInputType
    _sum?: ProveedorSumAggregateInputType
    _min?: ProveedorMinAggregateInputType
    _max?: ProveedorMaxAggregateInputType
  }

  export type ProveedorGroupByOutputType = {
    id: number
    identificacion: number
    nombreProveedor: string
    idUbicacion: number
    correoElectronico: string
    telefono: number
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  type GetProveedorGroupByPayload<T extends ProveedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
        }
      >
    >


  export type ProveedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identificacion?: boolean
    nombreProveedor?: boolean
    idUbicacion?: boolean
    correoElectronico?: boolean
    telefono?: boolean
    encabezadoCompra?: boolean | Proveedor$encabezadoCompraArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proveedor"]>

  export type ProveedorSelectScalar = {
    id?: boolean
    identificacion?: boolean
    nombreProveedor?: boolean
    idUbicacion?: boolean
    correoElectronico?: boolean
    telefono?: boolean
  }

  export type ProveedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encabezadoCompra?: boolean | Proveedor$encabezadoCompraArgs<ExtArgs>
    ubicacion?: boolean | UbicacionDefaultArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProveedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proveedor"
    objects: {
      encabezadoCompra: Prisma.$EncabezadoCompraPayload<ExtArgs>[]
      ubicacion: Prisma.$UbicacionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      identificacion: number
      nombreProveedor: string
      idUbicacion: number
      correoElectronico: string
      telefono: number
    }, ExtArgs["result"]["proveedor"]>
    composites: {}
  }


  type ProveedorGetPayload<S extends boolean | null | undefined | ProveedorDefaultArgs> = $Result.GetResult<Prisma.$ProveedorPayload, S>

  type ProveedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProveedorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProveedorCountAggregateInputType | true
    }

  export interface ProveedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proveedor'], meta: { name: 'Proveedor' } }
    /**
     * Find zero or one Proveedor that matches the filter.
     * @param {ProveedorFindUniqueArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProveedorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProveedorFindUniqueArgs<ExtArgs>>
    ): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Proveedor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProveedorFindUniqueOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProveedorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProveedorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Proveedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindFirstArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProveedorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProveedorFindFirstArgs<ExtArgs>>
    ): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Proveedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindFirstOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProveedorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProveedorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Proveedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedors
     * const proveedors = await prisma.proveedor.findMany()
     * 
     * // Get first 10 Proveedors
     * const proveedors = await prisma.proveedor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proveedorWithIdOnly = await prisma.proveedor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProveedorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProveedorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Proveedor.
     * @param {ProveedorCreateArgs} args - Arguments to create a Proveedor.
     * @example
     * // Create one Proveedor
     * const Proveedor = await prisma.proveedor.create({
     *   data: {
     *     // ... data to create a Proveedor
     *   }
     * })
     * 
    **/
    create<T extends ProveedorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProveedorCreateArgs<ExtArgs>>
    ): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Proveedors.
     *     @param {ProveedorCreateManyArgs} args - Arguments to create many Proveedors.
     *     @example
     *     // Create many Proveedors
     *     const proveedor = await prisma.proveedor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProveedorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProveedorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedor.
     * @param {ProveedorDeleteArgs} args - Arguments to delete one Proveedor.
     * @example
     * // Delete one Proveedor
     * const Proveedor = await prisma.proveedor.delete({
     *   where: {
     *     // ... filter to delete one Proveedor
     *   }
     * })
     * 
    **/
    delete<T extends ProveedorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProveedorDeleteArgs<ExtArgs>>
    ): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Proveedor.
     * @param {ProveedorUpdateArgs} args - Arguments to update one Proveedor.
     * @example
     * // Update one Proveedor
     * const proveedor = await prisma.proveedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProveedorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProveedorUpdateArgs<ExtArgs>>
    ): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Proveedors.
     * @param {ProveedorDeleteManyArgs} args - Arguments to filter Proveedors to delete.
     * @example
     * // Delete a few Proveedors
     * const { count } = await prisma.proveedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProveedorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProveedorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedors
     * const proveedor = await prisma.proveedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProveedorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProveedorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedor.
     * @param {ProveedorUpsertArgs} args - Arguments to update or create a Proveedor.
     * @example
     * // Update or create a Proveedor
     * const proveedor = await prisma.proveedor.upsert({
     *   create: {
     *     // ... data to create a Proveedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedor we want to update
     *   }
     * })
    **/
    upsert<T extends ProveedorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProveedorUpsertArgs<ExtArgs>>
    ): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorCountArgs} args - Arguments to filter Proveedors to count.
     * @example
     * // Count the number of Proveedors
     * const count = await prisma.proveedor.count({
     *   where: {
     *     // ... the filter for the Proveedors we want to count
     *   }
     * })
    **/
    count<T extends ProveedorCountArgs>(
      args?: Subset<T, ProveedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedorAggregateArgs>(args: Subset<T, ProveedorAggregateArgs>): Prisma.PrismaPromise<GetProveedorAggregateType<T>>

    /**
     * Group by Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProveedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProveedorGroupByArgs['orderBy'] }
        : { orderBy?: ProveedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProveedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proveedor model
   */
  readonly fields: ProveedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proveedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProveedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    encabezadoCompra<T extends Proveedor$encabezadoCompraArgs<ExtArgs> = {}>(args?: Subset<T, Proveedor$encabezadoCompraArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    ubicacion<T extends UbicacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UbicacionDefaultArgs<ExtArgs>>): Prisma__UbicacionClient<$Result.GetResult<Prisma.$UbicacionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Proveedor model
   */ 
  interface ProveedorFieldRefs {
    readonly id: FieldRef<"Proveedor", 'Int'>
    readonly identificacion: FieldRef<"Proveedor", 'Int'>
    readonly nombreProveedor: FieldRef<"Proveedor", 'String'>
    readonly idUbicacion: FieldRef<"Proveedor", 'Int'>
    readonly correoElectronico: FieldRef<"Proveedor", 'String'>
    readonly telefono: FieldRef<"Proveedor", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Proveedor findUnique
   */
  export type ProveedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where: ProveedorWhereUniqueInput
  }


  /**
   * Proveedor findUniqueOrThrow
   */
  export type ProveedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where: ProveedorWhereUniqueInput
  }


  /**
   * Proveedor findFirst
   */
  export type ProveedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * Proveedor findFirstOrThrow
   */
  export type ProveedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * Proveedor findMany
   */
  export type ProveedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedors to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * Proveedor create
   */
  export type ProveedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * The data needed to create a Proveedor.
     */
    data: XOR<ProveedorCreateInput, ProveedorUncheckedCreateInput>
  }


  /**
   * Proveedor createMany
   */
  export type ProveedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proveedors.
     */
    data: ProveedorCreateManyInput | ProveedorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Proveedor update
   */
  export type ProveedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * The data needed to update a Proveedor.
     */
    data: XOR<ProveedorUpdateInput, ProveedorUncheckedUpdateInput>
    /**
     * Choose, which Proveedor to update.
     */
    where: ProveedorWhereUniqueInput
  }


  /**
   * Proveedor updateMany
   */
  export type ProveedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proveedors.
     */
    data: XOR<ProveedorUpdateManyMutationInput, ProveedorUncheckedUpdateManyInput>
    /**
     * Filter which Proveedors to update
     */
    where?: ProveedorWhereInput
  }


  /**
   * Proveedor upsert
   */
  export type ProveedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * The filter to search for the Proveedor to update in case it exists.
     */
    where: ProveedorWhereUniqueInput
    /**
     * In case the Proveedor found by the `where` argument doesn't exist, create a new Proveedor with this data.
     */
    create: XOR<ProveedorCreateInput, ProveedorUncheckedCreateInput>
    /**
     * In case the Proveedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProveedorUpdateInput, ProveedorUncheckedUpdateInput>
  }


  /**
   * Proveedor delete
   */
  export type ProveedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter which Proveedor to delete.
     */
    where: ProveedorWhereUniqueInput
  }


  /**
   * Proveedor deleteMany
   */
  export type ProveedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proveedors to delete
     */
    where?: ProveedorWhereInput
  }


  /**
   * Proveedor.encabezadoCompra
   */
  export type Proveedor$encabezadoCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    where?: EncabezadoCompraWhereInput
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    cursor?: EncabezadoCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * Proveedor without action
   */
  export type ProveedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProveedorInclude<ExtArgs> | null
  }



  /**
   * Model EncabezadoCompra
   */

  export type AggregateEncabezadoCompra = {
    _count: EncabezadoCompraCountAggregateOutputType | null
    _avg: EncabezadoCompraAvgAggregateOutputType | null
    _sum: EncabezadoCompraSumAggregateOutputType | null
    _min: EncabezadoCompraMinAggregateOutputType | null
    _max: EncabezadoCompraMaxAggregateOutputType | null
  }

  export type EncabezadoCompraAvgAggregateOutputType = {
    id: number | null
    idProveedor: number | null
    idUsuario: number | null
  }

  export type EncabezadoCompraSumAggregateOutputType = {
    id: number | null
    idProveedor: number | null
    idUsuario: number | null
  }

  export type EncabezadoCompraMinAggregateOutputType = {
    id: number | null
    fechaCompra: Date | null
    idProveedor: number | null
    idUsuario: number | null
  }

  export type EncabezadoCompraMaxAggregateOutputType = {
    id: number | null
    fechaCompra: Date | null
    idProveedor: number | null
    idUsuario: number | null
  }

  export type EncabezadoCompraCountAggregateOutputType = {
    id: number
    fechaCompra: number
    idProveedor: number
    idUsuario: number
    _all: number
  }


  export type EncabezadoCompraAvgAggregateInputType = {
    id?: true
    idProveedor?: true
    idUsuario?: true
  }

  export type EncabezadoCompraSumAggregateInputType = {
    id?: true
    idProveedor?: true
    idUsuario?: true
  }

  export type EncabezadoCompraMinAggregateInputType = {
    id?: true
    fechaCompra?: true
    idProveedor?: true
    idUsuario?: true
  }

  export type EncabezadoCompraMaxAggregateInputType = {
    id?: true
    fechaCompra?: true
    idProveedor?: true
    idUsuario?: true
  }

  export type EncabezadoCompraCountAggregateInputType = {
    id?: true
    fechaCompra?: true
    idProveedor?: true
    idUsuario?: true
    _all?: true
  }

  export type EncabezadoCompraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncabezadoCompra to aggregate.
     */
    where?: EncabezadoCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoCompras to fetch.
     */
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncabezadoCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncabezadoCompras
    **/
    _count?: true | EncabezadoCompraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncabezadoCompraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncabezadoCompraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncabezadoCompraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncabezadoCompraMaxAggregateInputType
  }

  export type GetEncabezadoCompraAggregateType<T extends EncabezadoCompraAggregateArgs> = {
        [P in keyof T & keyof AggregateEncabezadoCompra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncabezadoCompra[P]>
      : GetScalarType<T[P], AggregateEncabezadoCompra[P]>
  }




  export type EncabezadoCompraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoCompraWhereInput
    orderBy?: EncabezadoCompraOrderByWithAggregationInput | EncabezadoCompraOrderByWithAggregationInput[]
    by: EncabezadoCompraScalarFieldEnum[] | EncabezadoCompraScalarFieldEnum
    having?: EncabezadoCompraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncabezadoCompraCountAggregateInputType | true
    _avg?: EncabezadoCompraAvgAggregateInputType
    _sum?: EncabezadoCompraSumAggregateInputType
    _min?: EncabezadoCompraMinAggregateInputType
    _max?: EncabezadoCompraMaxAggregateInputType
  }

  export type EncabezadoCompraGroupByOutputType = {
    id: number
    fechaCompra: Date
    idProveedor: number
    idUsuario: number
    _count: EncabezadoCompraCountAggregateOutputType | null
    _avg: EncabezadoCompraAvgAggregateOutputType | null
    _sum: EncabezadoCompraSumAggregateOutputType | null
    _min: EncabezadoCompraMinAggregateOutputType | null
    _max: EncabezadoCompraMaxAggregateOutputType | null
  }

  type GetEncabezadoCompraGroupByPayload<T extends EncabezadoCompraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncabezadoCompraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncabezadoCompraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncabezadoCompraGroupByOutputType[P]>
            : GetScalarType<T[P], EncabezadoCompraGroupByOutputType[P]>
        }
      >
    >


  export type EncabezadoCompraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fechaCompra?: boolean
    idProveedor?: boolean
    idUsuario?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    proveedor?: boolean | ProveedorDefaultArgs<ExtArgs>
    detalleCompra?: boolean | EncabezadoCompra$detalleCompraArgs<ExtArgs>
    pedido?: boolean | EncabezadoCompra$pedidoArgs<ExtArgs>
    _count?: boolean | EncabezadoCompraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encabezadoCompra"]>

  export type EncabezadoCompraSelectScalar = {
    id?: boolean
    fechaCompra?: boolean
    idProveedor?: boolean
    idUsuario?: boolean
  }

  export type EncabezadoCompraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    proveedor?: boolean | ProveedorDefaultArgs<ExtArgs>
    detalleCompra?: boolean | EncabezadoCompra$detalleCompraArgs<ExtArgs>
    pedido?: boolean | EncabezadoCompra$pedidoArgs<ExtArgs>
    _count?: boolean | EncabezadoCompraCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EncabezadoCompraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncabezadoCompra"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      proveedor: Prisma.$ProveedorPayload<ExtArgs>
      detalleCompra: Prisma.$DetalleCompraPayload<ExtArgs>[]
      pedido: Prisma.$PedidoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fechaCompra: Date
      idProveedor: number
      idUsuario: number
    }, ExtArgs["result"]["encabezadoCompra"]>
    composites: {}
  }


  type EncabezadoCompraGetPayload<S extends boolean | null | undefined | EncabezadoCompraDefaultArgs> = $Result.GetResult<Prisma.$EncabezadoCompraPayload, S>

  type EncabezadoCompraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncabezadoCompraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncabezadoCompraCountAggregateInputType | true
    }

  export interface EncabezadoCompraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncabezadoCompra'], meta: { name: 'EncabezadoCompra' } }
    /**
     * Find zero or one EncabezadoCompra that matches the filter.
     * @param {EncabezadoCompraFindUniqueArgs} args - Arguments to find a EncabezadoCompra
     * @example
     * // Get one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EncabezadoCompraFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraFindUniqueArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EncabezadoCompra that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EncabezadoCompraFindUniqueOrThrowArgs} args - Arguments to find a EncabezadoCompra
     * @example
     * // Get one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EncabezadoCompraFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EncabezadoCompra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraFindFirstArgs} args - Arguments to find a EncabezadoCompra
     * @example
     * // Get one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EncabezadoCompraFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraFindFirstArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EncabezadoCompra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraFindFirstOrThrowArgs} args - Arguments to find a EncabezadoCompra
     * @example
     * // Get one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EncabezadoCompraFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EncabezadoCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncabezadoCompras
     * const encabezadoCompras = await prisma.encabezadoCompra.findMany()
     * 
     * // Get first 10 EncabezadoCompras
     * const encabezadoCompras = await prisma.encabezadoCompra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encabezadoCompraWithIdOnly = await prisma.encabezadoCompra.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EncabezadoCompraFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EncabezadoCompra.
     * @param {EncabezadoCompraCreateArgs} args - Arguments to create a EncabezadoCompra.
     * @example
     * // Create one EncabezadoCompra
     * const EncabezadoCompra = await prisma.encabezadoCompra.create({
     *   data: {
     *     // ... data to create a EncabezadoCompra
     *   }
     * })
     * 
    **/
    create<T extends EncabezadoCompraCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraCreateArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EncabezadoCompras.
     *     @param {EncabezadoCompraCreateManyArgs} args - Arguments to create many EncabezadoCompras.
     *     @example
     *     // Create many EncabezadoCompras
     *     const encabezadoCompra = await prisma.encabezadoCompra.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EncabezadoCompraCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EncabezadoCompra.
     * @param {EncabezadoCompraDeleteArgs} args - Arguments to delete one EncabezadoCompra.
     * @example
     * // Delete one EncabezadoCompra
     * const EncabezadoCompra = await prisma.encabezadoCompra.delete({
     *   where: {
     *     // ... filter to delete one EncabezadoCompra
     *   }
     * })
     * 
    **/
    delete<T extends EncabezadoCompraDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraDeleteArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EncabezadoCompra.
     * @param {EncabezadoCompraUpdateArgs} args - Arguments to update one EncabezadoCompra.
     * @example
     * // Update one EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EncabezadoCompraUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraUpdateArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EncabezadoCompras.
     * @param {EncabezadoCompraDeleteManyArgs} args - Arguments to filter EncabezadoCompras to delete.
     * @example
     * // Delete a few EncabezadoCompras
     * const { count } = await prisma.encabezadoCompra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EncabezadoCompraDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncabezadoCompraDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncabezadoCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncabezadoCompras
     * const encabezadoCompra = await prisma.encabezadoCompra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EncabezadoCompraUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncabezadoCompra.
     * @param {EncabezadoCompraUpsertArgs} args - Arguments to update or create a EncabezadoCompra.
     * @example
     * // Update or create a EncabezadoCompra
     * const encabezadoCompra = await prisma.encabezadoCompra.upsert({
     *   create: {
     *     // ... data to create a EncabezadoCompra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncabezadoCompra we want to update
     *   }
     * })
    **/
    upsert<T extends EncabezadoCompraUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EncabezadoCompraUpsertArgs<ExtArgs>>
    ): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EncabezadoCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraCountArgs} args - Arguments to filter EncabezadoCompras to count.
     * @example
     * // Count the number of EncabezadoCompras
     * const count = await prisma.encabezadoCompra.count({
     *   where: {
     *     // ... the filter for the EncabezadoCompras we want to count
     *   }
     * })
    **/
    count<T extends EncabezadoCompraCountArgs>(
      args?: Subset<T, EncabezadoCompraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncabezadoCompraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncabezadoCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncabezadoCompraAggregateArgs>(args: Subset<T, EncabezadoCompraAggregateArgs>): Prisma.PrismaPromise<GetEncabezadoCompraAggregateType<T>>

    /**
     * Group by EncabezadoCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoCompraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncabezadoCompraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncabezadoCompraGroupByArgs['orderBy'] }
        : { orderBy?: EncabezadoCompraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncabezadoCompraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncabezadoCompraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncabezadoCompra model
   */
  readonly fields: EncabezadoCompraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncabezadoCompra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncabezadoCompraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    proveedor<T extends ProveedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProveedorDefaultArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    detalleCompra<T extends EncabezadoCompra$detalleCompraArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoCompra$detalleCompraArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findMany'> | Null>;

    pedido<T extends EncabezadoCompra$pedidoArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoCompra$pedidoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EncabezadoCompra model
   */ 
  interface EncabezadoCompraFieldRefs {
    readonly id: FieldRef<"EncabezadoCompra", 'Int'>
    readonly fechaCompra: FieldRef<"EncabezadoCompra", 'DateTime'>
    readonly idProveedor: FieldRef<"EncabezadoCompra", 'Int'>
    readonly idUsuario: FieldRef<"EncabezadoCompra", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EncabezadoCompra findUnique
   */
  export type EncabezadoCompraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompra to fetch.
     */
    where: EncabezadoCompraWhereUniqueInput
  }


  /**
   * EncabezadoCompra findUniqueOrThrow
   */
  export type EncabezadoCompraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompra to fetch.
     */
    where: EncabezadoCompraWhereUniqueInput
  }


  /**
   * EncabezadoCompra findFirst
   */
  export type EncabezadoCompraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompra to fetch.
     */
    where?: EncabezadoCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoCompras to fetch.
     */
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncabezadoCompras.
     */
    cursor?: EncabezadoCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncabezadoCompras.
     */
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra findFirstOrThrow
   */
  export type EncabezadoCompraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompra to fetch.
     */
    where?: EncabezadoCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoCompras to fetch.
     */
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncabezadoCompras.
     */
    cursor?: EncabezadoCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncabezadoCompras.
     */
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra findMany
   */
  export type EncabezadoCompraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoCompras to fetch.
     */
    where?: EncabezadoCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoCompras to fetch.
     */
    orderBy?: EncabezadoCompraOrderByWithRelationInput | EncabezadoCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncabezadoCompras.
     */
    cursor?: EncabezadoCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoCompras.
     */
    skip?: number
    distinct?: EncabezadoCompraScalarFieldEnum | EncabezadoCompraScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra create
   */
  export type EncabezadoCompraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * The data needed to create a EncabezadoCompra.
     */
    data: XOR<EncabezadoCompraCreateInput, EncabezadoCompraUncheckedCreateInput>
  }


  /**
   * EncabezadoCompra createMany
   */
  export type EncabezadoCompraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncabezadoCompras.
     */
    data: EncabezadoCompraCreateManyInput | EncabezadoCompraCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EncabezadoCompra update
   */
  export type EncabezadoCompraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * The data needed to update a EncabezadoCompra.
     */
    data: XOR<EncabezadoCompraUpdateInput, EncabezadoCompraUncheckedUpdateInput>
    /**
     * Choose, which EncabezadoCompra to update.
     */
    where: EncabezadoCompraWhereUniqueInput
  }


  /**
   * EncabezadoCompra updateMany
   */
  export type EncabezadoCompraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncabezadoCompras.
     */
    data: XOR<EncabezadoCompraUpdateManyMutationInput, EncabezadoCompraUncheckedUpdateManyInput>
    /**
     * Filter which EncabezadoCompras to update
     */
    where?: EncabezadoCompraWhereInput
  }


  /**
   * EncabezadoCompra upsert
   */
  export type EncabezadoCompraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * The filter to search for the EncabezadoCompra to update in case it exists.
     */
    where: EncabezadoCompraWhereUniqueInput
    /**
     * In case the EncabezadoCompra found by the `where` argument doesn't exist, create a new EncabezadoCompra with this data.
     */
    create: XOR<EncabezadoCompraCreateInput, EncabezadoCompraUncheckedCreateInput>
    /**
     * In case the EncabezadoCompra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncabezadoCompraUpdateInput, EncabezadoCompraUncheckedUpdateInput>
  }


  /**
   * EncabezadoCompra delete
   */
  export type EncabezadoCompraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
    /**
     * Filter which EncabezadoCompra to delete.
     */
    where: EncabezadoCompraWhereUniqueInput
  }


  /**
   * EncabezadoCompra deleteMany
   */
  export type EncabezadoCompraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncabezadoCompras to delete
     */
    where?: EncabezadoCompraWhereInput
  }


  /**
   * EncabezadoCompra.detalleCompra
   */
  export type EncabezadoCompra$detalleCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    where?: DetalleCompraWhereInput
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    cursor?: DetalleCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra.pedido
   */
  export type EncabezadoCompra$pedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * EncabezadoCompra without action
   */
  export type EncabezadoCompraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoCompra
     */
    select?: EncabezadoCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EncabezadoCompraInclude<ExtArgs> | null
  }



  /**
   * Model DetalleCompra
   */

  export type AggregateDetalleCompra = {
    _count: DetalleCompraCountAggregateOutputType | null
    _avg: DetalleCompraAvgAggregateOutputType | null
    _sum: DetalleCompraSumAggregateOutputType | null
    _min: DetalleCompraMinAggregateOutputType | null
    _max: DetalleCompraMaxAggregateOutputType | null
  }

  export type DetalleCompraAvgAggregateOutputType = {
    id: number | null
    idEncabezadoCompra: number | null
    idProducto: number | null
    idBodega: number | null
    cantidad: number | null
  }

  export type DetalleCompraSumAggregateOutputType = {
    id: number | null
    idEncabezadoCompra: number | null
    idProducto: number | null
    idBodega: number | null
    cantidad: number | null
  }

  export type DetalleCompraMinAggregateOutputType = {
    id: number | null
    idEncabezadoCompra: number | null
    idProducto: number | null
    idBodega: number | null
    cantidad: number | null
  }

  export type DetalleCompraMaxAggregateOutputType = {
    id: number | null
    idEncabezadoCompra: number | null
    idProducto: number | null
    idBodega: number | null
    cantidad: number | null
  }

  export type DetalleCompraCountAggregateOutputType = {
    id: number
    idEncabezadoCompra: number
    idProducto: number
    idBodega: number
    cantidad: number
    _all: number
  }


  export type DetalleCompraAvgAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
  }

  export type DetalleCompraSumAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
  }

  export type DetalleCompraMinAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
  }

  export type DetalleCompraMaxAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
  }

  export type DetalleCompraCountAggregateInputType = {
    id?: true
    idEncabezadoCompra?: true
    idProducto?: true
    idBodega?: true
    cantidad?: true
    _all?: true
  }

  export type DetalleCompraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetalleCompra to aggregate.
     */
    where?: DetalleCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     */
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetalleCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetalleCompras
    **/
    _count?: true | DetalleCompraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetalleCompraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetalleCompraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetalleCompraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetalleCompraMaxAggregateInputType
  }

  export type GetDetalleCompraAggregateType<T extends DetalleCompraAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalleCompra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalleCompra[P]>
      : GetScalarType<T[P], AggregateDetalleCompra[P]>
  }




  export type DetalleCompraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleCompraWhereInput
    orderBy?: DetalleCompraOrderByWithAggregationInput | DetalleCompraOrderByWithAggregationInput[]
    by: DetalleCompraScalarFieldEnum[] | DetalleCompraScalarFieldEnum
    having?: DetalleCompraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetalleCompraCountAggregateInputType | true
    _avg?: DetalleCompraAvgAggregateInputType
    _sum?: DetalleCompraSumAggregateInputType
    _min?: DetalleCompraMinAggregateInputType
    _max?: DetalleCompraMaxAggregateInputType
  }

  export type DetalleCompraGroupByOutputType = {
    id: number
    idEncabezadoCompra: number
    idProducto: number
    idBodega: number
    cantidad: number
    _count: DetalleCompraCountAggregateOutputType | null
    _avg: DetalleCompraAvgAggregateOutputType | null
    _sum: DetalleCompraSumAggregateOutputType | null
    _min: DetalleCompraMinAggregateOutputType | null
    _max: DetalleCompraMaxAggregateOutputType | null
  }

  type GetDetalleCompraGroupByPayload<T extends DetalleCompraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetalleCompraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetalleCompraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetalleCompraGroupByOutputType[P]>
            : GetScalarType<T[P], DetalleCompraGroupByOutputType[P]>
        }
      >
    >


  export type DetalleCompraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idEncabezadoCompra?: boolean
    idProducto?: boolean
    idBodega?: boolean
    cantidad?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    encabezadoCompra?: boolean | EncabezadoCompraDefaultArgs<ExtArgs>
    bodega?: boolean | BodegaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalleCompra"]>

  export type DetalleCompraSelectScalar = {
    id?: boolean
    idEncabezadoCompra?: boolean
    idProducto?: boolean
    idBodega?: boolean
    cantidad?: boolean
  }

  export type DetalleCompraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    encabezadoCompra?: boolean | EncabezadoCompraDefaultArgs<ExtArgs>
    bodega?: boolean | BodegaDefaultArgs<ExtArgs>
  }


  export type $DetalleCompraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetalleCompra"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>
      encabezadoCompra: Prisma.$EncabezadoCompraPayload<ExtArgs>
      bodega: Prisma.$BodegaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idEncabezadoCompra: number
      idProducto: number
      idBodega: number
      cantidad: number
    }, ExtArgs["result"]["detalleCompra"]>
    composites: {}
  }


  type DetalleCompraGetPayload<S extends boolean | null | undefined | DetalleCompraDefaultArgs> = $Result.GetResult<Prisma.$DetalleCompraPayload, S>

  type DetalleCompraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DetalleCompraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DetalleCompraCountAggregateInputType | true
    }

  export interface DetalleCompraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetalleCompra'], meta: { name: 'DetalleCompra' } }
    /**
     * Find zero or one DetalleCompra that matches the filter.
     * @param {DetalleCompraFindUniqueArgs} args - Arguments to find a DetalleCompra
     * @example
     * // Get one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DetalleCompraFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraFindUniqueArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DetalleCompra that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DetalleCompraFindUniqueOrThrowArgs} args - Arguments to find a DetalleCompra
     * @example
     * // Get one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DetalleCompraFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DetalleCompra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraFindFirstArgs} args - Arguments to find a DetalleCompra
     * @example
     * // Get one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DetalleCompraFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraFindFirstArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DetalleCompra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraFindFirstOrThrowArgs} args - Arguments to find a DetalleCompra
     * @example
     * // Get one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DetalleCompraFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DetalleCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetalleCompras
     * const detalleCompras = await prisma.detalleCompra.findMany()
     * 
     * // Get first 10 DetalleCompras
     * const detalleCompras = await prisma.detalleCompra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detalleCompraWithIdOnly = await prisma.detalleCompra.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DetalleCompraFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DetalleCompra.
     * @param {DetalleCompraCreateArgs} args - Arguments to create a DetalleCompra.
     * @example
     * // Create one DetalleCompra
     * const DetalleCompra = await prisma.detalleCompra.create({
     *   data: {
     *     // ... data to create a DetalleCompra
     *   }
     * })
     * 
    **/
    create<T extends DetalleCompraCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraCreateArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DetalleCompras.
     *     @param {DetalleCompraCreateManyArgs} args - Arguments to create many DetalleCompras.
     *     @example
     *     // Create many DetalleCompras
     *     const detalleCompra = await prisma.detalleCompra.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DetalleCompraCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DetalleCompra.
     * @param {DetalleCompraDeleteArgs} args - Arguments to delete one DetalleCompra.
     * @example
     * // Delete one DetalleCompra
     * const DetalleCompra = await prisma.detalleCompra.delete({
     *   where: {
     *     // ... filter to delete one DetalleCompra
     *   }
     * })
     * 
    **/
    delete<T extends DetalleCompraDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraDeleteArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DetalleCompra.
     * @param {DetalleCompraUpdateArgs} args - Arguments to update one DetalleCompra.
     * @example
     * // Update one DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DetalleCompraUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraUpdateArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DetalleCompras.
     * @param {DetalleCompraDeleteManyArgs} args - Arguments to filter DetalleCompras to delete.
     * @example
     * // Delete a few DetalleCompras
     * const { count } = await prisma.detalleCompra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DetalleCompraDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DetalleCompraDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetalleCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetalleCompras
     * const detalleCompra = await prisma.detalleCompra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DetalleCompraUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetalleCompra.
     * @param {DetalleCompraUpsertArgs} args - Arguments to update or create a DetalleCompra.
     * @example
     * // Update or create a DetalleCompra
     * const detalleCompra = await prisma.detalleCompra.upsert({
     *   create: {
     *     // ... data to create a DetalleCompra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetalleCompra we want to update
     *   }
     * })
    **/
    upsert<T extends DetalleCompraUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DetalleCompraUpsertArgs<ExtArgs>>
    ): Prisma__DetalleCompraClient<$Result.GetResult<Prisma.$DetalleCompraPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DetalleCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraCountArgs} args - Arguments to filter DetalleCompras to count.
     * @example
     * // Count the number of DetalleCompras
     * const count = await prisma.detalleCompra.count({
     *   where: {
     *     // ... the filter for the DetalleCompras we want to count
     *   }
     * })
    **/
    count<T extends DetalleCompraCountArgs>(
      args?: Subset<T, DetalleCompraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetalleCompraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetalleCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetalleCompraAggregateArgs>(args: Subset<T, DetalleCompraAggregateArgs>): Prisma.PrismaPromise<GetDetalleCompraAggregateType<T>>

    /**
     * Group by DetalleCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleCompraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetalleCompraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetalleCompraGroupByArgs['orderBy'] }
        : { orderBy?: DetalleCompraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetalleCompraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalleCompraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetalleCompra model
   */
  readonly fields: DetalleCompraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetalleCompra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetalleCompraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    encabezadoCompra<T extends EncabezadoCompraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoCompraDefaultArgs<ExtArgs>>): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bodega<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DetalleCompra model
   */ 
  interface DetalleCompraFieldRefs {
    readonly id: FieldRef<"DetalleCompra", 'Int'>
    readonly idEncabezadoCompra: FieldRef<"DetalleCompra", 'Int'>
    readonly idProducto: FieldRef<"DetalleCompra", 'Int'>
    readonly idBodega: FieldRef<"DetalleCompra", 'Int'>
    readonly cantidad: FieldRef<"DetalleCompra", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * DetalleCompra findUnique
   */
  export type DetalleCompraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompra to fetch.
     */
    where: DetalleCompraWhereUniqueInput
  }


  /**
   * DetalleCompra findUniqueOrThrow
   */
  export type DetalleCompraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompra to fetch.
     */
    where: DetalleCompraWhereUniqueInput
  }


  /**
   * DetalleCompra findFirst
   */
  export type DetalleCompraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompra to fetch.
     */
    where?: DetalleCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     */
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleCompras.
     */
    cursor?: DetalleCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleCompras.
     */
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * DetalleCompra findFirstOrThrow
   */
  export type DetalleCompraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompra to fetch.
     */
    where?: DetalleCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     */
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleCompras.
     */
    cursor?: DetalleCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleCompras.
     */
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * DetalleCompra findMany
   */
  export type DetalleCompraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter, which DetalleCompras to fetch.
     */
    where?: DetalleCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleCompras to fetch.
     */
    orderBy?: DetalleCompraOrderByWithRelationInput | DetalleCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetalleCompras.
     */
    cursor?: DetalleCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleCompras.
     */
    skip?: number
    distinct?: DetalleCompraScalarFieldEnum | DetalleCompraScalarFieldEnum[]
  }


  /**
   * DetalleCompra create
   */
  export type DetalleCompraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * The data needed to create a DetalleCompra.
     */
    data: XOR<DetalleCompraCreateInput, DetalleCompraUncheckedCreateInput>
  }


  /**
   * DetalleCompra createMany
   */
  export type DetalleCompraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetalleCompras.
     */
    data: DetalleCompraCreateManyInput | DetalleCompraCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DetalleCompra update
   */
  export type DetalleCompraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * The data needed to update a DetalleCompra.
     */
    data: XOR<DetalleCompraUpdateInput, DetalleCompraUncheckedUpdateInput>
    /**
     * Choose, which DetalleCompra to update.
     */
    where: DetalleCompraWhereUniqueInput
  }


  /**
   * DetalleCompra updateMany
   */
  export type DetalleCompraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetalleCompras.
     */
    data: XOR<DetalleCompraUpdateManyMutationInput, DetalleCompraUncheckedUpdateManyInput>
    /**
     * Filter which DetalleCompras to update
     */
    where?: DetalleCompraWhereInput
  }


  /**
   * DetalleCompra upsert
   */
  export type DetalleCompraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * The filter to search for the DetalleCompra to update in case it exists.
     */
    where: DetalleCompraWhereUniqueInput
    /**
     * In case the DetalleCompra found by the `where` argument doesn't exist, create a new DetalleCompra with this data.
     */
    create: XOR<DetalleCompraCreateInput, DetalleCompraUncheckedCreateInput>
    /**
     * In case the DetalleCompra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetalleCompraUpdateInput, DetalleCompraUncheckedUpdateInput>
  }


  /**
   * DetalleCompra delete
   */
  export type DetalleCompraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
    /**
     * Filter which DetalleCompra to delete.
     */
    where: DetalleCompraWhereUniqueInput
  }


  /**
   * DetalleCompra deleteMany
   */
  export type DetalleCompraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetalleCompras to delete
     */
    where?: DetalleCompraWhereInput
  }


  /**
   * DetalleCompra without action
   */
  export type DetalleCompraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleCompra
     */
    select?: DetalleCompraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DetalleCompraInclude<ExtArgs> | null
  }



  /**
   * Model Pedido
   */

  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    idEncabezadoCompra: number | null
    idEstado: number | null
  }

  export type PedidoSumAggregateOutputType = {
    idEncabezadoCompra: number | null
    idEstado: number | null
  }

  export type PedidoMinAggregateOutputType = {
    idEncabezadoCompra: number | null
    idEstado: number | null
    observaciones: string | null
    fechaPedido: Date | null
  }

  export type PedidoMaxAggregateOutputType = {
    idEncabezadoCompra: number | null
    idEstado: number | null
    observaciones: string | null
    fechaPedido: Date | null
  }

  export type PedidoCountAggregateOutputType = {
    idEncabezadoCompra: number
    idEstado: number
    observaciones: number
    fechaPedido: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    idEncabezadoCompra?: true
    idEstado?: true
  }

  export type PedidoSumAggregateInputType = {
    idEncabezadoCompra?: true
    idEstado?: true
  }

  export type PedidoMinAggregateInputType = {
    idEncabezadoCompra?: true
    idEstado?: true
    observaciones?: true
    fechaPedido?: true
  }

  export type PedidoMaxAggregateInputType = {
    idEncabezadoCompra?: true
    idEstado?: true
    observaciones?: true
    fechaPedido?: true
  }

  export type PedidoCountAggregateInputType = {
    idEncabezadoCompra?: true
    idEstado?: true
    observaciones?: true
    fechaPedido?: true
    _all?: true
  }

  export type PedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedido to aggregate.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithAggregationInput | PedidoOrderByWithAggregationInput[]
    by: PedidoScalarFieldEnum[] | PedidoScalarFieldEnum
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }

  export type PedidoGroupByOutputType = {
    idEncabezadoCompra: number
    idEstado: number
    observaciones: string | null
    fechaPedido: Date
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEncabezadoCompra?: boolean
    idEstado?: boolean
    observaciones?: boolean
    fechaPedido?: boolean
    estadoPedido?: boolean | EstadoDefaultArgs<ExtArgs>
    encabezadoCompra?: boolean | EncabezadoCompraDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectScalar = {
    idEncabezadoCompra?: boolean
    idEstado?: boolean
    observaciones?: boolean
    fechaPedido?: boolean
  }

  export type PedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estadoPedido?: boolean | EstadoDefaultArgs<ExtArgs>
    encabezadoCompra?: boolean | EncabezadoCompraDefaultArgs<ExtArgs>
  }


  export type $PedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pedido"
    objects: {
      estadoPedido: Prisma.$EstadoPayload<ExtArgs>
      encabezadoCompra: Prisma.$EncabezadoCompraPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idEncabezadoCompra: number
      idEstado: number
      observaciones: string | null
      fechaPedido: Date
    }, ExtArgs["result"]["pedido"]>
    composites: {}
  }


  type PedidoGetPayload<S extends boolean | null | undefined | PedidoDefaultArgs> = $Result.GetResult<Prisma.$PedidoPayload, S>

  type PedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PedidoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface PedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pedido'], meta: { name: 'Pedido' } }
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoFindUniqueArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pedido that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindFirstArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `idEncabezadoCompra`
     * const pedidoWithIdEncabezadoCompraOnly = await prisma.pedido.findMany({ select: { idEncabezadoCompra: true } })
     * 
    **/
    findMany<T extends PedidoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
    **/
    create<T extends PedidoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoCreateArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pedidos.
     *     @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     *     @example
     *     // Create many Pedidos
     *     const pedido = await prisma.pedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
    **/
    delete<T extends PedidoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeleteArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpdateArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoUpsertArgs<ExtArgs>>
    ): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pedido model
   */
  readonly fields: PedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    estadoPedido<T extends EstadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstadoDefaultArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    encabezadoCompra<T extends EncabezadoCompraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoCompraDefaultArgs<ExtArgs>>): Prisma__EncabezadoCompraClient<$Result.GetResult<Prisma.$EncabezadoCompraPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Pedido model
   */ 
  interface PedidoFieldRefs {
    readonly idEncabezadoCompra: FieldRef<"Pedido", 'Int'>
    readonly idEstado: FieldRef<"Pedido", 'Int'>
    readonly observaciones: FieldRef<"Pedido", 'String'>
    readonly fechaPedido: FieldRef<"Pedido", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Pedido findUnique
   */
  export type PedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido findFirst
   */
  export type PedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedidos to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }


  /**
   * Pedido create
   */
  export type PedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pedido.
     */
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }


  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Pedido update
   */
  export type PedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pedido.
     */
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
  }


  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     */
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     */
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }


  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter which Pedido to delete.
     */
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedidos to delete
     */
    where?: PedidoWhereInput
  }


  /**
   * Pedido without action
   */
  export type PedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoInclude<ExtArgs> | null
  }



  /**
   * Model Traslado
   */

  export type AggregateTraslado = {
    _count: TrasladoCountAggregateOutputType | null
    _avg: TrasladoAvgAggregateOutputType | null
    _sum: TrasladoSumAggregateOutputType | null
    _min: TrasladoMinAggregateOutputType | null
    _max: TrasladoMaxAggregateOutputType | null
  }

  export type TrasladoAvgAggregateOutputType = {
    id: number | null
    idBodegaOrigen: number | null
    idBodegaDestino: number | null
    idUsuario: number | null
    idProducto: number | null
    cantidad: number | null
    idEstado: number | null
  }

  export type TrasladoSumAggregateOutputType = {
    id: number | null
    idBodegaOrigen: number | null
    idBodegaDestino: number | null
    idUsuario: number | null
    idProducto: number | null
    cantidad: number | null
    idEstado: number | null
  }

  export type TrasladoMinAggregateOutputType = {
    id: number | null
    idBodegaOrigen: number | null
    idBodegaDestino: number | null
    idUsuario: number | null
    idProducto: number | null
    cantidad: number | null
    idEstado: number | null
    fechaRegistro: Date | null
  }

  export type TrasladoMaxAggregateOutputType = {
    id: number | null
    idBodegaOrigen: number | null
    idBodegaDestino: number | null
    idUsuario: number | null
    idProducto: number | null
    cantidad: number | null
    idEstado: number | null
    fechaRegistro: Date | null
  }

  export type TrasladoCountAggregateOutputType = {
    id: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idUsuario: number
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro: number
    _all: number
  }


  export type TrasladoAvgAggregateInputType = {
    id?: true
    idBodegaOrigen?: true
    idBodegaDestino?: true
    idUsuario?: true
    idProducto?: true
    cantidad?: true
    idEstado?: true
  }

  export type TrasladoSumAggregateInputType = {
    id?: true
    idBodegaOrigen?: true
    idBodegaDestino?: true
    idUsuario?: true
    idProducto?: true
    cantidad?: true
    idEstado?: true
  }

  export type TrasladoMinAggregateInputType = {
    id?: true
    idBodegaOrigen?: true
    idBodegaDestino?: true
    idUsuario?: true
    idProducto?: true
    cantidad?: true
    idEstado?: true
    fechaRegistro?: true
  }

  export type TrasladoMaxAggregateInputType = {
    id?: true
    idBodegaOrigen?: true
    idBodegaDestino?: true
    idUsuario?: true
    idProducto?: true
    cantidad?: true
    idEstado?: true
    fechaRegistro?: true
  }

  export type TrasladoCountAggregateInputType = {
    id?: true
    idBodegaOrigen?: true
    idBodegaDestino?: true
    idUsuario?: true
    idProducto?: true
    cantidad?: true
    idEstado?: true
    fechaRegistro?: true
    _all?: true
  }

  export type TrasladoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Traslado to aggregate.
     */
    where?: TrasladoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traslados to fetch.
     */
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrasladoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traslados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traslados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Traslados
    **/
    _count?: true | TrasladoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrasladoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrasladoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrasladoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrasladoMaxAggregateInputType
  }

  export type GetTrasladoAggregateType<T extends TrasladoAggregateArgs> = {
        [P in keyof T & keyof AggregateTraslado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraslado[P]>
      : GetScalarType<T[P], AggregateTraslado[P]>
  }




  export type TrasladoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrasladoWhereInput
    orderBy?: TrasladoOrderByWithAggregationInput | TrasladoOrderByWithAggregationInput[]
    by: TrasladoScalarFieldEnum[] | TrasladoScalarFieldEnum
    having?: TrasladoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrasladoCountAggregateInputType | true
    _avg?: TrasladoAvgAggregateInputType
    _sum?: TrasladoSumAggregateInputType
    _min?: TrasladoMinAggregateInputType
    _max?: TrasladoMaxAggregateInputType
  }

  export type TrasladoGroupByOutputType = {
    id: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idUsuario: number | null
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro: Date
    _count: TrasladoCountAggregateOutputType | null
    _avg: TrasladoAvgAggregateOutputType | null
    _sum: TrasladoSumAggregateOutputType | null
    _min: TrasladoMinAggregateOutputType | null
    _max: TrasladoMaxAggregateOutputType | null
  }

  type GetTrasladoGroupByPayload<T extends TrasladoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrasladoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrasladoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrasladoGroupByOutputType[P]>
            : GetScalarType<T[P], TrasladoGroupByOutputType[P]>
        }
      >
    >


  export type TrasladoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idBodegaOrigen?: boolean
    idBodegaDestino?: boolean
    idUsuario?: boolean
    idProducto?: boolean
    cantidad?: boolean
    idEstado?: boolean
    fechaRegistro?: boolean
    bodegaOrigen?: boolean | BodegaDefaultArgs<ExtArgs>
    bodegaDestino?: boolean | BodegaDefaultArgs<ExtArgs>
    estadoDestino?: boolean | EstadoDefaultArgs<ExtArgs>
    usuario?: boolean | Traslado$usuarioArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["traslado"]>

  export type TrasladoSelectScalar = {
    id?: boolean
    idBodegaOrigen?: boolean
    idBodegaDestino?: boolean
    idUsuario?: boolean
    idProducto?: boolean
    cantidad?: boolean
    idEstado?: boolean
    fechaRegistro?: boolean
  }

  export type TrasladoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodegaOrigen?: boolean | BodegaDefaultArgs<ExtArgs>
    bodegaDestino?: boolean | BodegaDefaultArgs<ExtArgs>
    estadoDestino?: boolean | EstadoDefaultArgs<ExtArgs>
    usuario?: boolean | Traslado$usuarioArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }


  export type $TrasladoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Traslado"
    objects: {
      bodegaOrigen: Prisma.$BodegaPayload<ExtArgs>
      bodegaDestino: Prisma.$BodegaPayload<ExtArgs>
      estadoDestino: Prisma.$EstadoPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs> | null
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idBodegaOrigen: number
      idBodegaDestino: number
      idUsuario: number | null
      idProducto: number
      cantidad: number
      idEstado: number
      fechaRegistro: Date
    }, ExtArgs["result"]["traslado"]>
    composites: {}
  }


  type TrasladoGetPayload<S extends boolean | null | undefined | TrasladoDefaultArgs> = $Result.GetResult<Prisma.$TrasladoPayload, S>

  type TrasladoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrasladoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrasladoCountAggregateInputType | true
    }

  export interface TrasladoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Traslado'], meta: { name: 'Traslado' } }
    /**
     * Find zero or one Traslado that matches the filter.
     * @param {TrasladoFindUniqueArgs} args - Arguments to find a Traslado
     * @example
     * // Get one Traslado
     * const traslado = await prisma.traslado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrasladoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoFindUniqueArgs<ExtArgs>>
    ): Prisma__TrasladoClient<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Traslado that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrasladoFindUniqueOrThrowArgs} args - Arguments to find a Traslado
     * @example
     * // Get one Traslado
     * const traslado = await prisma.traslado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrasladoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrasladoClient<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Traslado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoFindFirstArgs} args - Arguments to find a Traslado
     * @example
     * // Get one Traslado
     * const traslado = await prisma.traslado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrasladoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoFindFirstArgs<ExtArgs>>
    ): Prisma__TrasladoClient<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Traslado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoFindFirstOrThrowArgs} args - Arguments to find a Traslado
     * @example
     * // Get one Traslado
     * const traslado = await prisma.traslado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrasladoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrasladoClient<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Traslados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Traslados
     * const traslados = await prisma.traslado.findMany()
     * 
     * // Get first 10 Traslados
     * const traslados = await prisma.traslado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trasladoWithIdOnly = await prisma.traslado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrasladoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Traslado.
     * @param {TrasladoCreateArgs} args - Arguments to create a Traslado.
     * @example
     * // Create one Traslado
     * const Traslado = await prisma.traslado.create({
     *   data: {
     *     // ... data to create a Traslado
     *   }
     * })
     * 
    **/
    create<T extends TrasladoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoCreateArgs<ExtArgs>>
    ): Prisma__TrasladoClient<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Traslados.
     *     @param {TrasladoCreateManyArgs} args - Arguments to create many Traslados.
     *     @example
     *     // Create many Traslados
     *     const traslado = await prisma.traslado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrasladoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Traslado.
     * @param {TrasladoDeleteArgs} args - Arguments to delete one Traslado.
     * @example
     * // Delete one Traslado
     * const Traslado = await prisma.traslado.delete({
     *   where: {
     *     // ... filter to delete one Traslado
     *   }
     * })
     * 
    **/
    delete<T extends TrasladoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoDeleteArgs<ExtArgs>>
    ): Prisma__TrasladoClient<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Traslado.
     * @param {TrasladoUpdateArgs} args - Arguments to update one Traslado.
     * @example
     * // Update one Traslado
     * const traslado = await prisma.traslado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrasladoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoUpdateArgs<ExtArgs>>
    ): Prisma__TrasladoClient<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Traslados.
     * @param {TrasladoDeleteManyArgs} args - Arguments to filter Traslados to delete.
     * @example
     * // Delete a few Traslados
     * const { count } = await prisma.traslado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrasladoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrasladoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Traslados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Traslados
     * const traslado = await prisma.traslado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrasladoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Traslado.
     * @param {TrasladoUpsertArgs} args - Arguments to update or create a Traslado.
     * @example
     * // Update or create a Traslado
     * const traslado = await prisma.traslado.upsert({
     *   create: {
     *     // ... data to create a Traslado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Traslado we want to update
     *   }
     * })
    **/
    upsert<T extends TrasladoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrasladoUpsertArgs<ExtArgs>>
    ): Prisma__TrasladoClient<$Result.GetResult<Prisma.$TrasladoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Traslados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoCountArgs} args - Arguments to filter Traslados to count.
     * @example
     * // Count the number of Traslados
     * const count = await prisma.traslado.count({
     *   where: {
     *     // ... the filter for the Traslados we want to count
     *   }
     * })
    **/
    count<T extends TrasladoCountArgs>(
      args?: Subset<T, TrasladoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrasladoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Traslado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrasladoAggregateArgs>(args: Subset<T, TrasladoAggregateArgs>): Prisma.PrismaPromise<GetTrasladoAggregateType<T>>

    /**
     * Group by Traslado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrasladoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrasladoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrasladoGroupByArgs['orderBy'] }
        : { orderBy?: TrasladoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrasladoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrasladoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Traslado model
   */
  readonly fields: TrasladoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Traslado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrasladoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bodegaOrigen<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bodegaDestino<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    estadoDestino<T extends EstadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstadoDefaultArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuario<T extends Traslado$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Traslado$usuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Traslado model
   */ 
  interface TrasladoFieldRefs {
    readonly id: FieldRef<"Traslado", 'Int'>
    readonly idBodegaOrigen: FieldRef<"Traslado", 'Int'>
    readonly idBodegaDestino: FieldRef<"Traslado", 'Int'>
    readonly idUsuario: FieldRef<"Traslado", 'Int'>
    readonly idProducto: FieldRef<"Traslado", 'Int'>
    readonly cantidad: FieldRef<"Traslado", 'Int'>
    readonly idEstado: FieldRef<"Traslado", 'Int'>
    readonly fechaRegistro: FieldRef<"Traslado", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Traslado findUnique
   */
  export type TrasladoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * Filter, which Traslado to fetch.
     */
    where: TrasladoWhereUniqueInput
  }


  /**
   * Traslado findUniqueOrThrow
   */
  export type TrasladoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * Filter, which Traslado to fetch.
     */
    where: TrasladoWhereUniqueInput
  }


  /**
   * Traslado findFirst
   */
  export type TrasladoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * Filter, which Traslado to fetch.
     */
    where?: TrasladoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traslados to fetch.
     */
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traslados.
     */
    cursor?: TrasladoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traslados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traslados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traslados.
     */
    distinct?: TrasladoScalarFieldEnum | TrasladoScalarFieldEnum[]
  }


  /**
   * Traslado findFirstOrThrow
   */
  export type TrasladoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * Filter, which Traslado to fetch.
     */
    where?: TrasladoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traslados to fetch.
     */
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traslados.
     */
    cursor?: TrasladoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traslados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traslados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traslados.
     */
    distinct?: TrasladoScalarFieldEnum | TrasladoScalarFieldEnum[]
  }


  /**
   * Traslado findMany
   */
  export type TrasladoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * Filter, which Traslados to fetch.
     */
    where?: TrasladoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traslados to fetch.
     */
    orderBy?: TrasladoOrderByWithRelationInput | TrasladoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Traslados.
     */
    cursor?: TrasladoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traslados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traslados.
     */
    skip?: number
    distinct?: TrasladoScalarFieldEnum | TrasladoScalarFieldEnum[]
  }


  /**
   * Traslado create
   */
  export type TrasladoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * The data needed to create a Traslado.
     */
    data: XOR<TrasladoCreateInput, TrasladoUncheckedCreateInput>
  }


  /**
   * Traslado createMany
   */
  export type TrasladoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Traslados.
     */
    data: TrasladoCreateManyInput | TrasladoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Traslado update
   */
  export type TrasladoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * The data needed to update a Traslado.
     */
    data: XOR<TrasladoUpdateInput, TrasladoUncheckedUpdateInput>
    /**
     * Choose, which Traslado to update.
     */
    where: TrasladoWhereUniqueInput
  }


  /**
   * Traslado updateMany
   */
  export type TrasladoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Traslados.
     */
    data: XOR<TrasladoUpdateManyMutationInput, TrasladoUncheckedUpdateManyInput>
    /**
     * Filter which Traslados to update
     */
    where?: TrasladoWhereInput
  }


  /**
   * Traslado upsert
   */
  export type TrasladoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * The filter to search for the Traslado to update in case it exists.
     */
    where: TrasladoWhereUniqueInput
    /**
     * In case the Traslado found by the `where` argument doesn't exist, create a new Traslado with this data.
     */
    create: XOR<TrasladoCreateInput, TrasladoUncheckedCreateInput>
    /**
     * In case the Traslado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrasladoUpdateInput, TrasladoUncheckedUpdateInput>
  }


  /**
   * Traslado delete
   */
  export type TrasladoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
    /**
     * Filter which Traslado to delete.
     */
    where: TrasladoWhereUniqueInput
  }


  /**
   * Traslado deleteMany
   */
  export type TrasladoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Traslados to delete
     */
    where?: TrasladoWhereInput
  }


  /**
   * Traslado.usuario
   */
  export type Traslado$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }


  /**
   * Traslado without action
   */
  export type TrasladoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Traslado
     */
    select?: TrasladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrasladoInclude<ExtArgs> | null
  }



  /**
   * Model Historial
   */

  export type AggregateHistorial = {
    _count: HistorialCountAggregateOutputType | null
    _avg: HistorialAvgAggregateOutputType | null
    _sum: HistorialSumAggregateOutputType | null
    _min: HistorialMinAggregateOutputType | null
    _max: HistorialMaxAggregateOutputType | null
  }

  export type HistorialAvgAggregateOutputType = {
    id: number | null
    idBodega: number | null
    idUsuarioRegistro: number | null
    idProducto: number | null
  }

  export type HistorialSumAggregateOutputType = {
    id: number | null
    idBodega: number | null
    idUsuarioRegistro: number | null
    idProducto: number | null
  }

  export type HistorialMinAggregateOutputType = {
    id: number | null
    idBodega: number | null
    idUsuarioRegistro: number | null
    idProducto: number | null
    justificacion: string | null
    fechaAjuste: Date | null
  }

  export type HistorialMaxAggregateOutputType = {
    id: number | null
    idBodega: number | null
    idUsuarioRegistro: number | null
    idProducto: number | null
    justificacion: string | null
    fechaAjuste: Date | null
  }

  export type HistorialCountAggregateOutputType = {
    id: number
    idBodega: number
    idUsuarioRegistro: number
    idProducto: number
    justificacion: number
    fechaAjuste: number
    _all: number
  }


  export type HistorialAvgAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
  }

  export type HistorialSumAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
  }

  export type HistorialMinAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
    justificacion?: true
    fechaAjuste?: true
  }

  export type HistorialMaxAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
    justificacion?: true
    fechaAjuste?: true
  }

  export type HistorialCountAggregateInputType = {
    id?: true
    idBodega?: true
    idUsuarioRegistro?: true
    idProducto?: true
    justificacion?: true
    fechaAjuste?: true
    _all?: true
  }

  export type HistorialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Historial to aggregate.
     */
    where?: HistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historials to fetch.
     */
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Historials
    **/
    _count?: true | HistorialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorialMaxAggregateInputType
  }

  export type GetHistorialAggregateType<T extends HistorialAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial[P]>
      : GetScalarType<T[P], AggregateHistorial[P]>
  }




  export type HistorialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialWhereInput
    orderBy?: HistorialOrderByWithAggregationInput | HistorialOrderByWithAggregationInput[]
    by: HistorialScalarFieldEnum[] | HistorialScalarFieldEnum
    having?: HistorialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorialCountAggregateInputType | true
    _avg?: HistorialAvgAggregateInputType
    _sum?: HistorialSumAggregateInputType
    _min?: HistorialMinAggregateInputType
    _max?: HistorialMaxAggregateInputType
  }

  export type HistorialGroupByOutputType = {
    id: number
    idBodega: number
    idUsuarioRegistro: number
    idProducto: number
    justificacion: string
    fechaAjuste: Date
    _count: HistorialCountAggregateOutputType | null
    _avg: HistorialAvgAggregateOutputType | null
    _sum: HistorialSumAggregateOutputType | null
    _min: HistorialMinAggregateOutputType | null
    _max: HistorialMaxAggregateOutputType | null
  }

  type GetHistorialGroupByPayload<T extends HistorialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorialGroupByOutputType[P]>
            : GetScalarType<T[P], HistorialGroupByOutputType[P]>
        }
      >
    >


  export type HistorialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idBodega?: boolean
    idUsuarioRegistro?: boolean
    idProducto?: boolean
    justificacion?: boolean
    fechaAjuste?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    bodega?: boolean | BodegaDefaultArgs<ExtArgs>
    usuarioRegistro?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historial"]>

  export type HistorialSelectScalar = {
    id?: boolean
    idBodega?: boolean
    idUsuarioRegistro?: boolean
    idProducto?: boolean
    justificacion?: boolean
    fechaAjuste?: boolean
  }

  export type HistorialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    bodega?: boolean | BodegaDefaultArgs<ExtArgs>
    usuarioRegistro?: boolean | UsuarioDefaultArgs<ExtArgs>
  }


  export type $HistorialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Historial"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>
      bodega: Prisma.$BodegaPayload<ExtArgs>
      usuarioRegistro: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idBodega: number
      idUsuarioRegistro: number
      idProducto: number
      justificacion: string
      fechaAjuste: Date
    }, ExtArgs["result"]["historial"]>
    composites: {}
  }


  type HistorialGetPayload<S extends boolean | null | undefined | HistorialDefaultArgs> = $Result.GetResult<Prisma.$HistorialPayload, S>

  type HistorialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistorialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistorialCountAggregateInputType | true
    }

  export interface HistorialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Historial'], meta: { name: 'Historial' } }
    /**
     * Find zero or one Historial that matches the filter.
     * @param {HistorialFindUniqueArgs} args - Arguments to find a Historial
     * @example
     * // Get one Historial
     * const historial = await prisma.historial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HistorialFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialFindUniqueArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Historial that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HistorialFindUniqueOrThrowArgs} args - Arguments to find a Historial
     * @example
     * // Get one Historial
     * const historial = await prisma.historial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HistorialFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Historial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialFindFirstArgs} args - Arguments to find a Historial
     * @example
     * // Get one Historial
     * const historial = await prisma.historial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HistorialFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialFindFirstArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Historial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialFindFirstOrThrowArgs} args - Arguments to find a Historial
     * @example
     * // Get one Historial
     * const historial = await prisma.historial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HistorialFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Historials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historials
     * const historials = await prisma.historial.findMany()
     * 
     * // Get first 10 Historials
     * const historials = await prisma.historial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historialWithIdOnly = await prisma.historial.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HistorialFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Historial.
     * @param {HistorialCreateArgs} args - Arguments to create a Historial.
     * @example
     * // Create one Historial
     * const Historial = await prisma.historial.create({
     *   data: {
     *     // ... data to create a Historial
     *   }
     * })
     * 
    **/
    create<T extends HistorialCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialCreateArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Historials.
     *     @param {HistorialCreateManyArgs} args - Arguments to create many Historials.
     *     @example
     *     // Create many Historials
     *     const historial = await prisma.historial.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HistorialCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial.
     * @param {HistorialDeleteArgs} args - Arguments to delete one Historial.
     * @example
     * // Delete one Historial
     * const Historial = await prisma.historial.delete({
     *   where: {
     *     // ... filter to delete one Historial
     *   }
     * })
     * 
    **/
    delete<T extends HistorialDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialDeleteArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Historial.
     * @param {HistorialUpdateArgs} args - Arguments to update one Historial.
     * @example
     * // Update one Historial
     * const historial = await prisma.historial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HistorialUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialUpdateArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Historials.
     * @param {HistorialDeleteManyArgs} args - Arguments to filter Historials to delete.
     * @example
     * // Delete a few Historials
     * const { count } = await prisma.historial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HistorialDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historials
     * const historial = await prisma.historial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HistorialUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial.
     * @param {HistorialUpsertArgs} args - Arguments to update or create a Historial.
     * @example
     * // Update or create a Historial
     * const historial = await prisma.historial.upsert({
     *   create: {
     *     // ... data to create a Historial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial we want to update
     *   }
     * })
    **/
    upsert<T extends HistorialUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialUpsertArgs<ExtArgs>>
    ): Prisma__HistorialClient<$Result.GetResult<Prisma.$HistorialPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Historials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialCountArgs} args - Arguments to filter Historials to count.
     * @example
     * // Count the number of Historials
     * const count = await prisma.historial.count({
     *   where: {
     *     // ... the filter for the Historials we want to count
     *   }
     * })
    **/
    count<T extends HistorialCountArgs>(
      args?: Subset<T, HistorialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorialAggregateArgs>(args: Subset<T, HistorialAggregateArgs>): Prisma.PrismaPromise<GetHistorialAggregateType<T>>

    /**
     * Group by Historial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistorialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistorialGroupByArgs['orderBy'] }
        : { orderBy?: HistorialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistorialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Historial model
   */
  readonly fields: HistorialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Historial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistorialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bodega<T extends BodegaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodegaDefaultArgs<ExtArgs>>): Prisma__BodegaClient<$Result.GetResult<Prisma.$BodegaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuarioRegistro<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Historial model
   */ 
  interface HistorialFieldRefs {
    readonly id: FieldRef<"Historial", 'Int'>
    readonly idBodega: FieldRef<"Historial", 'Int'>
    readonly idUsuarioRegistro: FieldRef<"Historial", 'Int'>
    readonly idProducto: FieldRef<"Historial", 'Int'>
    readonly justificacion: FieldRef<"Historial", 'String'>
    readonly fechaAjuste: FieldRef<"Historial", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Historial findUnique
   */
  export type HistorialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historial to fetch.
     */
    where: HistorialWhereUniqueInput
  }


  /**
   * Historial findUniqueOrThrow
   */
  export type HistorialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historial to fetch.
     */
    where: HistorialWhereUniqueInput
  }


  /**
   * Historial findFirst
   */
  export type HistorialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historial to fetch.
     */
    where?: HistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historials to fetch.
     */
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Historials.
     */
    cursor?: HistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Historials.
     */
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Historial findFirstOrThrow
   */
  export type HistorialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historial to fetch.
     */
    where?: HistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historials to fetch.
     */
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Historials.
     */
    cursor?: HistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Historials.
     */
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Historial findMany
   */
  export type HistorialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter, which Historials to fetch.
     */
    where?: HistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historials to fetch.
     */
    orderBy?: HistorialOrderByWithRelationInput | HistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Historials.
     */
    cursor?: HistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historials.
     */
    skip?: number
    distinct?: HistorialScalarFieldEnum | HistorialScalarFieldEnum[]
  }


  /**
   * Historial create
   */
  export type HistorialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * The data needed to create a Historial.
     */
    data: XOR<HistorialCreateInput, HistorialUncheckedCreateInput>
  }


  /**
   * Historial createMany
   */
  export type HistorialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Historials.
     */
    data: HistorialCreateManyInput | HistorialCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Historial update
   */
  export type HistorialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * The data needed to update a Historial.
     */
    data: XOR<HistorialUpdateInput, HistorialUncheckedUpdateInput>
    /**
     * Choose, which Historial to update.
     */
    where: HistorialWhereUniqueInput
  }


  /**
   * Historial updateMany
   */
  export type HistorialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Historials.
     */
    data: XOR<HistorialUpdateManyMutationInput, HistorialUncheckedUpdateManyInput>
    /**
     * Filter which Historials to update
     */
    where?: HistorialWhereInput
  }


  /**
   * Historial upsert
   */
  export type HistorialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * The filter to search for the Historial to update in case it exists.
     */
    where: HistorialWhereUniqueInput
    /**
     * In case the Historial found by the `where` argument doesn't exist, create a new Historial with this data.
     */
    create: XOR<HistorialCreateInput, HistorialUncheckedCreateInput>
    /**
     * In case the Historial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistorialUpdateInput, HistorialUncheckedUpdateInput>
  }


  /**
   * Historial delete
   */
  export type HistorialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
    /**
     * Filter which Historial to delete.
     */
    where: HistorialWhereUniqueInput
  }


  /**
   * Historial deleteMany
   */
  export type HistorialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Historials to delete
     */
    where?: HistorialWhereInput
  }


  /**
   * Historial without action
   */
  export type HistorialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Historial
     */
    select?: HistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellidos: 'apellidos',
    correo: 'correo',
    contrasenna: 'contrasenna',
    fechaRegistro: 'fechaRegistro',
    rol: 'rol',
    idBodega: 'idBodega',
    estado: 'estado'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const EstadoScalarFieldEnum: {
    id: 'id',
    estado: 'estado'
  };

  export type EstadoScalarFieldEnum = (typeof EstadoScalarFieldEnum)[keyof typeof EstadoScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const SubCategoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type SubCategoriaScalarFieldEnum = (typeof SubCategoriaScalarFieldEnum)[keyof typeof SubCategoriaScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id: 'id',
    codigoProducto: 'codigoProducto',
    nombre: 'nombre',
    descripcion: 'descripcion',
    stock: 'stock',
    precio: 'precio',
    estadoProducto: 'estadoProducto',
    idCategoria: 'idCategoria',
    idSubCategoria: 'idSubCategoria'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const FotoScalarFieldEnum: {
    id: 'id',
    idProducto: 'idProducto',
    foto: 'foto'
  };

  export type FotoScalarFieldEnum = (typeof FotoScalarFieldEnum)[keyof typeof FotoScalarFieldEnum]


  export const UbicacionScalarFieldEnum: {
    id: 'id',
    idProvincia: 'idProvincia',
    idCanton: 'idCanton',
    idDistrito: 'idDistrito',
    direccionExacta: 'direccionExacta'
  };

  export type UbicacionScalarFieldEnum = (typeof UbicacionScalarFieldEnum)[keyof typeof UbicacionScalarFieldEnum]


  export const BodegaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    idUbicacion: 'idUbicacion',
    tamanno: 'tamanno',
    capacidad: 'capacidad',
    seguridad: 'seguridad'
  };

  export type BodegaScalarFieldEnum = (typeof BodegaScalarFieldEnum)[keyof typeof BodegaScalarFieldEnum]


  export const InventarioScalarFieldEnum: {
    idBodega: 'idBodega',
    idProducto: 'idProducto',
    idUsuarioRegistro: 'idUsuarioRegistro',
    idUsuarioActualizo: 'idUsuarioActualizo',
    cantidad: 'cantidad',
    cantidadMinima: 'cantidadMinima',
    cantidadMaxima: 'cantidadMaxima',
    fechaRegistro: 'fechaRegistro'
  };

  export type InventarioScalarFieldEnum = (typeof InventarioScalarFieldEnum)[keyof typeof InventarioScalarFieldEnum]


  export const ProveedorScalarFieldEnum: {
    id: 'id',
    identificacion: 'identificacion',
    nombreProveedor: 'nombreProveedor',
    idUbicacion: 'idUbicacion',
    correoElectronico: 'correoElectronico',
    telefono: 'telefono'
  };

  export type ProveedorScalarFieldEnum = (typeof ProveedorScalarFieldEnum)[keyof typeof ProveedorScalarFieldEnum]


  export const EncabezadoCompraScalarFieldEnum: {
    id: 'id',
    fechaCompra: 'fechaCompra',
    idProveedor: 'idProveedor',
    idUsuario: 'idUsuario'
  };

  export type EncabezadoCompraScalarFieldEnum = (typeof EncabezadoCompraScalarFieldEnum)[keyof typeof EncabezadoCompraScalarFieldEnum]


  export const DetalleCompraScalarFieldEnum: {
    id: 'id',
    idEncabezadoCompra: 'idEncabezadoCompra',
    idProducto: 'idProducto',
    idBodega: 'idBodega',
    cantidad: 'cantidad'
  };

  export type DetalleCompraScalarFieldEnum = (typeof DetalleCompraScalarFieldEnum)[keyof typeof DetalleCompraScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    idEncabezadoCompra: 'idEncabezadoCompra',
    idEstado: 'idEstado',
    observaciones: 'observaciones',
    fechaPedido: 'fechaPedido'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const TrasladoScalarFieldEnum: {
    id: 'id',
    idBodegaOrigen: 'idBodegaOrigen',
    idBodegaDestino: 'idBodegaDestino',
    idUsuario: 'idUsuario',
    idProducto: 'idProducto',
    cantidad: 'cantidad',
    idEstado: 'idEstado',
    fechaRegistro: 'fechaRegistro'
  };

  export type TrasladoScalarFieldEnum = (typeof TrasladoScalarFieldEnum)[keyof typeof TrasladoScalarFieldEnum]


  export const HistorialScalarFieldEnum: {
    id: 'id',
    idBodega: 'idBodega',
    idUsuarioRegistro: 'idUsuarioRegistro',
    idProducto: 'idProducto',
    justificacion: 'justificacion',
    fechaAjuste: 'fechaAjuste'
  };

  export type HistorialScalarFieldEnum = (typeof HistorialScalarFieldEnum)[keyof typeof HistorialScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    correo?: StringFilter<"Usuario"> | string
    contrasenna?: StringFilter<"Usuario"> | string
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    idBodega?: IntNullableFilter<"Usuario"> | number | null
    estado?: BoolFilter<"Usuario"> | boolean
    encabezadoCompras?: EncabezadoCompraListRelationFilter
    Traslado?: TrasladoListRelationFilter
    Historial?: HistorialListRelationFilter
    invUsuarioRegistro?: InventarioListRelationFilter
    invUsuarioActualizo?: InventarioListRelationFilter
    bodega?: XOR<BodegaNullableRelationFilter, BodegaWhereInput> | null
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idBodega?: SortOrderInput | SortOrder
    estado?: SortOrder
    encabezadoCompras?: EncabezadoCompraOrderByRelationAggregateInput
    Traslado?: TrasladoOrderByRelationAggregateInput
    Historial?: HistorialOrderByRelationAggregateInput
    invUsuarioRegistro?: InventarioOrderByRelationAggregateInput
    invUsuarioActualizo?: InventarioOrderByRelationAggregateInput
    bodega?: BodegaOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    correo?: StringFilter<"Usuario"> | string
    contrasenna?: StringFilter<"Usuario"> | string
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    idBodega?: IntNullableFilter<"Usuario"> | number | null
    estado?: BoolFilter<"Usuario"> | boolean
    encabezadoCompras?: EncabezadoCompraListRelationFilter
    Traslado?: TrasladoListRelationFilter
    Historial?: HistorialListRelationFilter
    invUsuarioRegistro?: InventarioListRelationFilter
    invUsuarioActualizo?: InventarioListRelationFilter
    bodega?: XOR<BodegaNullableRelationFilter, BodegaWhereInput> | null
  }, "id">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idBodega?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellidos?: StringWithAggregatesFilter<"Usuario"> | string
    correo?: StringWithAggregatesFilter<"Usuario"> | string
    contrasenna?: StringWithAggregatesFilter<"Usuario"> | string
    fechaRegistro?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    idBodega?: IntNullableWithAggregatesFilter<"Usuario"> | number | null
    estado?: BoolWithAggregatesFilter<"Usuario"> | boolean
  }

  export type EstadoWhereInput = {
    AND?: EstadoWhereInput | EstadoWhereInput[]
    OR?: EstadoWhereInput[]
    NOT?: EstadoWhereInput | EstadoWhereInput[]
    id?: IntFilter<"Estado"> | number
    estado?: StringFilter<"Estado"> | string
    pedidos?: PedidoListRelationFilter
    Traslado?: TrasladoListRelationFilter
  }

  export type EstadoOrderByWithRelationInput = {
    id?: SortOrder
    estado?: SortOrder
    pedidos?: PedidoOrderByRelationAggregateInput
    Traslado?: TrasladoOrderByRelationAggregateInput
  }

  export type EstadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EstadoWhereInput | EstadoWhereInput[]
    OR?: EstadoWhereInput[]
    NOT?: EstadoWhereInput | EstadoWhereInput[]
    estado?: StringFilter<"Estado"> | string
    pedidos?: PedidoListRelationFilter
    Traslado?: TrasladoListRelationFilter
  }, "id">

  export type EstadoOrderByWithAggregationInput = {
    id?: SortOrder
    estado?: SortOrder
    _count?: EstadoCountOrderByAggregateInput
    _avg?: EstadoAvgOrderByAggregateInput
    _max?: EstadoMaxOrderByAggregateInput
    _min?: EstadoMinOrderByAggregateInput
    _sum?: EstadoSumOrderByAggregateInput
  }

  export type EstadoScalarWhereWithAggregatesInput = {
    AND?: EstadoScalarWhereWithAggregatesInput | EstadoScalarWhereWithAggregatesInput[]
    OR?: EstadoScalarWhereWithAggregatesInput[]
    NOT?: EstadoScalarWhereWithAggregatesInput | EstadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Estado"> | number
    estado?: StringWithAggregatesFilter<"Estado"> | string
  }

  export type CategoriaWhereInput = {
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nombre?: StringFilter<"Categoria"> | string
    subCategoria?: SubCategoriaListRelationFilter
    producto?: ProductoListRelationFilter
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    subCategoria?: SubCategoriaOrderByRelationAggregateInput
    producto?: ProductoOrderByRelationAggregateInput
  }

  export type CategoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    nombre?: StringFilter<"Categoria"> | string
    subCategoria?: SubCategoriaListRelationFilter
    producto?: ProductoListRelationFilter
  }, "id">

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    OR?: CategoriaScalarWhereWithAggregatesInput[]
    NOT?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categoria"> | number
    nombre?: StringWithAggregatesFilter<"Categoria"> | string
  }

  export type SubCategoriaWhereInput = {
    AND?: SubCategoriaWhereInput | SubCategoriaWhereInput[]
    OR?: SubCategoriaWhereInput[]
    NOT?: SubCategoriaWhereInput | SubCategoriaWhereInput[]
    id?: IntFilter<"SubCategoria"> | number
    nombre?: StringFilter<"SubCategoria"> | string
    producto?: ProductoListRelationFilter
    categorias?: CategoriaListRelationFilter
  }

  export type SubCategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    producto?: ProductoOrderByRelationAggregateInput
    categorias?: CategoriaOrderByRelationAggregateInput
  }

  export type SubCategoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubCategoriaWhereInput | SubCategoriaWhereInput[]
    OR?: SubCategoriaWhereInput[]
    NOT?: SubCategoriaWhereInput | SubCategoriaWhereInput[]
    nombre?: StringFilter<"SubCategoria"> | string
    producto?: ProductoListRelationFilter
    categorias?: CategoriaListRelationFilter
  }, "id">

  export type SubCategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: SubCategoriaCountOrderByAggregateInput
    _avg?: SubCategoriaAvgOrderByAggregateInput
    _max?: SubCategoriaMaxOrderByAggregateInput
    _min?: SubCategoriaMinOrderByAggregateInput
    _sum?: SubCategoriaSumOrderByAggregateInput
  }

  export type SubCategoriaScalarWhereWithAggregatesInput = {
    AND?: SubCategoriaScalarWhereWithAggregatesInput | SubCategoriaScalarWhereWithAggregatesInput[]
    OR?: SubCategoriaScalarWhereWithAggregatesInput[]
    NOT?: SubCategoriaScalarWhereWithAggregatesInput | SubCategoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubCategoria"> | number
    nombre?: StringWithAggregatesFilter<"SubCategoria"> | string
  }

  export type ProductoWhereInput = {
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    id?: IntFilter<"Producto"> | number
    codigoProducto?: StringNullableFilter<"Producto"> | string | null
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    stock?: IntFilter<"Producto"> | number
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFilter<"Producto"> | boolean
    idCategoria?: IntFilter<"Producto"> | number
    idSubCategoria?: IntFilter<"Producto"> | number
    categoria?: XOR<CategoriaRelationFilter, CategoriaWhereInput>
    foto?: FotoListRelationFilter
    bodegaProductos?: InventarioListRelationFilter
    detalleCompras?: DetalleCompraListRelationFilter
    Historial?: HistorialListRelationFilter
    Traslado?: TrasladoListRelationFilter
    subCategorias?: XOR<SubCategoriaRelationFilter, SubCategoriaWhereInput>
  }

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder
    codigoProducto?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    estadoProducto?: SortOrder
    idCategoria?: SortOrder
    idSubCategoria?: SortOrder
    categoria?: CategoriaOrderByWithRelationInput
    foto?: FotoOrderByRelationAggregateInput
    bodegaProductos?: InventarioOrderByRelationAggregateInput
    detalleCompras?: DetalleCompraOrderByRelationAggregateInput
    Historial?: HistorialOrderByRelationAggregateInput
    Traslado?: TrasladoOrderByRelationAggregateInput
    subCategorias?: SubCategoriaOrderByWithRelationInput
  }

  export type ProductoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    codigoProducto?: StringNullableFilter<"Producto"> | string | null
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    stock?: IntFilter<"Producto"> | number
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFilter<"Producto"> | boolean
    idCategoria?: IntFilter<"Producto"> | number
    idSubCategoria?: IntFilter<"Producto"> | number
    categoria?: XOR<CategoriaRelationFilter, CategoriaWhereInput>
    foto?: FotoListRelationFilter
    bodegaProductos?: InventarioListRelationFilter
    detalleCompras?: DetalleCompraListRelationFilter
    Historial?: HistorialListRelationFilter
    Traslado?: TrasladoListRelationFilter
    subCategorias?: XOR<SubCategoriaRelationFilter, SubCategoriaWhereInput>
  }, "id">

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    codigoProducto?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    estadoProducto?: SortOrder
    idCategoria?: SortOrder
    idSubCategoria?: SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _avg?: ProductoAvgOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
    _sum?: ProductoSumOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    OR?: ProductoScalarWhereWithAggregatesInput[]
    NOT?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Producto"> | number
    codigoProducto?: StringNullableWithAggregatesFilter<"Producto"> | string | null
    nombre?: StringWithAggregatesFilter<"Producto"> | string
    descripcion?: StringWithAggregatesFilter<"Producto"> | string
    stock?: IntWithAggregatesFilter<"Producto"> | number
    precio?: DecimalWithAggregatesFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolWithAggregatesFilter<"Producto"> | boolean
    idCategoria?: IntWithAggregatesFilter<"Producto"> | number
    idSubCategoria?: IntWithAggregatesFilter<"Producto"> | number
  }

  export type FotoWhereInput = {
    AND?: FotoWhereInput | FotoWhereInput[]
    OR?: FotoWhereInput[]
    NOT?: FotoWhereInput | FotoWhereInput[]
    id?: IntFilter<"Foto"> | number
    idProducto?: IntFilter<"Foto"> | number
    foto?: BytesFilter<"Foto"> | Buffer
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
  }

  export type FotoOrderByWithRelationInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
    producto?: ProductoOrderByWithRelationInput
  }

  export type FotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FotoWhereInput | FotoWhereInput[]
    OR?: FotoWhereInput[]
    NOT?: FotoWhereInput | FotoWhereInput[]
    idProducto?: IntFilter<"Foto"> | number
    foto?: BytesFilter<"Foto"> | Buffer
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
  }, "id">

  export type FotoOrderByWithAggregationInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
    _count?: FotoCountOrderByAggregateInput
    _avg?: FotoAvgOrderByAggregateInput
    _max?: FotoMaxOrderByAggregateInput
    _min?: FotoMinOrderByAggregateInput
    _sum?: FotoSumOrderByAggregateInput
  }

  export type FotoScalarWhereWithAggregatesInput = {
    AND?: FotoScalarWhereWithAggregatesInput | FotoScalarWhereWithAggregatesInput[]
    OR?: FotoScalarWhereWithAggregatesInput[]
    NOT?: FotoScalarWhereWithAggregatesInput | FotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Foto"> | number
    idProducto?: IntWithAggregatesFilter<"Foto"> | number
    foto?: BytesWithAggregatesFilter<"Foto"> | Buffer
  }

  export type UbicacionWhereInput = {
    AND?: UbicacionWhereInput | UbicacionWhereInput[]
    OR?: UbicacionWhereInput[]
    NOT?: UbicacionWhereInput | UbicacionWhereInput[]
    id?: IntFilter<"Ubicacion"> | number
    idProvincia?: IntFilter<"Ubicacion"> | number
    idCanton?: IntFilter<"Ubicacion"> | number
    idDistrito?: IntFilter<"Ubicacion"> | number
    direccionExacta?: StringNullableFilter<"Ubicacion"> | string | null
    proveedor?: ProveedorListRelationFilter
    bodega?: BodegaListRelationFilter
  }

  export type UbicacionOrderByWithRelationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    direccionExacta?: SortOrderInput | SortOrder
    proveedor?: ProveedorOrderByRelationAggregateInput
    bodega?: BodegaOrderByRelationAggregateInput
  }

  export type UbicacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UbicacionWhereInput | UbicacionWhereInput[]
    OR?: UbicacionWhereInput[]
    NOT?: UbicacionWhereInput | UbicacionWhereInput[]
    idProvincia?: IntFilter<"Ubicacion"> | number
    idCanton?: IntFilter<"Ubicacion"> | number
    idDistrito?: IntFilter<"Ubicacion"> | number
    direccionExacta?: StringNullableFilter<"Ubicacion"> | string | null
    proveedor?: ProveedorListRelationFilter
    bodega?: BodegaListRelationFilter
  }, "id">

  export type UbicacionOrderByWithAggregationInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    direccionExacta?: SortOrderInput | SortOrder
    _count?: UbicacionCountOrderByAggregateInput
    _avg?: UbicacionAvgOrderByAggregateInput
    _max?: UbicacionMaxOrderByAggregateInput
    _min?: UbicacionMinOrderByAggregateInput
    _sum?: UbicacionSumOrderByAggregateInput
  }

  export type UbicacionScalarWhereWithAggregatesInput = {
    AND?: UbicacionScalarWhereWithAggregatesInput | UbicacionScalarWhereWithAggregatesInput[]
    OR?: UbicacionScalarWhereWithAggregatesInput[]
    NOT?: UbicacionScalarWhereWithAggregatesInput | UbicacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ubicacion"> | number
    idProvincia?: IntWithAggregatesFilter<"Ubicacion"> | number
    idCanton?: IntWithAggregatesFilter<"Ubicacion"> | number
    idDistrito?: IntWithAggregatesFilter<"Ubicacion"> | number
    direccionExacta?: StringNullableWithAggregatesFilter<"Ubicacion"> | string | null
  }

  export type BodegaWhereInput = {
    AND?: BodegaWhereInput | BodegaWhereInput[]
    OR?: BodegaWhereInput[]
    NOT?: BodegaWhereInput | BodegaWhereInput[]
    id?: IntFilter<"Bodega"> | number
    nombre?: StringFilter<"Bodega"> | string
    idUbicacion?: IntFilter<"Bodega"> | number
    tamanno?: FloatFilter<"Bodega"> | number
    capacidad?: FloatFilter<"Bodega"> | number
    seguridad?: BoolFilter<"Bodega"> | boolean
    usuario?: UsuarioListRelationFilter
    inventario?: InventarioListRelationFilter
    detalleCompra?: DetalleCompraListRelationFilter
    Historial?: HistorialListRelationFilter
    TrasladoOrigen?: TrasladoListRelationFilter
    TrasladoDestino?: TrasladoListRelationFilter
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
  }

  export type BodegaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
    usuario?: UsuarioOrderByRelationAggregateInput
    inventario?: InventarioOrderByRelationAggregateInput
    detalleCompra?: DetalleCompraOrderByRelationAggregateInput
    Historial?: HistorialOrderByRelationAggregateInput
    TrasladoOrigen?: TrasladoOrderByRelationAggregateInput
    TrasladoDestino?: TrasladoOrderByRelationAggregateInput
    ubicacion?: UbicacionOrderByWithRelationInput
  }

  export type BodegaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BodegaWhereInput | BodegaWhereInput[]
    OR?: BodegaWhereInput[]
    NOT?: BodegaWhereInput | BodegaWhereInput[]
    nombre?: StringFilter<"Bodega"> | string
    idUbicacion?: IntFilter<"Bodega"> | number
    tamanno?: FloatFilter<"Bodega"> | number
    capacidad?: FloatFilter<"Bodega"> | number
    seguridad?: BoolFilter<"Bodega"> | boolean
    usuario?: UsuarioListRelationFilter
    inventario?: InventarioListRelationFilter
    detalleCompra?: DetalleCompraListRelationFilter
    Historial?: HistorialListRelationFilter
    TrasladoOrigen?: TrasladoListRelationFilter
    TrasladoDestino?: TrasladoListRelationFilter
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
  }, "id">

  export type BodegaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
    _count?: BodegaCountOrderByAggregateInput
    _avg?: BodegaAvgOrderByAggregateInput
    _max?: BodegaMaxOrderByAggregateInput
    _min?: BodegaMinOrderByAggregateInput
    _sum?: BodegaSumOrderByAggregateInput
  }

  export type BodegaScalarWhereWithAggregatesInput = {
    AND?: BodegaScalarWhereWithAggregatesInput | BodegaScalarWhereWithAggregatesInput[]
    OR?: BodegaScalarWhereWithAggregatesInput[]
    NOT?: BodegaScalarWhereWithAggregatesInput | BodegaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bodega"> | number
    nombre?: StringWithAggregatesFilter<"Bodega"> | string
    idUbicacion?: IntWithAggregatesFilter<"Bodega"> | number
    tamanno?: FloatWithAggregatesFilter<"Bodega"> | number
    capacidad?: FloatWithAggregatesFilter<"Bodega"> | number
    seguridad?: BoolWithAggregatesFilter<"Bodega"> | boolean
  }

  export type InventarioWhereInput = {
    AND?: InventarioWhereInput | InventarioWhereInput[]
    OR?: InventarioWhereInput[]
    NOT?: InventarioWhereInput | InventarioWhereInput[]
    idBodega?: IntFilter<"Inventario"> | number
    idProducto?: IntFilter<"Inventario"> | number
    idUsuarioRegistro?: IntFilter<"Inventario"> | number
    idUsuarioActualizo?: IntFilter<"Inventario"> | number
    cantidad?: IntFilter<"Inventario"> | number
    cantidadMinima?: IntFilter<"Inventario"> | number
    cantidadMaxima?: IntFilter<"Inventario"> | number
    fechaRegistro?: DateTimeFilter<"Inventario"> | Date | string
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    usuarioRegistro?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    usuarioActualizo?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type InventarioOrderByWithRelationInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuarioRegistro?: SortOrder
    idUsuarioActualizo?: SortOrder
    cantidad?: SortOrder
    cantidadMinima?: SortOrder
    cantidadMaxima?: SortOrder
    fechaRegistro?: SortOrder
    bodegas?: BodegaOrderByWithRelationInput
    producto?: ProductoOrderByWithRelationInput
    usuarioRegistro?: UsuarioOrderByWithRelationInput
    usuarioActualizo?: UsuarioOrderByWithRelationInput
  }

  export type InventarioWhereUniqueInput = Prisma.AtLeast<{
    idBodega_idProducto?: InventarioIdBodegaIdProductoCompoundUniqueInput
    AND?: InventarioWhereInput | InventarioWhereInput[]
    OR?: InventarioWhereInput[]
    NOT?: InventarioWhereInput | InventarioWhereInput[]
    idBodega?: IntFilter<"Inventario"> | number
    idProducto?: IntFilter<"Inventario"> | number
    idUsuarioRegistro?: IntFilter<"Inventario"> | number
    idUsuarioActualizo?: IntFilter<"Inventario"> | number
    cantidad?: IntFilter<"Inventario"> | number
    cantidadMinima?: IntFilter<"Inventario"> | number
    cantidadMaxima?: IntFilter<"Inventario"> | number
    fechaRegistro?: DateTimeFilter<"Inventario"> | Date | string
    bodegas?: XOR<BodegaRelationFilter, BodegaWhereInput>
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    usuarioRegistro?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    usuarioActualizo?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "idBodega_idProducto">

  export type InventarioOrderByWithAggregationInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuarioRegistro?: SortOrder
    idUsuarioActualizo?: SortOrder
    cantidad?: SortOrder
    cantidadMinima?: SortOrder
    cantidadMaxima?: SortOrder
    fechaRegistro?: SortOrder
    _count?: InventarioCountOrderByAggregateInput
    _avg?: InventarioAvgOrderByAggregateInput
    _max?: InventarioMaxOrderByAggregateInput
    _min?: InventarioMinOrderByAggregateInput
    _sum?: InventarioSumOrderByAggregateInput
  }

  export type InventarioScalarWhereWithAggregatesInput = {
    AND?: InventarioScalarWhereWithAggregatesInput | InventarioScalarWhereWithAggregatesInput[]
    OR?: InventarioScalarWhereWithAggregatesInput[]
    NOT?: InventarioScalarWhereWithAggregatesInput | InventarioScalarWhereWithAggregatesInput[]
    idBodega?: IntWithAggregatesFilter<"Inventario"> | number
    idProducto?: IntWithAggregatesFilter<"Inventario"> | number
    idUsuarioRegistro?: IntWithAggregatesFilter<"Inventario"> | number
    idUsuarioActualizo?: IntWithAggregatesFilter<"Inventario"> | number
    cantidad?: IntWithAggregatesFilter<"Inventario"> | number
    cantidadMinima?: IntWithAggregatesFilter<"Inventario"> | number
    cantidadMaxima?: IntWithAggregatesFilter<"Inventario"> | number
    fechaRegistro?: DateTimeWithAggregatesFilter<"Inventario"> | Date | string
  }

  export type ProveedorWhereInput = {
    AND?: ProveedorWhereInput | ProveedorWhereInput[]
    OR?: ProveedorWhereInput[]
    NOT?: ProveedorWhereInput | ProveedorWhereInput[]
    id?: IntFilter<"Proveedor"> | number
    identificacion?: IntFilter<"Proveedor"> | number
    nombreProveedor?: StringFilter<"Proveedor"> | string
    idUbicacion?: IntFilter<"Proveedor"> | number
    correoElectronico?: StringFilter<"Proveedor"> | string
    telefono?: IntFilter<"Proveedor"> | number
    encabezadoCompra?: EncabezadoCompraListRelationFilter
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
  }

  export type ProveedorOrderByWithRelationInput = {
    id?: SortOrder
    identificacion?: SortOrder
    nombreProveedor?: SortOrder
    idUbicacion?: SortOrder
    correoElectronico?: SortOrder
    telefono?: SortOrder
    encabezadoCompra?: EncabezadoCompraOrderByRelationAggregateInput
    ubicacion?: UbicacionOrderByWithRelationInput
  }

  export type ProveedorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    correoElectronico?: string
    AND?: ProveedorWhereInput | ProveedorWhereInput[]
    OR?: ProveedorWhereInput[]
    NOT?: ProveedorWhereInput | ProveedorWhereInput[]
    identificacion?: IntFilter<"Proveedor"> | number
    nombreProveedor?: StringFilter<"Proveedor"> | string
    idUbicacion?: IntFilter<"Proveedor"> | number
    telefono?: IntFilter<"Proveedor"> | number
    encabezadoCompra?: EncabezadoCompraListRelationFilter
    ubicacion?: XOR<UbicacionRelationFilter, UbicacionWhereInput>
  }, "id" | "correoElectronico">

  export type ProveedorOrderByWithAggregationInput = {
    id?: SortOrder
    identificacion?: SortOrder
    nombreProveedor?: SortOrder
    idUbicacion?: SortOrder
    correoElectronico?: SortOrder
    telefono?: SortOrder
    _count?: ProveedorCountOrderByAggregateInput
    _avg?: ProveedorAvgOrderByAggregateInput
    _max?: ProveedorMaxOrderByAggregateInput
    _min?: ProveedorMinOrderByAggregateInput
    _sum?: ProveedorSumOrderByAggregateInput
  }

  export type ProveedorScalarWhereWithAggregatesInput = {
    AND?: ProveedorScalarWhereWithAggregatesInput | ProveedorScalarWhereWithAggregatesInput[]
    OR?: ProveedorScalarWhereWithAggregatesInput[]
    NOT?: ProveedorScalarWhereWithAggregatesInput | ProveedorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Proveedor"> | number
    identificacion?: IntWithAggregatesFilter<"Proveedor"> | number
    nombreProveedor?: StringWithAggregatesFilter<"Proveedor"> | string
    idUbicacion?: IntWithAggregatesFilter<"Proveedor"> | number
    correoElectronico?: StringWithAggregatesFilter<"Proveedor"> | string
    telefono?: IntWithAggregatesFilter<"Proveedor"> | number
  }

  export type EncabezadoCompraWhereInput = {
    AND?: EncabezadoCompraWhereInput | EncabezadoCompraWhereInput[]
    OR?: EncabezadoCompraWhereInput[]
    NOT?: EncabezadoCompraWhereInput | EncabezadoCompraWhereInput[]
    id?: IntFilter<"EncabezadoCompra"> | number
    fechaCompra?: DateTimeFilter<"EncabezadoCompra"> | Date | string
    idProveedor?: IntFilter<"EncabezadoCompra"> | number
    idUsuario?: IntFilter<"EncabezadoCompra"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    proveedor?: XOR<ProveedorRelationFilter, ProveedorWhereInput>
    detalleCompra?: DetalleCompraListRelationFilter
    pedido?: PedidoListRelationFilter
  }

  export type EncabezadoCompraOrderByWithRelationInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idProveedor?: SortOrder
    idUsuario?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    proveedor?: ProveedorOrderByWithRelationInput
    detalleCompra?: DetalleCompraOrderByRelationAggregateInput
    pedido?: PedidoOrderByRelationAggregateInput
  }

  export type EncabezadoCompraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncabezadoCompraWhereInput | EncabezadoCompraWhereInput[]
    OR?: EncabezadoCompraWhereInput[]
    NOT?: EncabezadoCompraWhereInput | EncabezadoCompraWhereInput[]
    fechaCompra?: DateTimeFilter<"EncabezadoCompra"> | Date | string
    idProveedor?: IntFilter<"EncabezadoCompra"> | number
    idUsuario?: IntFilter<"EncabezadoCompra"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    proveedor?: XOR<ProveedorRelationFilter, ProveedorWhereInput>
    detalleCompra?: DetalleCompraListRelationFilter
    pedido?: PedidoListRelationFilter
  }, "id">

  export type EncabezadoCompraOrderByWithAggregationInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idProveedor?: SortOrder
    idUsuario?: SortOrder
    _count?: EncabezadoCompraCountOrderByAggregateInput
    _avg?: EncabezadoCompraAvgOrderByAggregateInput
    _max?: EncabezadoCompraMaxOrderByAggregateInput
    _min?: EncabezadoCompraMinOrderByAggregateInput
    _sum?: EncabezadoCompraSumOrderByAggregateInput
  }

  export type EncabezadoCompraScalarWhereWithAggregatesInput = {
    AND?: EncabezadoCompraScalarWhereWithAggregatesInput | EncabezadoCompraScalarWhereWithAggregatesInput[]
    OR?: EncabezadoCompraScalarWhereWithAggregatesInput[]
    NOT?: EncabezadoCompraScalarWhereWithAggregatesInput | EncabezadoCompraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncabezadoCompra"> | number
    fechaCompra?: DateTimeWithAggregatesFilter<"EncabezadoCompra"> | Date | string
    idProveedor?: IntWithAggregatesFilter<"EncabezadoCompra"> | number
    idUsuario?: IntWithAggregatesFilter<"EncabezadoCompra"> | number
  }

  export type DetalleCompraWhereInput = {
    AND?: DetalleCompraWhereInput | DetalleCompraWhereInput[]
    OR?: DetalleCompraWhereInput[]
    NOT?: DetalleCompraWhereInput | DetalleCompraWhereInput[]
    id?: IntFilter<"DetalleCompra"> | number
    idEncabezadoCompra?: IntFilter<"DetalleCompra"> | number
    idProducto?: IntFilter<"DetalleCompra"> | number
    idBodega?: IntFilter<"DetalleCompra"> | number
    cantidad?: IntFilter<"DetalleCompra"> | number
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    encabezadoCompra?: XOR<EncabezadoCompraRelationFilter, EncabezadoCompraWhereInput>
    bodega?: XOR<BodegaRelationFilter, BodegaWhereInput>
  }

  export type DetalleCompraOrderByWithRelationInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
    producto?: ProductoOrderByWithRelationInput
    encabezadoCompra?: EncabezadoCompraOrderByWithRelationInput
    bodega?: BodegaOrderByWithRelationInput
  }

  export type DetalleCompraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DetalleCompraWhereInput | DetalleCompraWhereInput[]
    OR?: DetalleCompraWhereInput[]
    NOT?: DetalleCompraWhereInput | DetalleCompraWhereInput[]
    idEncabezadoCompra?: IntFilter<"DetalleCompra"> | number
    idProducto?: IntFilter<"DetalleCompra"> | number
    idBodega?: IntFilter<"DetalleCompra"> | number
    cantidad?: IntFilter<"DetalleCompra"> | number
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    encabezadoCompra?: XOR<EncabezadoCompraRelationFilter, EncabezadoCompraWhereInput>
    bodega?: XOR<BodegaRelationFilter, BodegaWhereInput>
  }, "id">

  export type DetalleCompraOrderByWithAggregationInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
    _count?: DetalleCompraCountOrderByAggregateInput
    _avg?: DetalleCompraAvgOrderByAggregateInput
    _max?: DetalleCompraMaxOrderByAggregateInput
    _min?: DetalleCompraMinOrderByAggregateInput
    _sum?: DetalleCompraSumOrderByAggregateInput
  }

  export type DetalleCompraScalarWhereWithAggregatesInput = {
    AND?: DetalleCompraScalarWhereWithAggregatesInput | DetalleCompraScalarWhereWithAggregatesInput[]
    OR?: DetalleCompraScalarWhereWithAggregatesInput[]
    NOT?: DetalleCompraScalarWhereWithAggregatesInput | DetalleCompraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DetalleCompra"> | number
    idEncabezadoCompra?: IntWithAggregatesFilter<"DetalleCompra"> | number
    idProducto?: IntWithAggregatesFilter<"DetalleCompra"> | number
    idBodega?: IntWithAggregatesFilter<"DetalleCompra"> | number
    cantidad?: IntWithAggregatesFilter<"DetalleCompra"> | number
  }

  export type PedidoWhereInput = {
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    idEncabezadoCompra?: IntFilter<"Pedido"> | number
    idEstado?: IntFilter<"Pedido"> | number
    observaciones?: StringNullableFilter<"Pedido"> | string | null
    fechaPedido?: DateTimeFilter<"Pedido"> | Date | string
    estadoPedido?: XOR<EstadoRelationFilter, EstadoWhereInput>
    encabezadoCompra?: XOR<EncabezadoCompraRelationFilter, EncabezadoCompraWhereInput>
  }

  export type PedidoOrderByWithRelationInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    fechaPedido?: SortOrder
    estadoPedido?: EstadoOrderByWithRelationInput
    encabezadoCompra?: EncabezadoCompraOrderByWithRelationInput
  }

  export type PedidoWhereUniqueInput = Prisma.AtLeast<{
    idEncabezadoCompra?: number
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    idEstado?: IntFilter<"Pedido"> | number
    observaciones?: StringNullableFilter<"Pedido"> | string | null
    fechaPedido?: DateTimeFilter<"Pedido"> | Date | string
    estadoPedido?: XOR<EstadoRelationFilter, EstadoWhereInput>
    encabezadoCompra?: XOR<EncabezadoCompraRelationFilter, EncabezadoCompraWhereInput>
  }, "idEncabezadoCompra">

  export type PedidoOrderByWithAggregationInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    fechaPedido?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    OR?: PedidoScalarWhereWithAggregatesInput[]
    NOT?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    idEncabezadoCompra?: IntWithAggregatesFilter<"Pedido"> | number
    idEstado?: IntWithAggregatesFilter<"Pedido"> | number
    observaciones?: StringNullableWithAggregatesFilter<"Pedido"> | string | null
    fechaPedido?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
  }

  export type TrasladoWhereInput = {
    AND?: TrasladoWhereInput | TrasladoWhereInput[]
    OR?: TrasladoWhereInput[]
    NOT?: TrasladoWhereInput | TrasladoWhereInput[]
    id?: IntFilter<"Traslado"> | number
    idBodegaOrigen?: IntFilter<"Traslado"> | number
    idBodegaDestino?: IntFilter<"Traslado"> | number
    idUsuario?: IntNullableFilter<"Traslado"> | number | null
    idProducto?: IntFilter<"Traslado"> | number
    cantidad?: IntFilter<"Traslado"> | number
    idEstado?: IntFilter<"Traslado"> | number
    fechaRegistro?: DateTimeFilter<"Traslado"> | Date | string
    bodegaOrigen?: XOR<BodegaRelationFilter, BodegaWhereInput>
    bodegaDestino?: XOR<BodegaRelationFilter, BodegaWhereInput>
    estadoDestino?: XOR<EstadoRelationFilter, EstadoWhereInput>
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
  }

  export type TrasladoOrderByWithRelationInput = {
    id?: SortOrder
    idBodegaOrigen?: SortOrder
    idBodegaDestino?: SortOrder
    idUsuario?: SortOrderInput | SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    idEstado?: SortOrder
    fechaRegistro?: SortOrder
    bodegaOrigen?: BodegaOrderByWithRelationInput
    bodegaDestino?: BodegaOrderByWithRelationInput
    estadoDestino?: EstadoOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
    producto?: ProductoOrderByWithRelationInput
  }

  export type TrasladoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TrasladoWhereInput | TrasladoWhereInput[]
    OR?: TrasladoWhereInput[]
    NOT?: TrasladoWhereInput | TrasladoWhereInput[]
    idBodegaOrigen?: IntFilter<"Traslado"> | number
    idBodegaDestino?: IntFilter<"Traslado"> | number
    idUsuario?: IntNullableFilter<"Traslado"> | number | null
    idProducto?: IntFilter<"Traslado"> | number
    cantidad?: IntFilter<"Traslado"> | number
    idEstado?: IntFilter<"Traslado"> | number
    fechaRegistro?: DateTimeFilter<"Traslado"> | Date | string
    bodegaOrigen?: XOR<BodegaRelationFilter, BodegaWhereInput>
    bodegaDestino?: XOR<BodegaRelationFilter, BodegaWhereInput>
    estadoDestino?: XOR<EstadoRelationFilter, EstadoWhereInput>
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
  }, "id">

  export type TrasladoOrderByWithAggregationInput = {
    id?: SortOrder
    idBodegaOrigen?: SortOrder
    idBodegaDestino?: SortOrder
    idUsuario?: SortOrderInput | SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    idEstado?: SortOrder
    fechaRegistro?: SortOrder
    _count?: TrasladoCountOrderByAggregateInput
    _avg?: TrasladoAvgOrderByAggregateInput
    _max?: TrasladoMaxOrderByAggregateInput
    _min?: TrasladoMinOrderByAggregateInput
    _sum?: TrasladoSumOrderByAggregateInput
  }

  export type TrasladoScalarWhereWithAggregatesInput = {
    AND?: TrasladoScalarWhereWithAggregatesInput | TrasladoScalarWhereWithAggregatesInput[]
    OR?: TrasladoScalarWhereWithAggregatesInput[]
    NOT?: TrasladoScalarWhereWithAggregatesInput | TrasladoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Traslado"> | number
    idBodegaOrigen?: IntWithAggregatesFilter<"Traslado"> | number
    idBodegaDestino?: IntWithAggregatesFilter<"Traslado"> | number
    idUsuario?: IntNullableWithAggregatesFilter<"Traslado"> | number | null
    idProducto?: IntWithAggregatesFilter<"Traslado"> | number
    cantidad?: IntWithAggregatesFilter<"Traslado"> | number
    idEstado?: IntWithAggregatesFilter<"Traslado"> | number
    fechaRegistro?: DateTimeWithAggregatesFilter<"Traslado"> | Date | string
  }

  export type HistorialWhereInput = {
    AND?: HistorialWhereInput | HistorialWhereInput[]
    OR?: HistorialWhereInput[]
    NOT?: HistorialWhereInput | HistorialWhereInput[]
    id?: IntFilter<"Historial"> | number
    idBodega?: IntFilter<"Historial"> | number
    idUsuarioRegistro?: IntFilter<"Historial"> | number
    idProducto?: IntFilter<"Historial"> | number
    justificacion?: StringFilter<"Historial"> | string
    fechaAjuste?: DateTimeFilter<"Historial"> | Date | string
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    bodega?: XOR<BodegaRelationFilter, BodegaWhereInput>
    usuarioRegistro?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type HistorialOrderByWithRelationInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    justificacion?: SortOrder
    fechaAjuste?: SortOrder
    producto?: ProductoOrderByWithRelationInput
    bodega?: BodegaOrderByWithRelationInput
    usuarioRegistro?: UsuarioOrderByWithRelationInput
  }

  export type HistorialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistorialWhereInput | HistorialWhereInput[]
    OR?: HistorialWhereInput[]
    NOT?: HistorialWhereInput | HistorialWhereInput[]
    idBodega?: IntFilter<"Historial"> | number
    idUsuarioRegistro?: IntFilter<"Historial"> | number
    idProducto?: IntFilter<"Historial"> | number
    justificacion?: StringFilter<"Historial"> | string
    fechaAjuste?: DateTimeFilter<"Historial"> | Date | string
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    bodega?: XOR<BodegaRelationFilter, BodegaWhereInput>
    usuarioRegistro?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type HistorialOrderByWithAggregationInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    justificacion?: SortOrder
    fechaAjuste?: SortOrder
    _count?: HistorialCountOrderByAggregateInput
    _avg?: HistorialAvgOrderByAggregateInput
    _max?: HistorialMaxOrderByAggregateInput
    _min?: HistorialMinOrderByAggregateInput
    _sum?: HistorialSumOrderByAggregateInput
  }

  export type HistorialScalarWhereWithAggregatesInput = {
    AND?: HistorialScalarWhereWithAggregatesInput | HistorialScalarWhereWithAggregatesInput[]
    OR?: HistorialScalarWhereWithAggregatesInput[]
    NOT?: HistorialScalarWhereWithAggregatesInput | HistorialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Historial"> | number
    idBodega?: IntWithAggregatesFilter<"Historial"> | number
    idUsuarioRegistro?: IntWithAggregatesFilter<"Historial"> | number
    idProducto?: IntWithAggregatesFilter<"Historial"> | number
    justificacion?: StringWithAggregatesFilter<"Historial"> | string
    fechaAjuste?: DateTimeWithAggregatesFilter<"Historial"> | Date | string
  }

  export type UsuarioCreateInput = {
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioCreateNestedManyWithoutUsuarioActualizoInput
    bodega?: BodegaCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    idBodega?: number | null
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioUncheckedCreateNestedManyWithoutUsuarioActualizoInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUpdateManyWithoutUsuarioActualizoNestedInput
    bodega?: BodegaUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idBodega?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUncheckedUpdateManyWithoutUsuarioActualizoNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    idBodega?: number | null
    estado?: boolean
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idBodega?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstadoCreateInput = {
    estado: string
    pedidos?: PedidoCreateNestedManyWithoutEstadoPedidoInput
    Traslado?: TrasladoCreateNestedManyWithoutEstadoDestinoInput
  }

  export type EstadoUncheckedCreateInput = {
    id?: number
    estado: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutEstadoPedidoInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutEstadoDestinoInput
  }

  export type EstadoUpdateInput = {
    estado?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutEstadoPedidoNestedInput
    Traslado?: TrasladoUpdateManyWithoutEstadoDestinoNestedInput
  }

  export type EstadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutEstadoPedidoNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutEstadoDestinoNestedInput
  }

  export type EstadoCreateManyInput = {
    id?: number
    estado: string
  }

  export type EstadoUpdateManyMutationInput = {
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaCreateInput = {
    nombre: string
    subCategoria?: SubCategoriaCreateNestedManyWithoutCategoriasInput
    producto?: ProductoCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    subCategoria?: SubCategoriaUncheckedCreateNestedManyWithoutCategoriasInput
    producto?: ProductoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    subCategoria?: SubCategoriaUpdateManyWithoutCategoriasNestedInput
    producto?: ProductoUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    subCategoria?: SubCategoriaUncheckedUpdateManyWithoutCategoriasNestedInput
    producto?: ProductoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type CategoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoriaCreateInput = {
    nombre: string
    producto?: ProductoCreateNestedManyWithoutSubCategoriasInput
    categorias?: CategoriaCreateNestedManyWithoutSubCategoriaInput
  }

  export type SubCategoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    producto?: ProductoUncheckedCreateNestedManyWithoutSubCategoriasInput
    categorias?: CategoriaUncheckedCreateNestedManyWithoutSubCategoriaInput
  }

  export type SubCategoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUpdateManyWithoutSubCategoriasNestedInput
    categorias?: CategoriaUpdateManyWithoutSubCategoriaNestedInput
  }

  export type SubCategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUncheckedUpdateManyWithoutSubCategoriasNestedInput
    categorias?: CategoriaUncheckedUpdateManyWithoutSubCategoriaNestedInput
  }

  export type SubCategoriaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type SubCategoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoCreateInput = {
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    categoria: CategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductoInput
    Historial?: HistorialCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoCreateNestedManyWithoutProductoInput
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
  }

  export type ProductoUncheckedCreateInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
    idSubCategoria: number
    foto?: FotoUncheckedCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductoInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoUpdateInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUpdateManyWithoutProductoNestedInput
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    foto?: FotoUncheckedUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoCreateManyInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
    idSubCategoria: number
  }

  export type ProductoUpdateManyMutationInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    idSubCategoria?: IntFieldUpdateOperationsInput | number
  }

  export type FotoCreateInput = {
    foto: Buffer
    producto: ProductoCreateNestedOneWithoutFotoInput
  }

  export type FotoUncheckedCreateInput = {
    id?: number
    idProducto: number
    foto: Buffer
  }

  export type FotoUpdateInput = {
    foto?: BytesFieldUpdateOperationsInput | Buffer
    producto?: ProductoUpdateOneRequiredWithoutFotoNestedInput
  }

  export type FotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type FotoCreateManyInput = {
    id?: number
    idProducto: number
    foto: Buffer
  }

  export type FotoUpdateManyMutationInput = {
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type FotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type UbicacionCreateInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta?: string | null
    proveedor?: ProveedorCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta?: string | null
    proveedor?: ProveedorUncheckedCreateNestedManyWithoutUbicacionInput
    bodega?: BodegaUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUpdateInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    direccionExacta?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: ProveedorUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    direccionExacta?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: ProveedorUncheckedUpdateManyWithoutUbicacionNestedInput
    bodega?: BodegaUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionCreateManyInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta?: string | null
  }

  export type UbicacionUpdateManyMutationInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    direccionExacta?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UbicacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    direccionExacta?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BodegaCreateInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioCreateNestedManyWithoutBodegaInput
    inventario?: InventarioCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutBodegaInput
    Historial?: HistorialCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoCreateNestedManyWithoutBodegaDestinoInput
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
  }

  export type BodegaUncheckedCreateInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioUncheckedCreateNestedManyWithoutBodegaInput
    inventario?: InventarioUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutBodegaInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoUncheckedCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoUncheckedCreateNestedManyWithoutBodegaDestinoInput
  }

  export type BodegaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUpdateManyWithoutBodegaDestinoNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
  }

  export type BodegaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUncheckedUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUncheckedUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUncheckedUpdateManyWithoutBodegaDestinoNestedInput
  }

  export type BodegaCreateManyInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
  }

  export type BodegaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BodegaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventarioCreateInput = {
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
    bodegas: BodegaCreateNestedOneWithoutInventarioInput
    producto: ProductoCreateNestedOneWithoutBodegaProductosInput
    usuarioRegistro: UsuarioCreateNestedOneWithoutInvUsuarioRegistroInput
    usuarioActualizo: UsuarioCreateNestedOneWithoutInvUsuarioActualizoInput
  }

  export type InventarioUncheckedCreateInput = {
    idBodega: number
    idProducto: number
    idUsuarioRegistro: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type InventarioUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegas?: BodegaUpdateOneRequiredWithoutInventarioNestedInput
    producto?: ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput
    usuarioRegistro?: UsuarioUpdateOneRequiredWithoutInvUsuarioRegistroNestedInput
    usuarioActualizo?: UsuarioUpdateOneRequiredWithoutInvUsuarioActualizoNestedInput
  }

  export type InventarioUncheckedUpdateInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idUsuarioActualizo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioCreateManyInput = {
    idBodega: number
    idProducto: number
    idUsuarioRegistro: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type InventarioUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUncheckedUpdateManyInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idUsuarioActualizo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProveedorCreateInput = {
    identificacion: number
    nombreProveedor: string
    correoElectronico: string
    telefono: number
    encabezadoCompra?: EncabezadoCompraCreateNestedManyWithoutProveedorInput
    ubicacion: UbicacionCreateNestedOneWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateInput = {
    id?: number
    identificacion: number
    nombreProveedor: string
    idUbicacion: number
    correoElectronico: string
    telefono: number
    encabezadoCompra?: EncabezadoCompraUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUpdateInput = {
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    encabezadoCompra?: EncabezadoCompraUpdateManyWithoutProveedorNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    encabezadoCompra?: EncabezadoCompraUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorCreateManyInput = {
    id?: number
    identificacion: number
    nombreProveedor: string
    idUbicacion: number
    correoElectronico: string
    telefono: number
  }

  export type ProveedorUpdateManyMutationInput = {
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
  }

  export type ProveedorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
  }

  export type EncabezadoCompraCreateInput = {
    fechaCompra?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEncabezadoComprasInput
    proveedor: ProveedorCreateNestedOneWithoutEncabezadoCompraInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutEncabezadoCompraInput
    pedido?: PedidoCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraUncheckedCreateInput = {
    id?: number
    fechaCompra?: Date | string
    idProveedor: number
    idUsuario: number
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoCompraInput
    pedido?: PedidoUncheckedCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraUpdateInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput
    proveedor?: ProveedorUpdateOneRequiredWithoutEncabezadoCompraNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutEncabezadoCompraNestedInput
    pedido?: PedidoUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idProveedor?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutEncabezadoCompraNestedInput
    pedido?: PedidoUncheckedUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type EncabezadoCompraCreateManyInput = {
    id?: number
    fechaCompra?: Date | string
    idProveedor: number
    idUsuario: number
  }

  export type EncabezadoCompraUpdateManyMutationInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncabezadoCompraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idProveedor?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraCreateInput = {
    cantidad: number
    producto: ProductoCreateNestedOneWithoutDetalleComprasInput
    encabezadoCompra: EncabezadoCompraCreateNestedOneWithoutDetalleCompraInput
    bodega: BodegaCreateNestedOneWithoutDetalleCompraInput
  }

  export type DetalleCompraUncheckedCreateInput = {
    id?: number
    idEncabezadoCompra: number
    idProducto: number
    idBodega: number
    cantidad: number
  }

  export type DetalleCompraUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutDetalleComprasNestedInput
    encabezadoCompra?: EncabezadoCompraUpdateOneRequiredWithoutDetalleCompraNestedInput
    bodega?: BodegaUpdateOneRequiredWithoutDetalleCompraNestedInput
  }

  export type DetalleCompraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraCreateManyInput = {
    id?: number
    idEncabezadoCompra: number
    idProducto: number
    idBodega: number
    cantidad: number
  }

  export type DetalleCompraUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoCreateInput = {
    observaciones?: string | null
    fechaPedido?: Date | string
    estadoPedido: EstadoCreateNestedOneWithoutPedidosInput
    encabezadoCompra: EncabezadoCompraCreateNestedOneWithoutPedidoInput
  }

  export type PedidoUncheckedCreateInput = {
    idEncabezadoCompra: number
    idEstado: number
    observaciones?: string | null
    fechaPedido?: Date | string
  }

  export type PedidoUpdateInput = {
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoPedido?: EstadoUpdateOneRequiredWithoutPedidosNestedInput
    encabezadoCompra?: EncabezadoCompraUpdateOneRequiredWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateManyInput = {
    idEncabezadoCompra: number
    idEstado: number
    observaciones?: string | null
    fechaPedido?: Date | string
  }

  export type PedidoUpdateManyMutationInput = {
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoCreateInput = {
    cantidad: number
    fechaRegistro?: Date | string
    bodegaOrigen: BodegaCreateNestedOneWithoutTrasladoOrigenInput
    bodegaDestino: BodegaCreateNestedOneWithoutTrasladoDestinoInput
    estadoDestino: EstadoCreateNestedOneWithoutTrasladoInput
    usuario?: UsuarioCreateNestedOneWithoutTrasladoInput
    producto: ProductoCreateNestedOneWithoutTrasladoInput
  }

  export type TrasladoUncheckedCreateInput = {
    id?: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idUsuario?: number | null
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type TrasladoUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegaOrigen?: BodegaUpdateOneRequiredWithoutTrasladoOrigenNestedInput
    bodegaDestino?: BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    estadoDestino?: EstadoUpdateOneRequiredWithoutTrasladoNestedInput
    usuario?: UsuarioUpdateOneWithoutTrasladoNestedInput
    producto?: ProductoUpdateOneRequiredWithoutTrasladoNestedInput
  }

  export type TrasladoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoCreateManyInput = {
    id?: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idUsuario?: number | null
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type TrasladoUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialCreateInput = {
    justificacion: string
    fechaAjuste?: Date | string
    producto: ProductoCreateNestedOneWithoutHistorialInput
    bodega: BodegaCreateNestedOneWithoutHistorialInput
    usuarioRegistro: UsuarioCreateNestedOneWithoutHistorialInput
  }

  export type HistorialUncheckedCreateInput = {
    id?: number
    idBodega: number
    idUsuarioRegistro: number
    idProducto: number
    justificacion: string
    fechaAjuste?: Date | string
  }

  export type HistorialUpdateInput = {
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: ProductoUpdateOneRequiredWithoutHistorialNestedInput
    bodega?: BodegaUpdateOneRequiredWithoutHistorialNestedInput
    usuarioRegistro?: UsuarioUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialCreateManyInput = {
    id?: number
    idBodega: number
    idUsuarioRegistro: number
    idProducto: number
    justificacion: string
    fechaAjuste?: Date | string
  }

  export type HistorialUpdateManyMutationInput = {
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EncabezadoCompraListRelationFilter = {
    every?: EncabezadoCompraWhereInput
    some?: EncabezadoCompraWhereInput
    none?: EncabezadoCompraWhereInput
  }

  export type TrasladoListRelationFilter = {
    every?: TrasladoWhereInput
    some?: TrasladoWhereInput
    none?: TrasladoWhereInput
  }

  export type HistorialListRelationFilter = {
    every?: HistorialWhereInput
    some?: HistorialWhereInput
    none?: HistorialWhereInput
  }

  export type InventarioListRelationFilter = {
    every?: InventarioWhereInput
    some?: InventarioWhereInput
    none?: InventarioWhereInput
  }

  export type BodegaNullableRelationFilter = {
    is?: BodegaWhereInput | null
    isNot?: BodegaWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EncabezadoCompraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrasladoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HistorialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idBodega?: SortOrder
    estado?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idBodega?: SortOrder
    estado?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    correo?: SortOrder
    contrasenna?: SortOrder
    fechaRegistro?: SortOrder
    rol?: SortOrder
    idBodega?: SortOrder
    estado?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstadoCountOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
  }

  export type EstadoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EstadoMaxOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
  }

  export type EstadoMinOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
  }

  export type EstadoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubCategoriaListRelationFilter = {
    every?: SubCategoriaWhereInput
    some?: SubCategoriaWhereInput
    none?: SubCategoriaWhereInput
  }

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput
    some?: ProductoWhereInput
    none?: ProductoWhereInput
  }

  export type SubCategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaListRelationFilter = {
    every?: CategoriaWhereInput
    some?: CategoriaWhereInput
    none?: CategoriaWhereInput
  }

  export type CategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubCategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SubCategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubCategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SubCategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type SubCategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CategoriaRelationFilter = {
    is?: CategoriaWhereInput
    isNot?: CategoriaWhereInput
  }

  export type FotoListRelationFilter = {
    every?: FotoWhereInput
    some?: FotoWhereInput
    none?: FotoWhereInput
  }

  export type DetalleCompraListRelationFilter = {
    every?: DetalleCompraWhereInput
    some?: DetalleCompraWhereInput
    none?: DetalleCompraWhereInput
  }

  export type SubCategoriaRelationFilter = {
    is?: SubCategoriaWhereInput
    isNot?: SubCategoriaWhereInput
  }

  export type FotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DetalleCompraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    codigoProducto?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    estadoProducto?: SortOrder
    idCategoria?: SortOrder
    idSubCategoria?: SortOrder
  }

  export type ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    idCategoria?: SortOrder
    idSubCategoria?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigoProducto?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    estadoProducto?: SortOrder
    idCategoria?: SortOrder
    idSubCategoria?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    codigoProducto?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    estadoProducto?: SortOrder
    idCategoria?: SortOrder
    idSubCategoria?: SortOrder
  }

  export type ProductoSumOrderByAggregateInput = {
    id?: SortOrder
    stock?: SortOrder
    precio?: SortOrder
    idCategoria?: SortOrder
    idSubCategoria?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type ProductoRelationFilter = {
    is?: ProductoWhereInput
    isNot?: ProductoWhereInput
  }

  export type FotoCountOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
  }

  export type FotoAvgOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
  }

  export type FotoMaxOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
  }

  export type FotoMinOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
    foto?: SortOrder
  }

  export type FotoSumOrderByAggregateInput = {
    id?: SortOrder
    idProducto?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type ProveedorListRelationFilter = {
    every?: ProveedorWhereInput
    some?: ProveedorWhereInput
    none?: ProveedorWhereInput
  }

  export type BodegaListRelationFilter = {
    every?: BodegaWhereInput
    some?: BodegaWhereInput
    none?: BodegaWhereInput
  }

  export type ProveedorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BodegaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UbicacionCountOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    direccionExacta?: SortOrder
  }

  export type UbicacionAvgOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
  }

  export type UbicacionMaxOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    direccionExacta?: SortOrder
  }

  export type UbicacionMinOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
    direccionExacta?: SortOrder
  }

  export type UbicacionSumOrderByAggregateInput = {
    id?: SortOrder
    idProvincia?: SortOrder
    idCanton?: SortOrder
    idDistrito?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UbicacionRelationFilter = {
    is?: UbicacionWhereInput
    isNot?: UbicacionWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BodegaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
  }

  export type BodegaAvgOrderByAggregateInput = {
    id?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
  }

  export type BodegaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
  }

  export type BodegaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
    seguridad?: SortOrder
  }

  export type BodegaSumOrderByAggregateInput = {
    id?: SortOrder
    idUbicacion?: SortOrder
    tamanno?: SortOrder
    capacidad?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BodegaRelationFilter = {
    is?: BodegaWhereInput
    isNot?: BodegaWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type InventarioIdBodegaIdProductoCompoundUniqueInput = {
    idBodega: number
    idProducto: number
  }

  export type InventarioCountOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuarioRegistro?: SortOrder
    idUsuarioActualizo?: SortOrder
    cantidad?: SortOrder
    cantidadMinima?: SortOrder
    cantidadMaxima?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type InventarioAvgOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuarioRegistro?: SortOrder
    idUsuarioActualizo?: SortOrder
    cantidad?: SortOrder
    cantidadMinima?: SortOrder
    cantidadMaxima?: SortOrder
  }

  export type InventarioMaxOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuarioRegistro?: SortOrder
    idUsuarioActualizo?: SortOrder
    cantidad?: SortOrder
    cantidadMinima?: SortOrder
    cantidadMaxima?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type InventarioMinOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuarioRegistro?: SortOrder
    idUsuarioActualizo?: SortOrder
    cantidad?: SortOrder
    cantidadMinima?: SortOrder
    cantidadMaxima?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type InventarioSumOrderByAggregateInput = {
    idBodega?: SortOrder
    idProducto?: SortOrder
    idUsuarioRegistro?: SortOrder
    idUsuarioActualizo?: SortOrder
    cantidad?: SortOrder
    cantidadMinima?: SortOrder
    cantidadMaxima?: SortOrder
  }

  export type ProveedorCountOrderByAggregateInput = {
    id?: SortOrder
    identificacion?: SortOrder
    nombreProveedor?: SortOrder
    idUbicacion?: SortOrder
    correoElectronico?: SortOrder
    telefono?: SortOrder
  }

  export type ProveedorAvgOrderByAggregateInput = {
    id?: SortOrder
    identificacion?: SortOrder
    idUbicacion?: SortOrder
    telefono?: SortOrder
  }

  export type ProveedorMaxOrderByAggregateInput = {
    id?: SortOrder
    identificacion?: SortOrder
    nombreProveedor?: SortOrder
    idUbicacion?: SortOrder
    correoElectronico?: SortOrder
    telefono?: SortOrder
  }

  export type ProveedorMinOrderByAggregateInput = {
    id?: SortOrder
    identificacion?: SortOrder
    nombreProveedor?: SortOrder
    idUbicacion?: SortOrder
    correoElectronico?: SortOrder
    telefono?: SortOrder
  }

  export type ProveedorSumOrderByAggregateInput = {
    id?: SortOrder
    identificacion?: SortOrder
    idUbicacion?: SortOrder
    telefono?: SortOrder
  }

  export type ProveedorRelationFilter = {
    is?: ProveedorWhereInput
    isNot?: ProveedorWhereInput
  }

  export type EncabezadoCompraCountOrderByAggregateInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idProveedor?: SortOrder
    idUsuario?: SortOrder
  }

  export type EncabezadoCompraAvgOrderByAggregateInput = {
    id?: SortOrder
    idProveedor?: SortOrder
    idUsuario?: SortOrder
  }

  export type EncabezadoCompraMaxOrderByAggregateInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idProveedor?: SortOrder
    idUsuario?: SortOrder
  }

  export type EncabezadoCompraMinOrderByAggregateInput = {
    id?: SortOrder
    fechaCompra?: SortOrder
    idProveedor?: SortOrder
    idUsuario?: SortOrder
  }

  export type EncabezadoCompraSumOrderByAggregateInput = {
    id?: SortOrder
    idProveedor?: SortOrder
    idUsuario?: SortOrder
  }

  export type EncabezadoCompraRelationFilter = {
    is?: EncabezadoCompraWhereInput
    isNot?: EncabezadoCompraWhereInput
  }

  export type DetalleCompraCountOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleCompraAvgOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleCompraMaxOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleCompraMinOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type DetalleCompraSumOrderByAggregateInput = {
    id?: SortOrder
    idEncabezadoCompra?: SortOrder
    idProducto?: SortOrder
    idBodega?: SortOrder
    cantidad?: SortOrder
  }

  export type EstadoRelationFilter = {
    is?: EstadoWhereInput
    isNot?: EstadoWhereInput
  }

  export type PedidoCountOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrder
    fechaPedido?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrder
    fechaPedido?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
    observaciones?: SortOrder
    fechaPedido?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    idEncabezadoCompra?: SortOrder
    idEstado?: SortOrder
  }

  export type UsuarioNullableRelationFilter = {
    is?: UsuarioWhereInput | null
    isNot?: UsuarioWhereInput | null
  }

  export type TrasladoCountOrderByAggregateInput = {
    id?: SortOrder
    idBodegaOrigen?: SortOrder
    idBodegaDestino?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    idEstado?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type TrasladoAvgOrderByAggregateInput = {
    id?: SortOrder
    idBodegaOrigen?: SortOrder
    idBodegaDestino?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    idEstado?: SortOrder
  }

  export type TrasladoMaxOrderByAggregateInput = {
    id?: SortOrder
    idBodegaOrigen?: SortOrder
    idBodegaDestino?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    idEstado?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type TrasladoMinOrderByAggregateInput = {
    id?: SortOrder
    idBodegaOrigen?: SortOrder
    idBodegaDestino?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    idEstado?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type TrasladoSumOrderByAggregateInput = {
    id?: SortOrder
    idBodegaOrigen?: SortOrder
    idBodegaDestino?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    idEstado?: SortOrder
  }

  export type HistorialCountOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    justificacion?: SortOrder
    fechaAjuste?: SortOrder
  }

  export type HistorialAvgOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
  }

  export type HistorialMaxOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    justificacion?: SortOrder
    fechaAjuste?: SortOrder
  }

  export type HistorialMinOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
    justificacion?: SortOrder
    fechaAjuste?: SortOrder
  }

  export type HistorialSumOrderByAggregateInput = {
    id?: SortOrder
    idBodega?: SortOrder
    idUsuarioRegistro?: SortOrder
    idProducto?: SortOrder
  }

  export type EncabezadoCompraCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EncabezadoCompraCreateWithoutUsuarioInput, EncabezadoCompraUncheckedCreateWithoutUsuarioInput> | EncabezadoCompraCreateWithoutUsuarioInput[] | EncabezadoCompraUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutUsuarioInput | EncabezadoCompraCreateOrConnectWithoutUsuarioInput[]
    createMany?: EncabezadoCompraCreateManyUsuarioInputEnvelope
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
  }

  export type TrasladoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TrasladoCreateWithoutUsuarioInput, TrasladoUncheckedCreateWithoutUsuarioInput> | TrasladoCreateWithoutUsuarioInput[] | TrasladoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutUsuarioInput | TrasladoCreateOrConnectWithoutUsuarioInput[]
    createMany?: TrasladoCreateManyUsuarioInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type HistorialCreateNestedManyWithoutUsuarioRegistroInput = {
    create?: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput> | HistorialCreateWithoutUsuarioRegistroInput[] | HistorialUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutUsuarioRegistroInput | HistorialCreateOrConnectWithoutUsuarioRegistroInput[]
    createMany?: HistorialCreateManyUsuarioRegistroInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type InventarioCreateNestedManyWithoutUsuarioRegistroInput = {
    create?: XOR<InventarioCreateWithoutUsuarioRegistroInput, InventarioUncheckedCreateWithoutUsuarioRegistroInput> | InventarioCreateWithoutUsuarioRegistroInput[] | InventarioUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuarioRegistroInput | InventarioCreateOrConnectWithoutUsuarioRegistroInput[]
    createMany?: InventarioCreateManyUsuarioRegistroInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type InventarioCreateNestedManyWithoutUsuarioActualizoInput = {
    create?: XOR<InventarioCreateWithoutUsuarioActualizoInput, InventarioUncheckedCreateWithoutUsuarioActualizoInput> | InventarioCreateWithoutUsuarioActualizoInput[] | InventarioUncheckedCreateWithoutUsuarioActualizoInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuarioActualizoInput | InventarioCreateOrConnectWithoutUsuarioActualizoInput[]
    createMany?: InventarioCreateManyUsuarioActualizoInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type BodegaCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<BodegaCreateWithoutUsuarioInput, BodegaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutUsuarioInput
    connect?: BodegaWhereUniqueInput
  }

  export type EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EncabezadoCompraCreateWithoutUsuarioInput, EncabezadoCompraUncheckedCreateWithoutUsuarioInput> | EncabezadoCompraCreateWithoutUsuarioInput[] | EncabezadoCompraUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutUsuarioInput | EncabezadoCompraCreateOrConnectWithoutUsuarioInput[]
    createMany?: EncabezadoCompraCreateManyUsuarioInputEnvelope
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
  }

  export type TrasladoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TrasladoCreateWithoutUsuarioInput, TrasladoUncheckedCreateWithoutUsuarioInput> | TrasladoCreateWithoutUsuarioInput[] | TrasladoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutUsuarioInput | TrasladoCreateOrConnectWithoutUsuarioInput[]
    createMany?: TrasladoCreateManyUsuarioInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput = {
    create?: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput> | HistorialCreateWithoutUsuarioRegistroInput[] | HistorialUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutUsuarioRegistroInput | HistorialCreateOrConnectWithoutUsuarioRegistroInput[]
    createMany?: HistorialCreateManyUsuarioRegistroInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutUsuarioRegistroInput = {
    create?: XOR<InventarioCreateWithoutUsuarioRegistroInput, InventarioUncheckedCreateWithoutUsuarioRegistroInput> | InventarioCreateWithoutUsuarioRegistroInput[] | InventarioUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuarioRegistroInput | InventarioCreateOrConnectWithoutUsuarioRegistroInput[]
    createMany?: InventarioCreateManyUsuarioRegistroInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutUsuarioActualizoInput = {
    create?: XOR<InventarioCreateWithoutUsuarioActualizoInput, InventarioUncheckedCreateWithoutUsuarioActualizoInput> | InventarioCreateWithoutUsuarioActualizoInput[] | InventarioUncheckedCreateWithoutUsuarioActualizoInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuarioActualizoInput | InventarioCreateOrConnectWithoutUsuarioActualizoInput[]
    createMany?: InventarioCreateManyUsuarioActualizoInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EncabezadoCompraUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutUsuarioInput, EncabezadoCompraUncheckedCreateWithoutUsuarioInput> | EncabezadoCompraCreateWithoutUsuarioInput[] | EncabezadoCompraUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutUsuarioInput | EncabezadoCompraCreateOrConnectWithoutUsuarioInput[]
    upsert?: EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioInput | EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EncabezadoCompraCreateManyUsuarioInputEnvelope
    set?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    disconnect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    delete?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    update?: EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioInput | EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EncabezadoCompraUpdateManyWithWhereWithoutUsuarioInput | EncabezadoCompraUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
  }

  export type TrasladoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TrasladoCreateWithoutUsuarioInput, TrasladoUncheckedCreateWithoutUsuarioInput> | TrasladoCreateWithoutUsuarioInput[] | TrasladoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutUsuarioInput | TrasladoCreateOrConnectWithoutUsuarioInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutUsuarioInput | TrasladoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TrasladoCreateManyUsuarioInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutUsuarioInput | TrasladoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutUsuarioInput | TrasladoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type HistorialUpdateManyWithoutUsuarioRegistroNestedInput = {
    create?: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput> | HistorialCreateWithoutUsuarioRegistroInput[] | HistorialUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutUsuarioRegistroInput | HistorialCreateOrConnectWithoutUsuarioRegistroInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput | HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput[]
    createMany?: HistorialCreateManyUsuarioRegistroInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput | HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput | HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type InventarioUpdateManyWithoutUsuarioRegistroNestedInput = {
    create?: XOR<InventarioCreateWithoutUsuarioRegistroInput, InventarioUncheckedCreateWithoutUsuarioRegistroInput> | InventarioCreateWithoutUsuarioRegistroInput[] | InventarioUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuarioRegistroInput | InventarioCreateOrConnectWithoutUsuarioRegistroInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutUsuarioRegistroInput | InventarioUpsertWithWhereUniqueWithoutUsuarioRegistroInput[]
    createMany?: InventarioCreateManyUsuarioRegistroInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutUsuarioRegistroInput | InventarioUpdateWithWhereUniqueWithoutUsuarioRegistroInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutUsuarioRegistroInput | InventarioUpdateManyWithWhereWithoutUsuarioRegistroInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type InventarioUpdateManyWithoutUsuarioActualizoNestedInput = {
    create?: XOR<InventarioCreateWithoutUsuarioActualizoInput, InventarioUncheckedCreateWithoutUsuarioActualizoInput> | InventarioCreateWithoutUsuarioActualizoInput[] | InventarioUncheckedCreateWithoutUsuarioActualizoInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuarioActualizoInput | InventarioCreateOrConnectWithoutUsuarioActualizoInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutUsuarioActualizoInput | InventarioUpsertWithWhereUniqueWithoutUsuarioActualizoInput[]
    createMany?: InventarioCreateManyUsuarioActualizoInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutUsuarioActualizoInput | InventarioUpdateWithWhereUniqueWithoutUsuarioActualizoInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutUsuarioActualizoInput | InventarioUpdateManyWithWhereWithoutUsuarioActualizoInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type BodegaUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<BodegaCreateWithoutUsuarioInput, BodegaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutUsuarioInput
    upsert?: BodegaUpsertWithoutUsuarioInput
    disconnect?: BodegaWhereInput | boolean
    delete?: BodegaWhereInput | boolean
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutUsuarioInput, BodegaUpdateWithoutUsuarioInput>, BodegaUncheckedUpdateWithoutUsuarioInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EncabezadoCompraUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutUsuarioInput, EncabezadoCompraUncheckedCreateWithoutUsuarioInput> | EncabezadoCompraCreateWithoutUsuarioInput[] | EncabezadoCompraUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutUsuarioInput | EncabezadoCompraCreateOrConnectWithoutUsuarioInput[]
    upsert?: EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioInput | EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EncabezadoCompraCreateManyUsuarioInputEnvelope
    set?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    disconnect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    delete?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    update?: EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioInput | EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EncabezadoCompraUpdateManyWithWhereWithoutUsuarioInput | EncabezadoCompraUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
  }

  export type TrasladoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TrasladoCreateWithoutUsuarioInput, TrasladoUncheckedCreateWithoutUsuarioInput> | TrasladoCreateWithoutUsuarioInput[] | TrasladoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutUsuarioInput | TrasladoCreateOrConnectWithoutUsuarioInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutUsuarioInput | TrasladoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TrasladoCreateManyUsuarioInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutUsuarioInput | TrasladoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutUsuarioInput | TrasladoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput = {
    create?: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput> | HistorialCreateWithoutUsuarioRegistroInput[] | HistorialUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutUsuarioRegistroInput | HistorialCreateOrConnectWithoutUsuarioRegistroInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput | HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput[]
    createMany?: HistorialCreateManyUsuarioRegistroInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput | HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput | HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutUsuarioRegistroNestedInput = {
    create?: XOR<InventarioCreateWithoutUsuarioRegistroInput, InventarioUncheckedCreateWithoutUsuarioRegistroInput> | InventarioCreateWithoutUsuarioRegistroInput[] | InventarioUncheckedCreateWithoutUsuarioRegistroInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuarioRegistroInput | InventarioCreateOrConnectWithoutUsuarioRegistroInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutUsuarioRegistroInput | InventarioUpsertWithWhereUniqueWithoutUsuarioRegistroInput[]
    createMany?: InventarioCreateManyUsuarioRegistroInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutUsuarioRegistroInput | InventarioUpdateWithWhereUniqueWithoutUsuarioRegistroInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutUsuarioRegistroInput | InventarioUpdateManyWithWhereWithoutUsuarioRegistroInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutUsuarioActualizoNestedInput = {
    create?: XOR<InventarioCreateWithoutUsuarioActualizoInput, InventarioUncheckedCreateWithoutUsuarioActualizoInput> | InventarioCreateWithoutUsuarioActualizoInput[] | InventarioUncheckedCreateWithoutUsuarioActualizoInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuarioActualizoInput | InventarioCreateOrConnectWithoutUsuarioActualizoInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutUsuarioActualizoInput | InventarioUpsertWithWhereUniqueWithoutUsuarioActualizoInput[]
    createMany?: InventarioCreateManyUsuarioActualizoInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutUsuarioActualizoInput | InventarioUpdateWithWhereUniqueWithoutUsuarioActualizoInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutUsuarioActualizoInput | InventarioUpdateManyWithWhereWithoutUsuarioActualizoInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type PedidoCreateNestedManyWithoutEstadoPedidoInput = {
    create?: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput> | PedidoCreateWithoutEstadoPedidoInput[] | PedidoUncheckedCreateWithoutEstadoPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEstadoPedidoInput | PedidoCreateOrConnectWithoutEstadoPedidoInput[]
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type TrasladoCreateNestedManyWithoutEstadoDestinoInput = {
    create?: XOR<TrasladoCreateWithoutEstadoDestinoInput, TrasladoUncheckedCreateWithoutEstadoDestinoInput> | TrasladoCreateWithoutEstadoDestinoInput[] | TrasladoUncheckedCreateWithoutEstadoDestinoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutEstadoDestinoInput | TrasladoCreateOrConnectWithoutEstadoDestinoInput[]
    createMany?: TrasladoCreateManyEstadoDestinoInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutEstadoPedidoInput = {
    create?: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput> | PedidoCreateWithoutEstadoPedidoInput[] | PedidoUncheckedCreateWithoutEstadoPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEstadoPedidoInput | PedidoCreateOrConnectWithoutEstadoPedidoInput[]
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type TrasladoUncheckedCreateNestedManyWithoutEstadoDestinoInput = {
    create?: XOR<TrasladoCreateWithoutEstadoDestinoInput, TrasladoUncheckedCreateWithoutEstadoDestinoInput> | TrasladoCreateWithoutEstadoDestinoInput[] | TrasladoUncheckedCreateWithoutEstadoDestinoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutEstadoDestinoInput | TrasladoCreateOrConnectWithoutEstadoDestinoInput[]
    createMany?: TrasladoCreateManyEstadoDestinoInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type PedidoUpdateManyWithoutEstadoPedidoNestedInput = {
    create?: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput> | PedidoCreateWithoutEstadoPedidoInput[] | PedidoUncheckedCreateWithoutEstadoPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEstadoPedidoInput | PedidoCreateOrConnectWithoutEstadoPedidoInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput | PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput[]
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput | PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutEstadoPedidoInput | PedidoUpdateManyWithWhereWithoutEstadoPedidoInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type TrasladoUpdateManyWithoutEstadoDestinoNestedInput = {
    create?: XOR<TrasladoCreateWithoutEstadoDestinoInput, TrasladoUncheckedCreateWithoutEstadoDestinoInput> | TrasladoCreateWithoutEstadoDestinoInput[] | TrasladoUncheckedCreateWithoutEstadoDestinoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutEstadoDestinoInput | TrasladoCreateOrConnectWithoutEstadoDestinoInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutEstadoDestinoInput | TrasladoUpsertWithWhereUniqueWithoutEstadoDestinoInput[]
    createMany?: TrasladoCreateManyEstadoDestinoInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutEstadoDestinoInput | TrasladoUpdateWithWhereUniqueWithoutEstadoDestinoInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutEstadoDestinoInput | TrasladoUpdateManyWithWhereWithoutEstadoDestinoInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutEstadoPedidoNestedInput = {
    create?: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput> | PedidoCreateWithoutEstadoPedidoInput[] | PedidoUncheckedCreateWithoutEstadoPedidoInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEstadoPedidoInput | PedidoCreateOrConnectWithoutEstadoPedidoInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput | PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput[]
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput | PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutEstadoPedidoInput | PedidoUpdateManyWithWhereWithoutEstadoPedidoInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type TrasladoUncheckedUpdateManyWithoutEstadoDestinoNestedInput = {
    create?: XOR<TrasladoCreateWithoutEstadoDestinoInput, TrasladoUncheckedCreateWithoutEstadoDestinoInput> | TrasladoCreateWithoutEstadoDestinoInput[] | TrasladoUncheckedCreateWithoutEstadoDestinoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutEstadoDestinoInput | TrasladoCreateOrConnectWithoutEstadoDestinoInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutEstadoDestinoInput | TrasladoUpsertWithWhereUniqueWithoutEstadoDestinoInput[]
    createMany?: TrasladoCreateManyEstadoDestinoInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutEstadoDestinoInput | TrasladoUpdateWithWhereUniqueWithoutEstadoDestinoInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutEstadoDestinoInput | TrasladoUpdateManyWithWhereWithoutEstadoDestinoInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type SubCategoriaCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput> | SubCategoriaCreateWithoutCategoriasInput[] | SubCategoriaUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutCategoriasInput | SubCategoriaCreateOrConnectWithoutCategoriasInput[]
    connect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
  }

  export type ProductoCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput> | ProductoCreateWithoutCategoriaInput[] | ProductoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutCategoriaInput | ProductoCreateOrConnectWithoutCategoriaInput[]
    createMany?: ProductoCreateManyCategoriaInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type SubCategoriaUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput> | SubCategoriaCreateWithoutCategoriasInput[] | SubCategoriaUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutCategoriasInput | SubCategoriaCreateOrConnectWithoutCategoriasInput[]
    connect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
  }

  export type ProductoUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput> | ProductoCreateWithoutCategoriaInput[] | ProductoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutCategoriaInput | ProductoCreateOrConnectWithoutCategoriaInput[]
    createMany?: ProductoCreateManyCategoriaInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type SubCategoriaUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput> | SubCategoriaCreateWithoutCategoriasInput[] | SubCategoriaUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutCategoriasInput | SubCategoriaCreateOrConnectWithoutCategoriasInput[]
    upsert?: SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput | SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput[]
    set?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    disconnect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    delete?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    connect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    update?: SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput | SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: SubCategoriaUpdateManyWithWhereWithoutCategoriasInput | SubCategoriaUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: SubCategoriaScalarWhereInput | SubCategoriaScalarWhereInput[]
  }

  export type ProductoUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput> | ProductoCreateWithoutCategoriaInput[] | ProductoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutCategoriaInput | ProductoCreateOrConnectWithoutCategoriaInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutCategoriaInput | ProductoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ProductoCreateManyCategoriaInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutCategoriaInput | ProductoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutCategoriaInput | ProductoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type SubCategoriaUncheckedUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput> | SubCategoriaCreateWithoutCategoriasInput[] | SubCategoriaUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutCategoriasInput | SubCategoriaCreateOrConnectWithoutCategoriasInput[]
    upsert?: SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput | SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput[]
    set?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    disconnect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    delete?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    connect?: SubCategoriaWhereUniqueInput | SubCategoriaWhereUniqueInput[]
    update?: SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput | SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: SubCategoriaUpdateManyWithWhereWithoutCategoriasInput | SubCategoriaUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: SubCategoriaScalarWhereInput | SubCategoriaScalarWhereInput[]
  }

  export type ProductoUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput> | ProductoCreateWithoutCategoriaInput[] | ProductoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutCategoriaInput | ProductoCreateOrConnectWithoutCategoriaInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutCategoriaInput | ProductoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ProductoCreateManyCategoriaInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutCategoriaInput | ProductoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutCategoriaInput | ProductoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type ProductoCreateNestedManyWithoutSubCategoriasInput = {
    create?: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput> | ProductoCreateWithoutSubCategoriasInput[] | ProductoUncheckedCreateWithoutSubCategoriasInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutSubCategoriasInput | ProductoCreateOrConnectWithoutSubCategoriasInput[]
    createMany?: ProductoCreateManySubCategoriasInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type CategoriaCreateNestedManyWithoutSubCategoriaInput = {
    create?: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput> | CategoriaCreateWithoutSubCategoriaInput[] | CategoriaUncheckedCreateWithoutSubCategoriaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutSubCategoriaInput | CategoriaCreateOrConnectWithoutSubCategoriaInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type ProductoUncheckedCreateNestedManyWithoutSubCategoriasInput = {
    create?: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput> | ProductoCreateWithoutSubCategoriasInput[] | ProductoUncheckedCreateWithoutSubCategoriasInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutSubCategoriasInput | ProductoCreateOrConnectWithoutSubCategoriasInput[]
    createMany?: ProductoCreateManySubCategoriasInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type CategoriaUncheckedCreateNestedManyWithoutSubCategoriaInput = {
    create?: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput> | CategoriaCreateWithoutSubCategoriaInput[] | CategoriaUncheckedCreateWithoutSubCategoriaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutSubCategoriaInput | CategoriaCreateOrConnectWithoutSubCategoriaInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type ProductoUpdateManyWithoutSubCategoriasNestedInput = {
    create?: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput> | ProductoCreateWithoutSubCategoriasInput[] | ProductoUncheckedCreateWithoutSubCategoriasInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutSubCategoriasInput | ProductoCreateOrConnectWithoutSubCategoriasInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput | ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput[]
    createMany?: ProductoCreateManySubCategoriasInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput | ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutSubCategoriasInput | ProductoUpdateManyWithWhereWithoutSubCategoriasInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type CategoriaUpdateManyWithoutSubCategoriaNestedInput = {
    create?: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput> | CategoriaCreateWithoutSubCategoriaInput[] | CategoriaUncheckedCreateWithoutSubCategoriaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutSubCategoriaInput | CategoriaCreateOrConnectWithoutSubCategoriaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput | CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput[]
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput | CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutSubCategoriaInput | CategoriaUpdateManyWithWhereWithoutSubCategoriaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type ProductoUncheckedUpdateManyWithoutSubCategoriasNestedInput = {
    create?: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput> | ProductoCreateWithoutSubCategoriasInput[] | ProductoUncheckedCreateWithoutSubCategoriasInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutSubCategoriasInput | ProductoCreateOrConnectWithoutSubCategoriasInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput | ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput[]
    createMany?: ProductoCreateManySubCategoriasInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput | ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutSubCategoriasInput | ProductoUpdateManyWithWhereWithoutSubCategoriasInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type CategoriaUncheckedUpdateManyWithoutSubCategoriaNestedInput = {
    create?: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput> | CategoriaCreateWithoutSubCategoriaInput[] | CategoriaUncheckedCreateWithoutSubCategoriaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutSubCategoriaInput | CategoriaCreateOrConnectWithoutSubCategoriaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput | CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput[]
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput | CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutSubCategoriaInput | CategoriaUpdateManyWithWhereWithoutSubCategoriaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type CategoriaCreateNestedOneWithoutProductoInput = {
    create?: XOR<CategoriaCreateWithoutProductoInput, CategoriaUncheckedCreateWithoutProductoInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutProductoInput
    connect?: CategoriaWhereUniqueInput
  }

  export type FotoCreateNestedManyWithoutProductoInput = {
    create?: XOR<FotoCreateWithoutProductoInput, FotoUncheckedCreateWithoutProductoInput> | FotoCreateWithoutProductoInput[] | FotoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: FotoCreateOrConnectWithoutProductoInput | FotoCreateOrConnectWithoutProductoInput[]
    createMany?: FotoCreateManyProductoInputEnvelope
    connect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
  }

  export type InventarioCreateNestedManyWithoutProductoInput = {
    create?: XOR<InventarioCreateWithoutProductoInput, InventarioUncheckedCreateWithoutProductoInput> | InventarioCreateWithoutProductoInput[] | InventarioUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutProductoInput | InventarioCreateOrConnectWithoutProductoInput[]
    createMany?: InventarioCreateManyProductoInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type DetalleCompraCreateNestedManyWithoutProductoInput = {
    create?: XOR<DetalleCompraCreateWithoutProductoInput, DetalleCompraUncheckedCreateWithoutProductoInput> | DetalleCompraCreateWithoutProductoInput[] | DetalleCompraUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutProductoInput | DetalleCompraCreateOrConnectWithoutProductoInput[]
    createMany?: DetalleCompraCreateManyProductoInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type HistorialCreateNestedManyWithoutProductoInput = {
    create?: XOR<HistorialCreateWithoutProductoInput, HistorialUncheckedCreateWithoutProductoInput> | HistorialCreateWithoutProductoInput[] | HistorialUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutProductoInput | HistorialCreateOrConnectWithoutProductoInput[]
    createMany?: HistorialCreateManyProductoInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type TrasladoCreateNestedManyWithoutProductoInput = {
    create?: XOR<TrasladoCreateWithoutProductoInput, TrasladoUncheckedCreateWithoutProductoInput> | TrasladoCreateWithoutProductoInput[] | TrasladoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutProductoInput | TrasladoCreateOrConnectWithoutProductoInput[]
    createMany?: TrasladoCreateManyProductoInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type SubCategoriaCreateNestedOneWithoutProductoInput = {
    create?: XOR<SubCategoriaCreateWithoutProductoInput, SubCategoriaUncheckedCreateWithoutProductoInput>
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutProductoInput
    connect?: SubCategoriaWhereUniqueInput
  }

  export type FotoUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<FotoCreateWithoutProductoInput, FotoUncheckedCreateWithoutProductoInput> | FotoCreateWithoutProductoInput[] | FotoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: FotoCreateOrConnectWithoutProductoInput | FotoCreateOrConnectWithoutProductoInput[]
    createMany?: FotoCreateManyProductoInputEnvelope
    connect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<InventarioCreateWithoutProductoInput, InventarioUncheckedCreateWithoutProductoInput> | InventarioCreateWithoutProductoInput[] | InventarioUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutProductoInput | InventarioCreateOrConnectWithoutProductoInput[]
    createMany?: InventarioCreateManyProductoInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type DetalleCompraUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<DetalleCompraCreateWithoutProductoInput, DetalleCompraUncheckedCreateWithoutProductoInput> | DetalleCompraCreateWithoutProductoInput[] | DetalleCompraUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutProductoInput | DetalleCompraCreateOrConnectWithoutProductoInput[]
    createMany?: DetalleCompraCreateManyProductoInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type HistorialUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<HistorialCreateWithoutProductoInput, HistorialUncheckedCreateWithoutProductoInput> | HistorialCreateWithoutProductoInput[] | HistorialUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutProductoInput | HistorialCreateOrConnectWithoutProductoInput[]
    createMany?: HistorialCreateManyProductoInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type TrasladoUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<TrasladoCreateWithoutProductoInput, TrasladoUncheckedCreateWithoutProductoInput> | TrasladoCreateWithoutProductoInput[] | TrasladoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutProductoInput | TrasladoCreateOrConnectWithoutProductoInput[]
    createMany?: TrasladoCreateManyProductoInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CategoriaUpdateOneRequiredWithoutProductoNestedInput = {
    create?: XOR<CategoriaCreateWithoutProductoInput, CategoriaUncheckedCreateWithoutProductoInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutProductoInput
    upsert?: CategoriaUpsertWithoutProductoInput
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutProductoInput, CategoriaUpdateWithoutProductoInput>, CategoriaUncheckedUpdateWithoutProductoInput>
  }

  export type FotoUpdateManyWithoutProductoNestedInput = {
    create?: XOR<FotoCreateWithoutProductoInput, FotoUncheckedCreateWithoutProductoInput> | FotoCreateWithoutProductoInput[] | FotoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: FotoCreateOrConnectWithoutProductoInput | FotoCreateOrConnectWithoutProductoInput[]
    upsert?: FotoUpsertWithWhereUniqueWithoutProductoInput | FotoUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: FotoCreateManyProductoInputEnvelope
    set?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    disconnect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    delete?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    connect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    update?: FotoUpdateWithWhereUniqueWithoutProductoInput | FotoUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: FotoUpdateManyWithWhereWithoutProductoInput | FotoUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: FotoScalarWhereInput | FotoScalarWhereInput[]
  }

  export type InventarioUpdateManyWithoutProductoNestedInput = {
    create?: XOR<InventarioCreateWithoutProductoInput, InventarioUncheckedCreateWithoutProductoInput> | InventarioCreateWithoutProductoInput[] | InventarioUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutProductoInput | InventarioCreateOrConnectWithoutProductoInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutProductoInput | InventarioUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: InventarioCreateManyProductoInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutProductoInput | InventarioUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutProductoInput | InventarioUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type DetalleCompraUpdateManyWithoutProductoNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutProductoInput, DetalleCompraUncheckedCreateWithoutProductoInput> | DetalleCompraCreateWithoutProductoInput[] | DetalleCompraUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutProductoInput | DetalleCompraCreateOrConnectWithoutProductoInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutProductoInput | DetalleCompraUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: DetalleCompraCreateManyProductoInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutProductoInput | DetalleCompraUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutProductoInput | DetalleCompraUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type HistorialUpdateManyWithoutProductoNestedInput = {
    create?: XOR<HistorialCreateWithoutProductoInput, HistorialUncheckedCreateWithoutProductoInput> | HistorialCreateWithoutProductoInput[] | HistorialUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutProductoInput | HistorialCreateOrConnectWithoutProductoInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutProductoInput | HistorialUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: HistorialCreateManyProductoInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutProductoInput | HistorialUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutProductoInput | HistorialUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type TrasladoUpdateManyWithoutProductoNestedInput = {
    create?: XOR<TrasladoCreateWithoutProductoInput, TrasladoUncheckedCreateWithoutProductoInput> | TrasladoCreateWithoutProductoInput[] | TrasladoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutProductoInput | TrasladoCreateOrConnectWithoutProductoInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutProductoInput | TrasladoUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: TrasladoCreateManyProductoInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutProductoInput | TrasladoUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutProductoInput | TrasladoUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type SubCategoriaUpdateOneRequiredWithoutProductoNestedInput = {
    create?: XOR<SubCategoriaCreateWithoutProductoInput, SubCategoriaUncheckedCreateWithoutProductoInput>
    connectOrCreate?: SubCategoriaCreateOrConnectWithoutProductoInput
    upsert?: SubCategoriaUpsertWithoutProductoInput
    connect?: SubCategoriaWhereUniqueInput
    update?: XOR<XOR<SubCategoriaUpdateToOneWithWhereWithoutProductoInput, SubCategoriaUpdateWithoutProductoInput>, SubCategoriaUncheckedUpdateWithoutProductoInput>
  }

  export type FotoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<FotoCreateWithoutProductoInput, FotoUncheckedCreateWithoutProductoInput> | FotoCreateWithoutProductoInput[] | FotoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: FotoCreateOrConnectWithoutProductoInput | FotoCreateOrConnectWithoutProductoInput[]
    upsert?: FotoUpsertWithWhereUniqueWithoutProductoInput | FotoUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: FotoCreateManyProductoInputEnvelope
    set?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    disconnect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    delete?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    connect?: FotoWhereUniqueInput | FotoWhereUniqueInput[]
    update?: FotoUpdateWithWhereUniqueWithoutProductoInput | FotoUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: FotoUpdateManyWithWhereWithoutProductoInput | FotoUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: FotoScalarWhereInput | FotoScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<InventarioCreateWithoutProductoInput, InventarioUncheckedCreateWithoutProductoInput> | InventarioCreateWithoutProductoInput[] | InventarioUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutProductoInput | InventarioCreateOrConnectWithoutProductoInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutProductoInput | InventarioUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: InventarioCreateManyProductoInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutProductoInput | InventarioUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutProductoInput | InventarioUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type DetalleCompraUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutProductoInput, DetalleCompraUncheckedCreateWithoutProductoInput> | DetalleCompraCreateWithoutProductoInput[] | DetalleCompraUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutProductoInput | DetalleCompraCreateOrConnectWithoutProductoInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutProductoInput | DetalleCompraUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: DetalleCompraCreateManyProductoInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutProductoInput | DetalleCompraUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutProductoInput | DetalleCompraUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type HistorialUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<HistorialCreateWithoutProductoInput, HistorialUncheckedCreateWithoutProductoInput> | HistorialCreateWithoutProductoInput[] | HistorialUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutProductoInput | HistorialCreateOrConnectWithoutProductoInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutProductoInput | HistorialUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: HistorialCreateManyProductoInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutProductoInput | HistorialUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutProductoInput | HistorialUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type TrasladoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<TrasladoCreateWithoutProductoInput, TrasladoUncheckedCreateWithoutProductoInput> | TrasladoCreateWithoutProductoInput[] | TrasladoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutProductoInput | TrasladoCreateOrConnectWithoutProductoInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutProductoInput | TrasladoUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: TrasladoCreateManyProductoInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutProductoInput | TrasladoUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutProductoInput | TrasladoUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type ProductoCreateNestedOneWithoutFotoInput = {
    create?: XOR<ProductoCreateWithoutFotoInput, ProductoUncheckedCreateWithoutFotoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutFotoInput
    connect?: ProductoWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type ProductoUpdateOneRequiredWithoutFotoNestedInput = {
    create?: XOR<ProductoCreateWithoutFotoInput, ProductoUncheckedCreateWithoutFotoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutFotoInput
    upsert?: ProductoUpsertWithoutFotoInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutFotoInput, ProductoUpdateWithoutFotoInput>, ProductoUncheckedUpdateWithoutFotoInput>
  }

  export type ProveedorCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<ProveedorCreateWithoutUbicacionInput, ProveedorUncheckedCreateWithoutUbicacionInput> | ProveedorCreateWithoutUbicacionInput[] | ProveedorUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: ProveedorCreateOrConnectWithoutUbicacionInput | ProveedorCreateOrConnectWithoutUbicacionInput[]
    createMany?: ProveedorCreateManyUbicacionInputEnvelope
    connect?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
  }

  export type BodegaCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput> | BodegaCreateWithoutUbicacionInput[] | BodegaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BodegaCreateOrConnectWithoutUbicacionInput | BodegaCreateOrConnectWithoutUbicacionInput[]
    createMany?: BodegaCreateManyUbicacionInputEnvelope
    connect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
  }

  export type ProveedorUncheckedCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<ProveedorCreateWithoutUbicacionInput, ProveedorUncheckedCreateWithoutUbicacionInput> | ProveedorCreateWithoutUbicacionInput[] | ProveedorUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: ProveedorCreateOrConnectWithoutUbicacionInput | ProveedorCreateOrConnectWithoutUbicacionInput[]
    createMany?: ProveedorCreateManyUbicacionInputEnvelope
    connect?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
  }

  export type BodegaUncheckedCreateNestedManyWithoutUbicacionInput = {
    create?: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput> | BodegaCreateWithoutUbicacionInput[] | BodegaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BodegaCreateOrConnectWithoutUbicacionInput | BodegaCreateOrConnectWithoutUbicacionInput[]
    createMany?: BodegaCreateManyUbicacionInputEnvelope
    connect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
  }

  export type ProveedorUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<ProveedorCreateWithoutUbicacionInput, ProveedorUncheckedCreateWithoutUbicacionInput> | ProveedorCreateWithoutUbicacionInput[] | ProveedorUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: ProveedorCreateOrConnectWithoutUbicacionInput | ProveedorCreateOrConnectWithoutUbicacionInput[]
    upsert?: ProveedorUpsertWithWhereUniqueWithoutUbicacionInput | ProveedorUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: ProveedorCreateManyUbicacionInputEnvelope
    set?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
    disconnect?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
    delete?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
    connect?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
    update?: ProveedorUpdateWithWhereUniqueWithoutUbicacionInput | ProveedorUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: ProveedorUpdateManyWithWhereWithoutUbicacionInput | ProveedorUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: ProveedorScalarWhereInput | ProveedorScalarWhereInput[]
  }

  export type BodegaUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput> | BodegaCreateWithoutUbicacionInput[] | BodegaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BodegaCreateOrConnectWithoutUbicacionInput | BodegaCreateOrConnectWithoutUbicacionInput[]
    upsert?: BodegaUpsertWithWhereUniqueWithoutUbicacionInput | BodegaUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: BodegaCreateManyUbicacionInputEnvelope
    set?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    disconnect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    delete?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    connect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    update?: BodegaUpdateWithWhereUniqueWithoutUbicacionInput | BodegaUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: BodegaUpdateManyWithWhereWithoutUbicacionInput | BodegaUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: BodegaScalarWhereInput | BodegaScalarWhereInput[]
  }

  export type ProveedorUncheckedUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<ProveedorCreateWithoutUbicacionInput, ProveedorUncheckedCreateWithoutUbicacionInput> | ProveedorCreateWithoutUbicacionInput[] | ProveedorUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: ProveedorCreateOrConnectWithoutUbicacionInput | ProveedorCreateOrConnectWithoutUbicacionInput[]
    upsert?: ProveedorUpsertWithWhereUniqueWithoutUbicacionInput | ProveedorUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: ProveedorCreateManyUbicacionInputEnvelope
    set?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
    disconnect?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
    delete?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
    connect?: ProveedorWhereUniqueInput | ProveedorWhereUniqueInput[]
    update?: ProveedorUpdateWithWhereUniqueWithoutUbicacionInput | ProveedorUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: ProveedorUpdateManyWithWhereWithoutUbicacionInput | ProveedorUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: ProveedorScalarWhereInput | ProveedorScalarWhereInput[]
  }

  export type BodegaUncheckedUpdateManyWithoutUbicacionNestedInput = {
    create?: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput> | BodegaCreateWithoutUbicacionInput[] | BodegaUncheckedCreateWithoutUbicacionInput[]
    connectOrCreate?: BodegaCreateOrConnectWithoutUbicacionInput | BodegaCreateOrConnectWithoutUbicacionInput[]
    upsert?: BodegaUpsertWithWhereUniqueWithoutUbicacionInput | BodegaUpsertWithWhereUniqueWithoutUbicacionInput[]
    createMany?: BodegaCreateManyUbicacionInputEnvelope
    set?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    disconnect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    delete?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    connect?: BodegaWhereUniqueInput | BodegaWhereUniqueInput[]
    update?: BodegaUpdateWithWhereUniqueWithoutUbicacionInput | BodegaUpdateWithWhereUniqueWithoutUbicacionInput[]
    updateMany?: BodegaUpdateManyWithWhereWithoutUbicacionInput | BodegaUpdateManyWithWhereWithoutUbicacionInput[]
    deleteMany?: BodegaScalarWhereInput | BodegaScalarWhereInput[]
  }

  export type UsuarioCreateNestedManyWithoutBodegaInput = {
    create?: XOR<UsuarioCreateWithoutBodegaInput, UsuarioUncheckedCreateWithoutBodegaInput> | UsuarioCreateWithoutBodegaInput[] | UsuarioUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutBodegaInput | UsuarioCreateOrConnectWithoutBodegaInput[]
    createMany?: UsuarioCreateManyBodegaInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type InventarioCreateNestedManyWithoutBodegasInput = {
    create?: XOR<InventarioCreateWithoutBodegasInput, InventarioUncheckedCreateWithoutBodegasInput> | InventarioCreateWithoutBodegasInput[] | InventarioUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutBodegasInput | InventarioCreateOrConnectWithoutBodegasInput[]
    createMany?: InventarioCreateManyBodegasInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type DetalleCompraCreateNestedManyWithoutBodegaInput = {
    create?: XOR<DetalleCompraCreateWithoutBodegaInput, DetalleCompraUncheckedCreateWithoutBodegaInput> | DetalleCompraCreateWithoutBodegaInput[] | DetalleCompraUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutBodegaInput | DetalleCompraCreateOrConnectWithoutBodegaInput[]
    createMany?: DetalleCompraCreateManyBodegaInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type HistorialCreateNestedManyWithoutBodegaInput = {
    create?: XOR<HistorialCreateWithoutBodegaInput, HistorialUncheckedCreateWithoutBodegaInput> | HistorialCreateWithoutBodegaInput[] | HistorialUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutBodegaInput | HistorialCreateOrConnectWithoutBodegaInput[]
    createMany?: HistorialCreateManyBodegaInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type TrasladoCreateNestedManyWithoutBodegaOrigenInput = {
    create?: XOR<TrasladoCreateWithoutBodegaOrigenInput, TrasladoUncheckedCreateWithoutBodegaOrigenInput> | TrasladoCreateWithoutBodegaOrigenInput[] | TrasladoUncheckedCreateWithoutBodegaOrigenInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutBodegaOrigenInput | TrasladoCreateOrConnectWithoutBodegaOrigenInput[]
    createMany?: TrasladoCreateManyBodegaOrigenInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type TrasladoCreateNestedManyWithoutBodegaDestinoInput = {
    create?: XOR<TrasladoCreateWithoutBodegaDestinoInput, TrasladoUncheckedCreateWithoutBodegaDestinoInput> | TrasladoCreateWithoutBodegaDestinoInput[] | TrasladoUncheckedCreateWithoutBodegaDestinoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutBodegaDestinoInput | TrasladoCreateOrConnectWithoutBodegaDestinoInput[]
    createMany?: TrasladoCreateManyBodegaDestinoInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type UbicacionCreateNestedOneWithoutBodegaInput = {
    create?: XOR<UbicacionCreateWithoutBodegaInput, UbicacionUncheckedCreateWithoutBodegaInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutBodegaInput
    connect?: UbicacionWhereUniqueInput
  }

  export type UsuarioUncheckedCreateNestedManyWithoutBodegaInput = {
    create?: XOR<UsuarioCreateWithoutBodegaInput, UsuarioUncheckedCreateWithoutBodegaInput> | UsuarioCreateWithoutBodegaInput[] | UsuarioUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutBodegaInput | UsuarioCreateOrConnectWithoutBodegaInput[]
    createMany?: UsuarioCreateManyBodegaInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutBodegasInput = {
    create?: XOR<InventarioCreateWithoutBodegasInput, InventarioUncheckedCreateWithoutBodegasInput> | InventarioCreateWithoutBodegasInput[] | InventarioUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutBodegasInput | InventarioCreateOrConnectWithoutBodegasInput[]
    createMany?: InventarioCreateManyBodegasInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type DetalleCompraUncheckedCreateNestedManyWithoutBodegaInput = {
    create?: XOR<DetalleCompraCreateWithoutBodegaInput, DetalleCompraUncheckedCreateWithoutBodegaInput> | DetalleCompraCreateWithoutBodegaInput[] | DetalleCompraUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutBodegaInput | DetalleCompraCreateOrConnectWithoutBodegaInput[]
    createMany?: DetalleCompraCreateManyBodegaInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type HistorialUncheckedCreateNestedManyWithoutBodegaInput = {
    create?: XOR<HistorialCreateWithoutBodegaInput, HistorialUncheckedCreateWithoutBodegaInput> | HistorialCreateWithoutBodegaInput[] | HistorialUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutBodegaInput | HistorialCreateOrConnectWithoutBodegaInput[]
    createMany?: HistorialCreateManyBodegaInputEnvelope
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
  }

  export type TrasladoUncheckedCreateNestedManyWithoutBodegaOrigenInput = {
    create?: XOR<TrasladoCreateWithoutBodegaOrigenInput, TrasladoUncheckedCreateWithoutBodegaOrigenInput> | TrasladoCreateWithoutBodegaOrigenInput[] | TrasladoUncheckedCreateWithoutBodegaOrigenInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutBodegaOrigenInput | TrasladoCreateOrConnectWithoutBodegaOrigenInput[]
    createMany?: TrasladoCreateManyBodegaOrigenInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type TrasladoUncheckedCreateNestedManyWithoutBodegaDestinoInput = {
    create?: XOR<TrasladoCreateWithoutBodegaDestinoInput, TrasladoUncheckedCreateWithoutBodegaDestinoInput> | TrasladoCreateWithoutBodegaDestinoInput[] | TrasladoUncheckedCreateWithoutBodegaDestinoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutBodegaDestinoInput | TrasladoCreateOrConnectWithoutBodegaDestinoInput[]
    createMany?: TrasladoCreateManyBodegaDestinoInputEnvelope
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUpdateManyWithoutBodegaNestedInput = {
    create?: XOR<UsuarioCreateWithoutBodegaInput, UsuarioUncheckedCreateWithoutBodegaInput> | UsuarioCreateWithoutBodegaInput[] | UsuarioUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutBodegaInput | UsuarioCreateOrConnectWithoutBodegaInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutBodegaInput | UsuarioUpsertWithWhereUniqueWithoutBodegaInput[]
    createMany?: UsuarioCreateManyBodegaInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutBodegaInput | UsuarioUpdateWithWhereUniqueWithoutBodegaInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutBodegaInput | UsuarioUpdateManyWithWhereWithoutBodegaInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type InventarioUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<InventarioCreateWithoutBodegasInput, InventarioUncheckedCreateWithoutBodegasInput> | InventarioCreateWithoutBodegasInput[] | InventarioUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutBodegasInput | InventarioCreateOrConnectWithoutBodegasInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutBodegasInput | InventarioUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: InventarioCreateManyBodegasInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutBodegasInput | InventarioUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutBodegasInput | InventarioUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type DetalleCompraUpdateManyWithoutBodegaNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutBodegaInput, DetalleCompraUncheckedCreateWithoutBodegaInput> | DetalleCompraCreateWithoutBodegaInput[] | DetalleCompraUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutBodegaInput | DetalleCompraCreateOrConnectWithoutBodegaInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutBodegaInput | DetalleCompraUpsertWithWhereUniqueWithoutBodegaInput[]
    createMany?: DetalleCompraCreateManyBodegaInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutBodegaInput | DetalleCompraUpdateWithWhereUniqueWithoutBodegaInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutBodegaInput | DetalleCompraUpdateManyWithWhereWithoutBodegaInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type HistorialUpdateManyWithoutBodegaNestedInput = {
    create?: XOR<HistorialCreateWithoutBodegaInput, HistorialUncheckedCreateWithoutBodegaInput> | HistorialCreateWithoutBodegaInput[] | HistorialUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutBodegaInput | HistorialCreateOrConnectWithoutBodegaInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutBodegaInput | HistorialUpsertWithWhereUniqueWithoutBodegaInput[]
    createMany?: HistorialCreateManyBodegaInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutBodegaInput | HistorialUpdateWithWhereUniqueWithoutBodegaInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutBodegaInput | HistorialUpdateManyWithWhereWithoutBodegaInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type TrasladoUpdateManyWithoutBodegaOrigenNestedInput = {
    create?: XOR<TrasladoCreateWithoutBodegaOrigenInput, TrasladoUncheckedCreateWithoutBodegaOrigenInput> | TrasladoCreateWithoutBodegaOrigenInput[] | TrasladoUncheckedCreateWithoutBodegaOrigenInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutBodegaOrigenInput | TrasladoCreateOrConnectWithoutBodegaOrigenInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutBodegaOrigenInput | TrasladoUpsertWithWhereUniqueWithoutBodegaOrigenInput[]
    createMany?: TrasladoCreateManyBodegaOrigenInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutBodegaOrigenInput | TrasladoUpdateWithWhereUniqueWithoutBodegaOrigenInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutBodegaOrigenInput | TrasladoUpdateManyWithWhereWithoutBodegaOrigenInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type TrasladoUpdateManyWithoutBodegaDestinoNestedInput = {
    create?: XOR<TrasladoCreateWithoutBodegaDestinoInput, TrasladoUncheckedCreateWithoutBodegaDestinoInput> | TrasladoCreateWithoutBodegaDestinoInput[] | TrasladoUncheckedCreateWithoutBodegaDestinoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutBodegaDestinoInput | TrasladoCreateOrConnectWithoutBodegaDestinoInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutBodegaDestinoInput | TrasladoUpsertWithWhereUniqueWithoutBodegaDestinoInput[]
    createMany?: TrasladoCreateManyBodegaDestinoInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutBodegaDestinoInput | TrasladoUpdateWithWhereUniqueWithoutBodegaDestinoInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutBodegaDestinoInput | TrasladoUpdateManyWithWhereWithoutBodegaDestinoInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type UbicacionUpdateOneRequiredWithoutBodegaNestedInput = {
    create?: XOR<UbicacionCreateWithoutBodegaInput, UbicacionUncheckedCreateWithoutBodegaInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutBodegaInput
    upsert?: UbicacionUpsertWithoutBodegaInput
    connect?: UbicacionWhereUniqueInput
    update?: XOR<XOR<UbicacionUpdateToOneWithWhereWithoutBodegaInput, UbicacionUpdateWithoutBodegaInput>, UbicacionUncheckedUpdateWithoutBodegaInput>
  }

  export type UsuarioUncheckedUpdateManyWithoutBodegaNestedInput = {
    create?: XOR<UsuarioCreateWithoutBodegaInput, UsuarioUncheckedCreateWithoutBodegaInput> | UsuarioCreateWithoutBodegaInput[] | UsuarioUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutBodegaInput | UsuarioCreateOrConnectWithoutBodegaInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutBodegaInput | UsuarioUpsertWithWhereUniqueWithoutBodegaInput[]
    createMany?: UsuarioCreateManyBodegaInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutBodegaInput | UsuarioUpdateWithWhereUniqueWithoutBodegaInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutBodegaInput | UsuarioUpdateManyWithWhereWithoutBodegaInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutBodegasNestedInput = {
    create?: XOR<InventarioCreateWithoutBodegasInput, InventarioUncheckedCreateWithoutBodegasInput> | InventarioCreateWithoutBodegasInput[] | InventarioUncheckedCreateWithoutBodegasInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutBodegasInput | InventarioCreateOrConnectWithoutBodegasInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutBodegasInput | InventarioUpsertWithWhereUniqueWithoutBodegasInput[]
    createMany?: InventarioCreateManyBodegasInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutBodegasInput | InventarioUpdateWithWhereUniqueWithoutBodegasInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutBodegasInput | InventarioUpdateManyWithWhereWithoutBodegasInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type DetalleCompraUncheckedUpdateManyWithoutBodegaNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutBodegaInput, DetalleCompraUncheckedCreateWithoutBodegaInput> | DetalleCompraCreateWithoutBodegaInput[] | DetalleCompraUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutBodegaInput | DetalleCompraCreateOrConnectWithoutBodegaInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutBodegaInput | DetalleCompraUpsertWithWhereUniqueWithoutBodegaInput[]
    createMany?: DetalleCompraCreateManyBodegaInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutBodegaInput | DetalleCompraUpdateWithWhereUniqueWithoutBodegaInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutBodegaInput | DetalleCompraUpdateManyWithWhereWithoutBodegaInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type HistorialUncheckedUpdateManyWithoutBodegaNestedInput = {
    create?: XOR<HistorialCreateWithoutBodegaInput, HistorialUncheckedCreateWithoutBodegaInput> | HistorialCreateWithoutBodegaInput[] | HistorialUncheckedCreateWithoutBodegaInput[]
    connectOrCreate?: HistorialCreateOrConnectWithoutBodegaInput | HistorialCreateOrConnectWithoutBodegaInput[]
    upsert?: HistorialUpsertWithWhereUniqueWithoutBodegaInput | HistorialUpsertWithWhereUniqueWithoutBodegaInput[]
    createMany?: HistorialCreateManyBodegaInputEnvelope
    set?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    disconnect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    delete?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    connect?: HistorialWhereUniqueInput | HistorialWhereUniqueInput[]
    update?: HistorialUpdateWithWhereUniqueWithoutBodegaInput | HistorialUpdateWithWhereUniqueWithoutBodegaInput[]
    updateMany?: HistorialUpdateManyWithWhereWithoutBodegaInput | HistorialUpdateManyWithWhereWithoutBodegaInput[]
    deleteMany?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
  }

  export type TrasladoUncheckedUpdateManyWithoutBodegaOrigenNestedInput = {
    create?: XOR<TrasladoCreateWithoutBodegaOrigenInput, TrasladoUncheckedCreateWithoutBodegaOrigenInput> | TrasladoCreateWithoutBodegaOrigenInput[] | TrasladoUncheckedCreateWithoutBodegaOrigenInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutBodegaOrigenInput | TrasladoCreateOrConnectWithoutBodegaOrigenInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutBodegaOrigenInput | TrasladoUpsertWithWhereUniqueWithoutBodegaOrigenInput[]
    createMany?: TrasladoCreateManyBodegaOrigenInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutBodegaOrigenInput | TrasladoUpdateWithWhereUniqueWithoutBodegaOrigenInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutBodegaOrigenInput | TrasladoUpdateManyWithWhereWithoutBodegaOrigenInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type TrasladoUncheckedUpdateManyWithoutBodegaDestinoNestedInput = {
    create?: XOR<TrasladoCreateWithoutBodegaDestinoInput, TrasladoUncheckedCreateWithoutBodegaDestinoInput> | TrasladoCreateWithoutBodegaDestinoInput[] | TrasladoUncheckedCreateWithoutBodegaDestinoInput[]
    connectOrCreate?: TrasladoCreateOrConnectWithoutBodegaDestinoInput | TrasladoCreateOrConnectWithoutBodegaDestinoInput[]
    upsert?: TrasladoUpsertWithWhereUniqueWithoutBodegaDestinoInput | TrasladoUpsertWithWhereUniqueWithoutBodegaDestinoInput[]
    createMany?: TrasladoCreateManyBodegaDestinoInputEnvelope
    set?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    disconnect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    delete?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    connect?: TrasladoWhereUniqueInput | TrasladoWhereUniqueInput[]
    update?: TrasladoUpdateWithWhereUniqueWithoutBodegaDestinoInput | TrasladoUpdateWithWhereUniqueWithoutBodegaDestinoInput[]
    updateMany?: TrasladoUpdateManyWithWhereWithoutBodegaDestinoInput | TrasladoUpdateManyWithWhereWithoutBodegaDestinoInput[]
    deleteMany?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
  }

  export type BodegaCreateNestedOneWithoutInventarioInput = {
    create?: XOR<BodegaCreateWithoutInventarioInput, BodegaUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutInventarioInput
    connect?: BodegaWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutBodegaProductosInput = {
    create?: XOR<ProductoCreateWithoutBodegaProductosInput, ProductoUncheckedCreateWithoutBodegaProductosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutBodegaProductosInput
    connect?: ProductoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutInvUsuarioRegistroInput = {
    create?: XOR<UsuarioCreateWithoutInvUsuarioRegistroInput, UsuarioUncheckedCreateWithoutInvUsuarioRegistroInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutInvUsuarioRegistroInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutInvUsuarioActualizoInput = {
    create?: XOR<UsuarioCreateWithoutInvUsuarioActualizoInput, UsuarioUncheckedCreateWithoutInvUsuarioActualizoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutInvUsuarioActualizoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type BodegaUpdateOneRequiredWithoutInventarioNestedInput = {
    create?: XOR<BodegaCreateWithoutInventarioInput, BodegaUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutInventarioInput
    upsert?: BodegaUpsertWithoutInventarioInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutInventarioInput, BodegaUpdateWithoutInventarioInput>, BodegaUncheckedUpdateWithoutInventarioInput>
  }

  export type ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput = {
    create?: XOR<ProductoCreateWithoutBodegaProductosInput, ProductoUncheckedCreateWithoutBodegaProductosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutBodegaProductosInput
    upsert?: ProductoUpsertWithoutBodegaProductosInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutBodegaProductosInput, ProductoUpdateWithoutBodegaProductosInput>, ProductoUncheckedUpdateWithoutBodegaProductosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutInvUsuarioRegistroNestedInput = {
    create?: XOR<UsuarioCreateWithoutInvUsuarioRegistroInput, UsuarioUncheckedCreateWithoutInvUsuarioRegistroInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutInvUsuarioRegistroInput
    upsert?: UsuarioUpsertWithoutInvUsuarioRegistroInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutInvUsuarioRegistroInput, UsuarioUpdateWithoutInvUsuarioRegistroInput>, UsuarioUncheckedUpdateWithoutInvUsuarioRegistroInput>
  }

  export type UsuarioUpdateOneRequiredWithoutInvUsuarioActualizoNestedInput = {
    create?: XOR<UsuarioCreateWithoutInvUsuarioActualizoInput, UsuarioUncheckedCreateWithoutInvUsuarioActualizoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutInvUsuarioActualizoInput
    upsert?: UsuarioUpsertWithoutInvUsuarioActualizoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutInvUsuarioActualizoInput, UsuarioUpdateWithoutInvUsuarioActualizoInput>, UsuarioUncheckedUpdateWithoutInvUsuarioActualizoInput>
  }

  export type EncabezadoCompraCreateNestedManyWithoutProveedorInput = {
    create?: XOR<EncabezadoCompraCreateWithoutProveedorInput, EncabezadoCompraUncheckedCreateWithoutProveedorInput> | EncabezadoCompraCreateWithoutProveedorInput[] | EncabezadoCompraUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutProveedorInput | EncabezadoCompraCreateOrConnectWithoutProveedorInput[]
    createMany?: EncabezadoCompraCreateManyProveedorInputEnvelope
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
  }

  export type UbicacionCreateNestedOneWithoutProveedorInput = {
    create?: XOR<UbicacionCreateWithoutProveedorInput, UbicacionUncheckedCreateWithoutProveedorInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutProveedorInput
    connect?: UbicacionWhereUniqueInput
  }

  export type EncabezadoCompraUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<EncabezadoCompraCreateWithoutProveedorInput, EncabezadoCompraUncheckedCreateWithoutProveedorInput> | EncabezadoCompraCreateWithoutProveedorInput[] | EncabezadoCompraUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutProveedorInput | EncabezadoCompraCreateOrConnectWithoutProveedorInput[]
    createMany?: EncabezadoCompraCreateManyProveedorInputEnvelope
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
  }

  export type EncabezadoCompraUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutProveedorInput, EncabezadoCompraUncheckedCreateWithoutProveedorInput> | EncabezadoCompraCreateWithoutProveedorInput[] | EncabezadoCompraUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutProveedorInput | EncabezadoCompraCreateOrConnectWithoutProveedorInput[]
    upsert?: EncabezadoCompraUpsertWithWhereUniqueWithoutProveedorInput | EncabezadoCompraUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: EncabezadoCompraCreateManyProveedorInputEnvelope
    set?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    disconnect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    delete?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    update?: EncabezadoCompraUpdateWithWhereUniqueWithoutProveedorInput | EncabezadoCompraUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: EncabezadoCompraUpdateManyWithWhereWithoutProveedorInput | EncabezadoCompraUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
  }

  export type UbicacionUpdateOneRequiredWithoutProveedorNestedInput = {
    create?: XOR<UbicacionCreateWithoutProveedorInput, UbicacionUncheckedCreateWithoutProveedorInput>
    connectOrCreate?: UbicacionCreateOrConnectWithoutProveedorInput
    upsert?: UbicacionUpsertWithoutProveedorInput
    connect?: UbicacionWhereUniqueInput
    update?: XOR<XOR<UbicacionUpdateToOneWithWhereWithoutProveedorInput, UbicacionUpdateWithoutProveedorInput>, UbicacionUncheckedUpdateWithoutProveedorInput>
  }

  export type EncabezadoCompraUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutProveedorInput, EncabezadoCompraUncheckedCreateWithoutProveedorInput> | EncabezadoCompraCreateWithoutProveedorInput[] | EncabezadoCompraUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutProveedorInput | EncabezadoCompraCreateOrConnectWithoutProveedorInput[]
    upsert?: EncabezadoCompraUpsertWithWhereUniqueWithoutProveedorInput | EncabezadoCompraUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: EncabezadoCompraCreateManyProveedorInputEnvelope
    set?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    disconnect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    delete?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    connect?: EncabezadoCompraWhereUniqueInput | EncabezadoCompraWhereUniqueInput[]
    update?: EncabezadoCompraUpdateWithWhereUniqueWithoutProveedorInput | EncabezadoCompraUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: EncabezadoCompraUpdateManyWithWhereWithoutProveedorInput | EncabezadoCompraUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutEncabezadoComprasInput = {
    create?: XOR<UsuarioCreateWithoutEncabezadoComprasInput, UsuarioUncheckedCreateWithoutEncabezadoComprasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEncabezadoComprasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ProveedorCreateNestedOneWithoutEncabezadoCompraInput = {
    create?: XOR<ProveedorCreateWithoutEncabezadoCompraInput, ProveedorUncheckedCreateWithoutEncabezadoCompraInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutEncabezadoCompraInput
    connect?: ProveedorWhereUniqueInput
  }

  export type DetalleCompraCreateNestedManyWithoutEncabezadoCompraInput = {
    create?: XOR<DetalleCompraCreateWithoutEncabezadoCompraInput, DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput> | DetalleCompraCreateWithoutEncabezadoCompraInput[] | DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput | DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput[]
    createMany?: DetalleCompraCreateManyEncabezadoCompraInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type PedidoCreateNestedManyWithoutEncabezadoCompraInput = {
    create?: XOR<PedidoCreateWithoutEncabezadoCompraInput, PedidoUncheckedCreateWithoutEncabezadoCompraInput> | PedidoCreateWithoutEncabezadoCompraInput[] | PedidoUncheckedCreateWithoutEncabezadoCompraInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEncabezadoCompraInput | PedidoCreateOrConnectWithoutEncabezadoCompraInput[]
    createMany?: PedidoCreateManyEncabezadoCompraInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoCompraInput = {
    create?: XOR<DetalleCompraCreateWithoutEncabezadoCompraInput, DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput> | DetalleCompraCreateWithoutEncabezadoCompraInput[] | DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput | DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput[]
    createMany?: DetalleCompraCreateManyEncabezadoCompraInputEnvelope
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutEncabezadoCompraInput = {
    create?: XOR<PedidoCreateWithoutEncabezadoCompraInput, PedidoUncheckedCreateWithoutEncabezadoCompraInput> | PedidoCreateWithoutEncabezadoCompraInput[] | PedidoUncheckedCreateWithoutEncabezadoCompraInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEncabezadoCompraInput | PedidoCreateOrConnectWithoutEncabezadoCompraInput[]
    createMany?: PedidoCreateManyEncabezadoCompraInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput = {
    create?: XOR<UsuarioCreateWithoutEncabezadoComprasInput, UsuarioUncheckedCreateWithoutEncabezadoComprasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEncabezadoComprasInput
    upsert?: UsuarioUpsertWithoutEncabezadoComprasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEncabezadoComprasInput, UsuarioUpdateWithoutEncabezadoComprasInput>, UsuarioUncheckedUpdateWithoutEncabezadoComprasInput>
  }

  export type ProveedorUpdateOneRequiredWithoutEncabezadoCompraNestedInput = {
    create?: XOR<ProveedorCreateWithoutEncabezadoCompraInput, ProveedorUncheckedCreateWithoutEncabezadoCompraInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutEncabezadoCompraInput
    upsert?: ProveedorUpsertWithoutEncabezadoCompraInput
    connect?: ProveedorWhereUniqueInput
    update?: XOR<XOR<ProveedorUpdateToOneWithWhereWithoutEncabezadoCompraInput, ProveedorUpdateWithoutEncabezadoCompraInput>, ProveedorUncheckedUpdateWithoutEncabezadoCompraInput>
  }

  export type DetalleCompraUpdateManyWithoutEncabezadoCompraNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutEncabezadoCompraInput, DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput> | DetalleCompraCreateWithoutEncabezadoCompraInput[] | DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput | DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoCompraInput | DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoCompraInput[]
    createMany?: DetalleCompraCreateManyEncabezadoCompraInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoCompraInput | DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoCompraInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutEncabezadoCompraInput | DetalleCompraUpdateManyWithWhereWithoutEncabezadoCompraInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type PedidoUpdateManyWithoutEncabezadoCompraNestedInput = {
    create?: XOR<PedidoCreateWithoutEncabezadoCompraInput, PedidoUncheckedCreateWithoutEncabezadoCompraInput> | PedidoCreateWithoutEncabezadoCompraInput[] | PedidoUncheckedCreateWithoutEncabezadoCompraInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEncabezadoCompraInput | PedidoCreateOrConnectWithoutEncabezadoCompraInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutEncabezadoCompraInput | PedidoUpsertWithWhereUniqueWithoutEncabezadoCompraInput[]
    createMany?: PedidoCreateManyEncabezadoCompraInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutEncabezadoCompraInput | PedidoUpdateWithWhereUniqueWithoutEncabezadoCompraInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutEncabezadoCompraInput | PedidoUpdateManyWithWhereWithoutEncabezadoCompraInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type DetalleCompraUncheckedUpdateManyWithoutEncabezadoCompraNestedInput = {
    create?: XOR<DetalleCompraCreateWithoutEncabezadoCompraInput, DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput> | DetalleCompraCreateWithoutEncabezadoCompraInput[] | DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput[]
    connectOrCreate?: DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput | DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput[]
    upsert?: DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoCompraInput | DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoCompraInput[]
    createMany?: DetalleCompraCreateManyEncabezadoCompraInputEnvelope
    set?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    disconnect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    delete?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    connect?: DetalleCompraWhereUniqueInput | DetalleCompraWhereUniqueInput[]
    update?: DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoCompraInput | DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoCompraInput[]
    updateMany?: DetalleCompraUpdateManyWithWhereWithoutEncabezadoCompraInput | DetalleCompraUpdateManyWithWhereWithoutEncabezadoCompraInput[]
    deleteMany?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutEncabezadoCompraNestedInput = {
    create?: XOR<PedidoCreateWithoutEncabezadoCompraInput, PedidoUncheckedCreateWithoutEncabezadoCompraInput> | PedidoCreateWithoutEncabezadoCompraInput[] | PedidoUncheckedCreateWithoutEncabezadoCompraInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutEncabezadoCompraInput | PedidoCreateOrConnectWithoutEncabezadoCompraInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutEncabezadoCompraInput | PedidoUpsertWithWhereUniqueWithoutEncabezadoCompraInput[]
    createMany?: PedidoCreateManyEncabezadoCompraInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutEncabezadoCompraInput | PedidoUpdateWithWhereUniqueWithoutEncabezadoCompraInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutEncabezadoCompraInput | PedidoUpdateManyWithWhereWithoutEncabezadoCompraInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type ProductoCreateNestedOneWithoutDetalleComprasInput = {
    create?: XOR<ProductoCreateWithoutDetalleComprasInput, ProductoUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetalleComprasInput
    connect?: ProductoWhereUniqueInput
  }

  export type EncabezadoCompraCreateNestedOneWithoutDetalleCompraInput = {
    create?: XOR<EncabezadoCompraCreateWithoutDetalleCompraInput, EncabezadoCompraUncheckedCreateWithoutDetalleCompraInput>
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutDetalleCompraInput
    connect?: EncabezadoCompraWhereUniqueInput
  }

  export type BodegaCreateNestedOneWithoutDetalleCompraInput = {
    create?: XOR<BodegaCreateWithoutDetalleCompraInput, BodegaUncheckedCreateWithoutDetalleCompraInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutDetalleCompraInput
    connect?: BodegaWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutDetalleComprasNestedInput = {
    create?: XOR<ProductoCreateWithoutDetalleComprasInput, ProductoUncheckedCreateWithoutDetalleComprasInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetalleComprasInput
    upsert?: ProductoUpsertWithoutDetalleComprasInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutDetalleComprasInput, ProductoUpdateWithoutDetalleComprasInput>, ProductoUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type EncabezadoCompraUpdateOneRequiredWithoutDetalleCompraNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutDetalleCompraInput, EncabezadoCompraUncheckedCreateWithoutDetalleCompraInput>
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutDetalleCompraInput
    upsert?: EncabezadoCompraUpsertWithoutDetalleCompraInput
    connect?: EncabezadoCompraWhereUniqueInput
    update?: XOR<XOR<EncabezadoCompraUpdateToOneWithWhereWithoutDetalleCompraInput, EncabezadoCompraUpdateWithoutDetalleCompraInput>, EncabezadoCompraUncheckedUpdateWithoutDetalleCompraInput>
  }

  export type BodegaUpdateOneRequiredWithoutDetalleCompraNestedInput = {
    create?: XOR<BodegaCreateWithoutDetalleCompraInput, BodegaUncheckedCreateWithoutDetalleCompraInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutDetalleCompraInput
    upsert?: BodegaUpsertWithoutDetalleCompraInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutDetalleCompraInput, BodegaUpdateWithoutDetalleCompraInput>, BodegaUncheckedUpdateWithoutDetalleCompraInput>
  }

  export type EstadoCreateNestedOneWithoutPedidosInput = {
    create?: XOR<EstadoCreateWithoutPedidosInput, EstadoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutPedidosInput
    connect?: EstadoWhereUniqueInput
  }

  export type EncabezadoCompraCreateNestedOneWithoutPedidoInput = {
    create?: XOR<EncabezadoCompraCreateWithoutPedidoInput, EncabezadoCompraUncheckedCreateWithoutPedidoInput>
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutPedidoInput
    connect?: EncabezadoCompraWhereUniqueInput
  }

  export type EstadoUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<EstadoCreateWithoutPedidosInput, EstadoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutPedidosInput
    upsert?: EstadoUpsertWithoutPedidosInput
    connect?: EstadoWhereUniqueInput
    update?: XOR<XOR<EstadoUpdateToOneWithWhereWithoutPedidosInput, EstadoUpdateWithoutPedidosInput>, EstadoUncheckedUpdateWithoutPedidosInput>
  }

  export type EncabezadoCompraUpdateOneRequiredWithoutPedidoNestedInput = {
    create?: XOR<EncabezadoCompraCreateWithoutPedidoInput, EncabezadoCompraUncheckedCreateWithoutPedidoInput>
    connectOrCreate?: EncabezadoCompraCreateOrConnectWithoutPedidoInput
    upsert?: EncabezadoCompraUpsertWithoutPedidoInput
    connect?: EncabezadoCompraWhereUniqueInput
    update?: XOR<XOR<EncabezadoCompraUpdateToOneWithWhereWithoutPedidoInput, EncabezadoCompraUpdateWithoutPedidoInput>, EncabezadoCompraUncheckedUpdateWithoutPedidoInput>
  }

  export type BodegaCreateNestedOneWithoutTrasladoOrigenInput = {
    create?: XOR<BodegaCreateWithoutTrasladoOrigenInput, BodegaUncheckedCreateWithoutTrasladoOrigenInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutTrasladoOrigenInput
    connect?: BodegaWhereUniqueInput
  }

  export type BodegaCreateNestedOneWithoutTrasladoDestinoInput = {
    create?: XOR<BodegaCreateWithoutTrasladoDestinoInput, BodegaUncheckedCreateWithoutTrasladoDestinoInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutTrasladoDestinoInput
    connect?: BodegaWhereUniqueInput
  }

  export type EstadoCreateNestedOneWithoutTrasladoInput = {
    create?: XOR<EstadoCreateWithoutTrasladoInput, EstadoUncheckedCreateWithoutTrasladoInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutTrasladoInput
    connect?: EstadoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutTrasladoInput = {
    create?: XOR<UsuarioCreateWithoutTrasladoInput, UsuarioUncheckedCreateWithoutTrasladoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTrasladoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutTrasladoInput = {
    create?: XOR<ProductoCreateWithoutTrasladoInput, ProductoUncheckedCreateWithoutTrasladoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutTrasladoInput
    connect?: ProductoWhereUniqueInput
  }

  export type BodegaUpdateOneRequiredWithoutTrasladoOrigenNestedInput = {
    create?: XOR<BodegaCreateWithoutTrasladoOrigenInput, BodegaUncheckedCreateWithoutTrasladoOrigenInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutTrasladoOrigenInput
    upsert?: BodegaUpsertWithoutTrasladoOrigenInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutTrasladoOrigenInput, BodegaUpdateWithoutTrasladoOrigenInput>, BodegaUncheckedUpdateWithoutTrasladoOrigenInput>
  }

  export type BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput = {
    create?: XOR<BodegaCreateWithoutTrasladoDestinoInput, BodegaUncheckedCreateWithoutTrasladoDestinoInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutTrasladoDestinoInput
    upsert?: BodegaUpsertWithoutTrasladoDestinoInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutTrasladoDestinoInput, BodegaUpdateWithoutTrasladoDestinoInput>, BodegaUncheckedUpdateWithoutTrasladoDestinoInput>
  }

  export type EstadoUpdateOneRequiredWithoutTrasladoNestedInput = {
    create?: XOR<EstadoCreateWithoutTrasladoInput, EstadoUncheckedCreateWithoutTrasladoInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutTrasladoInput
    upsert?: EstadoUpsertWithoutTrasladoInput
    connect?: EstadoWhereUniqueInput
    update?: XOR<XOR<EstadoUpdateToOneWithWhereWithoutTrasladoInput, EstadoUpdateWithoutTrasladoInput>, EstadoUncheckedUpdateWithoutTrasladoInput>
  }

  export type UsuarioUpdateOneWithoutTrasladoNestedInput = {
    create?: XOR<UsuarioCreateWithoutTrasladoInput, UsuarioUncheckedCreateWithoutTrasladoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTrasladoInput
    upsert?: UsuarioUpsertWithoutTrasladoInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutTrasladoInput, UsuarioUpdateWithoutTrasladoInput>, UsuarioUncheckedUpdateWithoutTrasladoInput>
  }

  export type ProductoUpdateOneRequiredWithoutTrasladoNestedInput = {
    create?: XOR<ProductoCreateWithoutTrasladoInput, ProductoUncheckedCreateWithoutTrasladoInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutTrasladoInput
    upsert?: ProductoUpsertWithoutTrasladoInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutTrasladoInput, ProductoUpdateWithoutTrasladoInput>, ProductoUncheckedUpdateWithoutTrasladoInput>
  }

  export type ProductoCreateNestedOneWithoutHistorialInput = {
    create?: XOR<ProductoCreateWithoutHistorialInput, ProductoUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutHistorialInput
    connect?: ProductoWhereUniqueInput
  }

  export type BodegaCreateNestedOneWithoutHistorialInput = {
    create?: XOR<BodegaCreateWithoutHistorialInput, BodegaUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutHistorialInput
    connect?: BodegaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutHistorialInput = {
    create?: XOR<UsuarioCreateWithoutHistorialInput, UsuarioUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHistorialInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutHistorialNestedInput = {
    create?: XOR<ProductoCreateWithoutHistorialInput, ProductoUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutHistorialInput
    upsert?: ProductoUpsertWithoutHistorialInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutHistorialInput, ProductoUpdateWithoutHistorialInput>, ProductoUncheckedUpdateWithoutHistorialInput>
  }

  export type BodegaUpdateOneRequiredWithoutHistorialNestedInput = {
    create?: XOR<BodegaCreateWithoutHistorialInput, BodegaUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: BodegaCreateOrConnectWithoutHistorialInput
    upsert?: BodegaUpsertWithoutHistorialInput
    connect?: BodegaWhereUniqueInput
    update?: XOR<XOR<BodegaUpdateToOneWithWhereWithoutHistorialInput, BodegaUpdateWithoutHistorialInput>, BodegaUncheckedUpdateWithoutHistorialInput>
  }

  export type UsuarioUpdateOneRequiredWithoutHistorialNestedInput = {
    create?: XOR<UsuarioCreateWithoutHistorialInput, UsuarioUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHistorialInput
    upsert?: UsuarioUpsertWithoutHistorialInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutHistorialInput, UsuarioUpdateWithoutHistorialInput>, UsuarioUncheckedUpdateWithoutHistorialInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EncabezadoCompraCreateWithoutUsuarioInput = {
    fechaCompra?: Date | string
    proveedor: ProveedorCreateNestedOneWithoutEncabezadoCompraInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutEncabezadoCompraInput
    pedido?: PedidoCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraUncheckedCreateWithoutUsuarioInput = {
    id?: number
    fechaCompra?: Date | string
    idProveedor: number
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoCompraInput
    pedido?: PedidoUncheckedCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraCreateOrConnectWithoutUsuarioInput = {
    where: EncabezadoCompraWhereUniqueInput
    create: XOR<EncabezadoCompraCreateWithoutUsuarioInput, EncabezadoCompraUncheckedCreateWithoutUsuarioInput>
  }

  export type EncabezadoCompraCreateManyUsuarioInputEnvelope = {
    data: EncabezadoCompraCreateManyUsuarioInput | EncabezadoCompraCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type TrasladoCreateWithoutUsuarioInput = {
    cantidad: number
    fechaRegistro?: Date | string
    bodegaOrigen: BodegaCreateNestedOneWithoutTrasladoOrigenInput
    bodegaDestino: BodegaCreateNestedOneWithoutTrasladoDestinoInput
    estadoDestino: EstadoCreateNestedOneWithoutTrasladoInput
    producto: ProductoCreateNestedOneWithoutTrasladoInput
  }

  export type TrasladoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type TrasladoCreateOrConnectWithoutUsuarioInput = {
    where: TrasladoWhereUniqueInput
    create: XOR<TrasladoCreateWithoutUsuarioInput, TrasladoUncheckedCreateWithoutUsuarioInput>
  }

  export type TrasladoCreateManyUsuarioInputEnvelope = {
    data: TrasladoCreateManyUsuarioInput | TrasladoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type HistorialCreateWithoutUsuarioRegistroInput = {
    justificacion: string
    fechaAjuste?: Date | string
    producto: ProductoCreateNestedOneWithoutHistorialInput
    bodega: BodegaCreateNestedOneWithoutHistorialInput
  }

  export type HistorialUncheckedCreateWithoutUsuarioRegistroInput = {
    id?: number
    idBodega: number
    idProducto: number
    justificacion: string
    fechaAjuste?: Date | string
  }

  export type HistorialCreateOrConnectWithoutUsuarioRegistroInput = {
    where: HistorialWhereUniqueInput
    create: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput>
  }

  export type HistorialCreateManyUsuarioRegistroInputEnvelope = {
    data: HistorialCreateManyUsuarioRegistroInput | HistorialCreateManyUsuarioRegistroInput[]
    skipDuplicates?: boolean
  }

  export type InventarioCreateWithoutUsuarioRegistroInput = {
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
    bodegas: BodegaCreateNestedOneWithoutInventarioInput
    producto: ProductoCreateNestedOneWithoutBodegaProductosInput
    usuarioActualizo: UsuarioCreateNestedOneWithoutInvUsuarioActualizoInput
  }

  export type InventarioUncheckedCreateWithoutUsuarioRegistroInput = {
    idBodega: number
    idProducto: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type InventarioCreateOrConnectWithoutUsuarioRegistroInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutUsuarioRegistroInput, InventarioUncheckedCreateWithoutUsuarioRegistroInput>
  }

  export type InventarioCreateManyUsuarioRegistroInputEnvelope = {
    data: InventarioCreateManyUsuarioRegistroInput | InventarioCreateManyUsuarioRegistroInput[]
    skipDuplicates?: boolean
  }

  export type InventarioCreateWithoutUsuarioActualizoInput = {
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
    bodegas: BodegaCreateNestedOneWithoutInventarioInput
    producto: ProductoCreateNestedOneWithoutBodegaProductosInput
    usuarioRegistro: UsuarioCreateNestedOneWithoutInvUsuarioRegistroInput
  }

  export type InventarioUncheckedCreateWithoutUsuarioActualizoInput = {
    idBodega: number
    idProducto: number
    idUsuarioRegistro: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type InventarioCreateOrConnectWithoutUsuarioActualizoInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutUsuarioActualizoInput, InventarioUncheckedCreateWithoutUsuarioActualizoInput>
  }

  export type InventarioCreateManyUsuarioActualizoInputEnvelope = {
    data: InventarioCreateManyUsuarioActualizoInput | InventarioCreateManyUsuarioActualizoInput[]
    skipDuplicates?: boolean
  }

  export type BodegaCreateWithoutUsuarioInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    inventario?: InventarioCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutBodegaInput
    Historial?: HistorialCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoCreateNestedManyWithoutBodegaDestinoInput
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
  }

  export type BodegaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    inventario?: InventarioUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutBodegaInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoUncheckedCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoUncheckedCreateNestedManyWithoutBodegaDestinoInput
  }

  export type BodegaCreateOrConnectWithoutUsuarioInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutUsuarioInput, BodegaUncheckedCreateWithoutUsuarioInput>
  }

  export type EncabezadoCompraUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EncabezadoCompraWhereUniqueInput
    update: XOR<EncabezadoCompraUpdateWithoutUsuarioInput, EncabezadoCompraUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EncabezadoCompraCreateWithoutUsuarioInput, EncabezadoCompraUncheckedCreateWithoutUsuarioInput>
  }

  export type EncabezadoCompraUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EncabezadoCompraWhereUniqueInput
    data: XOR<EncabezadoCompraUpdateWithoutUsuarioInput, EncabezadoCompraUncheckedUpdateWithoutUsuarioInput>
  }

  export type EncabezadoCompraUpdateManyWithWhereWithoutUsuarioInput = {
    where: EncabezadoCompraScalarWhereInput
    data: XOR<EncabezadoCompraUpdateManyMutationInput, EncabezadoCompraUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type EncabezadoCompraScalarWhereInput = {
    AND?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
    OR?: EncabezadoCompraScalarWhereInput[]
    NOT?: EncabezadoCompraScalarWhereInput | EncabezadoCompraScalarWhereInput[]
    id?: IntFilter<"EncabezadoCompra"> | number
    fechaCompra?: DateTimeFilter<"EncabezadoCompra"> | Date | string
    idProveedor?: IntFilter<"EncabezadoCompra"> | number
    idUsuario?: IntFilter<"EncabezadoCompra"> | number
  }

  export type TrasladoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: TrasladoWhereUniqueInput
    update: XOR<TrasladoUpdateWithoutUsuarioInput, TrasladoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<TrasladoCreateWithoutUsuarioInput, TrasladoUncheckedCreateWithoutUsuarioInput>
  }

  export type TrasladoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: TrasladoWhereUniqueInput
    data: XOR<TrasladoUpdateWithoutUsuarioInput, TrasladoUncheckedUpdateWithoutUsuarioInput>
  }

  export type TrasladoUpdateManyWithWhereWithoutUsuarioInput = {
    where: TrasladoScalarWhereInput
    data: XOR<TrasladoUpdateManyMutationInput, TrasladoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type TrasladoScalarWhereInput = {
    AND?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
    OR?: TrasladoScalarWhereInput[]
    NOT?: TrasladoScalarWhereInput | TrasladoScalarWhereInput[]
    id?: IntFilter<"Traslado"> | number
    idBodegaOrigen?: IntFilter<"Traslado"> | number
    idBodegaDestino?: IntFilter<"Traslado"> | number
    idUsuario?: IntNullableFilter<"Traslado"> | number | null
    idProducto?: IntFilter<"Traslado"> | number
    cantidad?: IntFilter<"Traslado"> | number
    idEstado?: IntFilter<"Traslado"> | number
    fechaRegistro?: DateTimeFilter<"Traslado"> | Date | string
  }

  export type HistorialUpsertWithWhereUniqueWithoutUsuarioRegistroInput = {
    where: HistorialWhereUniqueInput
    update: XOR<HistorialUpdateWithoutUsuarioRegistroInput, HistorialUncheckedUpdateWithoutUsuarioRegistroInput>
    create: XOR<HistorialCreateWithoutUsuarioRegistroInput, HistorialUncheckedCreateWithoutUsuarioRegistroInput>
  }

  export type HistorialUpdateWithWhereUniqueWithoutUsuarioRegistroInput = {
    where: HistorialWhereUniqueInput
    data: XOR<HistorialUpdateWithoutUsuarioRegistroInput, HistorialUncheckedUpdateWithoutUsuarioRegistroInput>
  }

  export type HistorialUpdateManyWithWhereWithoutUsuarioRegistroInput = {
    where: HistorialScalarWhereInput
    data: XOR<HistorialUpdateManyMutationInput, HistorialUncheckedUpdateManyWithoutUsuarioRegistroInput>
  }

  export type HistorialScalarWhereInput = {
    AND?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
    OR?: HistorialScalarWhereInput[]
    NOT?: HistorialScalarWhereInput | HistorialScalarWhereInput[]
    id?: IntFilter<"Historial"> | number
    idBodega?: IntFilter<"Historial"> | number
    idUsuarioRegistro?: IntFilter<"Historial"> | number
    idProducto?: IntFilter<"Historial"> | number
    justificacion?: StringFilter<"Historial"> | string
    fechaAjuste?: DateTimeFilter<"Historial"> | Date | string
  }

  export type InventarioUpsertWithWhereUniqueWithoutUsuarioRegistroInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutUsuarioRegistroInput, InventarioUncheckedUpdateWithoutUsuarioRegistroInput>
    create: XOR<InventarioCreateWithoutUsuarioRegistroInput, InventarioUncheckedCreateWithoutUsuarioRegistroInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutUsuarioRegistroInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutUsuarioRegistroInput, InventarioUncheckedUpdateWithoutUsuarioRegistroInput>
  }

  export type InventarioUpdateManyWithWhereWithoutUsuarioRegistroInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutUsuarioRegistroInput>
  }

  export type InventarioScalarWhereInput = {
    AND?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
    OR?: InventarioScalarWhereInput[]
    NOT?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
    idBodega?: IntFilter<"Inventario"> | number
    idProducto?: IntFilter<"Inventario"> | number
    idUsuarioRegistro?: IntFilter<"Inventario"> | number
    idUsuarioActualizo?: IntFilter<"Inventario"> | number
    cantidad?: IntFilter<"Inventario"> | number
    cantidadMinima?: IntFilter<"Inventario"> | number
    cantidadMaxima?: IntFilter<"Inventario"> | number
    fechaRegistro?: DateTimeFilter<"Inventario"> | Date | string
  }

  export type InventarioUpsertWithWhereUniqueWithoutUsuarioActualizoInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutUsuarioActualizoInput, InventarioUncheckedUpdateWithoutUsuarioActualizoInput>
    create: XOR<InventarioCreateWithoutUsuarioActualizoInput, InventarioUncheckedCreateWithoutUsuarioActualizoInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutUsuarioActualizoInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutUsuarioActualizoInput, InventarioUncheckedUpdateWithoutUsuarioActualizoInput>
  }

  export type InventarioUpdateManyWithWhereWithoutUsuarioActualizoInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutUsuarioActualizoInput>
  }

  export type BodegaUpsertWithoutUsuarioInput = {
    update: XOR<BodegaUpdateWithoutUsuarioInput, BodegaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<BodegaCreateWithoutUsuarioInput, BodegaUncheckedCreateWithoutUsuarioInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutUsuarioInput, BodegaUncheckedUpdateWithoutUsuarioInput>
  }

  export type BodegaUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    inventario?: InventarioUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUpdateManyWithoutBodegaDestinoNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
  }

  export type BodegaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    inventario?: InventarioUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUncheckedUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUncheckedUpdateManyWithoutBodegaDestinoNestedInput
  }

  export type PedidoCreateWithoutEstadoPedidoInput = {
    observaciones?: string | null
    fechaPedido?: Date | string
    encabezadoCompra: EncabezadoCompraCreateNestedOneWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutEstadoPedidoInput = {
    idEncabezadoCompra: number
    observaciones?: string | null
    fechaPedido?: Date | string
  }

  export type PedidoCreateOrConnectWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput>
  }

  export type PedidoCreateManyEstadoPedidoInputEnvelope = {
    data: PedidoCreateManyEstadoPedidoInput | PedidoCreateManyEstadoPedidoInput[]
    skipDuplicates?: boolean
  }

  export type TrasladoCreateWithoutEstadoDestinoInput = {
    cantidad: number
    fechaRegistro?: Date | string
    bodegaOrigen: BodegaCreateNestedOneWithoutTrasladoOrigenInput
    bodegaDestino: BodegaCreateNestedOneWithoutTrasladoDestinoInput
    usuario?: UsuarioCreateNestedOneWithoutTrasladoInput
    producto: ProductoCreateNestedOneWithoutTrasladoInput
  }

  export type TrasladoUncheckedCreateWithoutEstadoDestinoInput = {
    id?: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idUsuario?: number | null
    idProducto: number
    cantidad: number
    fechaRegistro?: Date | string
  }

  export type TrasladoCreateOrConnectWithoutEstadoDestinoInput = {
    where: TrasladoWhereUniqueInput
    create: XOR<TrasladoCreateWithoutEstadoDestinoInput, TrasladoUncheckedCreateWithoutEstadoDestinoInput>
  }

  export type TrasladoCreateManyEstadoDestinoInputEnvelope = {
    data: TrasladoCreateManyEstadoDestinoInput | TrasladoCreateManyEstadoDestinoInput[]
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutEstadoPedidoInput, PedidoUncheckedUpdateWithoutEstadoPedidoInput>
    create: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutEstadoPedidoInput, PedidoUncheckedUpdateWithoutEstadoPedidoInput>
  }

  export type PedidoUpdateManyWithWhereWithoutEstadoPedidoInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutEstadoPedidoInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    OR?: PedidoScalarWhereInput[]
    NOT?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    idEncabezadoCompra?: IntFilter<"Pedido"> | number
    idEstado?: IntFilter<"Pedido"> | number
    observaciones?: StringNullableFilter<"Pedido"> | string | null
    fechaPedido?: DateTimeFilter<"Pedido"> | Date | string
  }

  export type TrasladoUpsertWithWhereUniqueWithoutEstadoDestinoInput = {
    where: TrasladoWhereUniqueInput
    update: XOR<TrasladoUpdateWithoutEstadoDestinoInput, TrasladoUncheckedUpdateWithoutEstadoDestinoInput>
    create: XOR<TrasladoCreateWithoutEstadoDestinoInput, TrasladoUncheckedCreateWithoutEstadoDestinoInput>
  }

  export type TrasladoUpdateWithWhereUniqueWithoutEstadoDestinoInput = {
    where: TrasladoWhereUniqueInput
    data: XOR<TrasladoUpdateWithoutEstadoDestinoInput, TrasladoUncheckedUpdateWithoutEstadoDestinoInput>
  }

  export type TrasladoUpdateManyWithWhereWithoutEstadoDestinoInput = {
    where: TrasladoScalarWhereInput
    data: XOR<TrasladoUpdateManyMutationInput, TrasladoUncheckedUpdateManyWithoutEstadoDestinoInput>
  }

  export type SubCategoriaCreateWithoutCategoriasInput = {
    nombre: string
    producto?: ProductoCreateNestedManyWithoutSubCategoriasInput
  }

  export type SubCategoriaUncheckedCreateWithoutCategoriasInput = {
    id?: number
    nombre: string
    producto?: ProductoUncheckedCreateNestedManyWithoutSubCategoriasInput
  }

  export type SubCategoriaCreateOrConnectWithoutCategoriasInput = {
    where: SubCategoriaWhereUniqueInput
    create: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput>
  }

  export type ProductoCreateWithoutCategoriaInput = {
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    foto?: FotoCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductoInput
    Historial?: HistorialCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoCreateNestedManyWithoutProductoInput
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutCategoriaInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idSubCategoria: number
    foto?: FotoUncheckedCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductoInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput>
  }

  export type ProductoCreateManyCategoriaInputEnvelope = {
    data: ProductoCreateManyCategoriaInput | ProductoCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoriaUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: SubCategoriaWhereUniqueInput
    update: XOR<SubCategoriaUpdateWithoutCategoriasInput, SubCategoriaUncheckedUpdateWithoutCategoriasInput>
    create: XOR<SubCategoriaCreateWithoutCategoriasInput, SubCategoriaUncheckedCreateWithoutCategoriasInput>
  }

  export type SubCategoriaUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: SubCategoriaWhereUniqueInput
    data: XOR<SubCategoriaUpdateWithoutCategoriasInput, SubCategoriaUncheckedUpdateWithoutCategoriasInput>
  }

  export type SubCategoriaUpdateManyWithWhereWithoutCategoriasInput = {
    where: SubCategoriaScalarWhereInput
    data: XOR<SubCategoriaUpdateManyMutationInput, SubCategoriaUncheckedUpdateManyWithoutCategoriasInput>
  }

  export type SubCategoriaScalarWhereInput = {
    AND?: SubCategoriaScalarWhereInput | SubCategoriaScalarWhereInput[]
    OR?: SubCategoriaScalarWhereInput[]
    NOT?: SubCategoriaScalarWhereInput | SubCategoriaScalarWhereInput[]
    id?: IntFilter<"SubCategoria"> | number
    nombre?: StringFilter<"SubCategoria"> | string
  }

  export type ProductoUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutCategoriaInput, ProductoUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutCategoriaInput, ProductoUncheckedUpdateWithoutCategoriaInput>
  }

  export type ProductoUpdateManyWithWhereWithoutCategoriaInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type ProductoScalarWhereInput = {
    AND?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    OR?: ProductoScalarWhereInput[]
    NOT?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    id?: IntFilter<"Producto"> | number
    codigoProducto?: StringNullableFilter<"Producto"> | string | null
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    stock?: IntFilter<"Producto"> | number
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFilter<"Producto"> | boolean
    idCategoria?: IntFilter<"Producto"> | number
    idSubCategoria?: IntFilter<"Producto"> | number
  }

  export type ProductoCreateWithoutSubCategoriasInput = {
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    categoria: CategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductoInput
    Historial?: HistorialCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutSubCategoriasInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
    foto?: FotoUncheckedCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductoInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutSubCategoriasInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput>
  }

  export type ProductoCreateManySubCategoriasInputEnvelope = {
    data: ProductoCreateManySubCategoriasInput | ProductoCreateManySubCategoriasInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaCreateWithoutSubCategoriaInput = {
    nombre: string
    producto?: ProductoCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutSubCategoriaInput = {
    id?: number
    nombre: string
    producto?: ProductoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutSubCategoriaInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput>
  }

  export type ProductoUpsertWithWhereUniqueWithoutSubCategoriasInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutSubCategoriasInput, ProductoUncheckedUpdateWithoutSubCategoriasInput>
    create: XOR<ProductoCreateWithoutSubCategoriasInput, ProductoUncheckedCreateWithoutSubCategoriasInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutSubCategoriasInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutSubCategoriasInput, ProductoUncheckedUpdateWithoutSubCategoriasInput>
  }

  export type ProductoUpdateManyWithWhereWithoutSubCategoriasInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutSubCategoriasInput>
  }

  export type CategoriaUpsertWithWhereUniqueWithoutSubCategoriaInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutSubCategoriaInput, CategoriaUncheckedUpdateWithoutSubCategoriaInput>
    create: XOR<CategoriaCreateWithoutSubCategoriaInput, CategoriaUncheckedCreateWithoutSubCategoriaInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutSubCategoriaInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutSubCategoriaInput, CategoriaUncheckedUpdateWithoutSubCategoriaInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutSubCategoriaInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutSubCategoriaInput>
  }

  export type CategoriaScalarWhereInput = {
    AND?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
    OR?: CategoriaScalarWhereInput[]
    NOT?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nombre?: StringFilter<"Categoria"> | string
  }

  export type CategoriaCreateWithoutProductoInput = {
    nombre: string
    subCategoria?: SubCategoriaCreateNestedManyWithoutCategoriasInput
  }

  export type CategoriaUncheckedCreateWithoutProductoInput = {
    id?: number
    nombre: string
    subCategoria?: SubCategoriaUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type CategoriaCreateOrConnectWithoutProductoInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutProductoInput, CategoriaUncheckedCreateWithoutProductoInput>
  }

  export type FotoCreateWithoutProductoInput = {
    foto: Buffer
  }

  export type FotoUncheckedCreateWithoutProductoInput = {
    id?: number
    foto: Buffer
  }

  export type FotoCreateOrConnectWithoutProductoInput = {
    where: FotoWhereUniqueInput
    create: XOR<FotoCreateWithoutProductoInput, FotoUncheckedCreateWithoutProductoInput>
  }

  export type FotoCreateManyProductoInputEnvelope = {
    data: FotoCreateManyProductoInput | FotoCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type InventarioCreateWithoutProductoInput = {
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
    bodegas: BodegaCreateNestedOneWithoutInventarioInput
    usuarioRegistro: UsuarioCreateNestedOneWithoutInvUsuarioRegistroInput
    usuarioActualizo: UsuarioCreateNestedOneWithoutInvUsuarioActualizoInput
  }

  export type InventarioUncheckedCreateWithoutProductoInput = {
    idBodega: number
    idUsuarioRegistro: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type InventarioCreateOrConnectWithoutProductoInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutProductoInput, InventarioUncheckedCreateWithoutProductoInput>
  }

  export type InventarioCreateManyProductoInputEnvelope = {
    data: InventarioCreateManyProductoInput | InventarioCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type DetalleCompraCreateWithoutProductoInput = {
    cantidad: number
    encabezadoCompra: EncabezadoCompraCreateNestedOneWithoutDetalleCompraInput
    bodega: BodegaCreateNestedOneWithoutDetalleCompraInput
  }

  export type DetalleCompraUncheckedCreateWithoutProductoInput = {
    id?: number
    idEncabezadoCompra: number
    idBodega: number
    cantidad: number
  }

  export type DetalleCompraCreateOrConnectWithoutProductoInput = {
    where: DetalleCompraWhereUniqueInput
    create: XOR<DetalleCompraCreateWithoutProductoInput, DetalleCompraUncheckedCreateWithoutProductoInput>
  }

  export type DetalleCompraCreateManyProductoInputEnvelope = {
    data: DetalleCompraCreateManyProductoInput | DetalleCompraCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type HistorialCreateWithoutProductoInput = {
    justificacion: string
    fechaAjuste?: Date | string
    bodega: BodegaCreateNestedOneWithoutHistorialInput
    usuarioRegistro: UsuarioCreateNestedOneWithoutHistorialInput
  }

  export type HistorialUncheckedCreateWithoutProductoInput = {
    id?: number
    idBodega: number
    idUsuarioRegistro: number
    justificacion: string
    fechaAjuste?: Date | string
  }

  export type HistorialCreateOrConnectWithoutProductoInput = {
    where: HistorialWhereUniqueInput
    create: XOR<HistorialCreateWithoutProductoInput, HistorialUncheckedCreateWithoutProductoInput>
  }

  export type HistorialCreateManyProductoInputEnvelope = {
    data: HistorialCreateManyProductoInput | HistorialCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type TrasladoCreateWithoutProductoInput = {
    cantidad: number
    fechaRegistro?: Date | string
    bodegaOrigen: BodegaCreateNestedOneWithoutTrasladoOrigenInput
    bodegaDestino: BodegaCreateNestedOneWithoutTrasladoDestinoInput
    estadoDestino: EstadoCreateNestedOneWithoutTrasladoInput
    usuario?: UsuarioCreateNestedOneWithoutTrasladoInput
  }

  export type TrasladoUncheckedCreateWithoutProductoInput = {
    id?: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idUsuario?: number | null
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type TrasladoCreateOrConnectWithoutProductoInput = {
    where: TrasladoWhereUniqueInput
    create: XOR<TrasladoCreateWithoutProductoInput, TrasladoUncheckedCreateWithoutProductoInput>
  }

  export type TrasladoCreateManyProductoInputEnvelope = {
    data: TrasladoCreateManyProductoInput | TrasladoCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoriaCreateWithoutProductoInput = {
    nombre: string
    categorias?: CategoriaCreateNestedManyWithoutSubCategoriaInput
  }

  export type SubCategoriaUncheckedCreateWithoutProductoInput = {
    id?: number
    nombre: string
    categorias?: CategoriaUncheckedCreateNestedManyWithoutSubCategoriaInput
  }

  export type SubCategoriaCreateOrConnectWithoutProductoInput = {
    where: SubCategoriaWhereUniqueInput
    create: XOR<SubCategoriaCreateWithoutProductoInput, SubCategoriaUncheckedCreateWithoutProductoInput>
  }

  export type CategoriaUpsertWithoutProductoInput = {
    update: XOR<CategoriaUpdateWithoutProductoInput, CategoriaUncheckedUpdateWithoutProductoInput>
    create: XOR<CategoriaCreateWithoutProductoInput, CategoriaUncheckedCreateWithoutProductoInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutProductoInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutProductoInput, CategoriaUncheckedUpdateWithoutProductoInput>
  }

  export type CategoriaUpdateWithoutProductoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    subCategoria?: SubCategoriaUpdateManyWithoutCategoriasNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    subCategoria?: SubCategoriaUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type FotoUpsertWithWhereUniqueWithoutProductoInput = {
    where: FotoWhereUniqueInput
    update: XOR<FotoUpdateWithoutProductoInput, FotoUncheckedUpdateWithoutProductoInput>
    create: XOR<FotoCreateWithoutProductoInput, FotoUncheckedCreateWithoutProductoInput>
  }

  export type FotoUpdateWithWhereUniqueWithoutProductoInput = {
    where: FotoWhereUniqueInput
    data: XOR<FotoUpdateWithoutProductoInput, FotoUncheckedUpdateWithoutProductoInput>
  }

  export type FotoUpdateManyWithWhereWithoutProductoInput = {
    where: FotoScalarWhereInput
    data: XOR<FotoUpdateManyMutationInput, FotoUncheckedUpdateManyWithoutProductoInput>
  }

  export type FotoScalarWhereInput = {
    AND?: FotoScalarWhereInput | FotoScalarWhereInput[]
    OR?: FotoScalarWhereInput[]
    NOT?: FotoScalarWhereInput | FotoScalarWhereInput[]
    id?: IntFilter<"Foto"> | number
    idProducto?: IntFilter<"Foto"> | number
    foto?: BytesFilter<"Foto"> | Buffer
  }

  export type InventarioUpsertWithWhereUniqueWithoutProductoInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutProductoInput, InventarioUncheckedUpdateWithoutProductoInput>
    create: XOR<InventarioCreateWithoutProductoInput, InventarioUncheckedCreateWithoutProductoInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutProductoInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutProductoInput, InventarioUncheckedUpdateWithoutProductoInput>
  }

  export type InventarioUpdateManyWithWhereWithoutProductoInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutProductoInput>
  }

  export type DetalleCompraUpsertWithWhereUniqueWithoutProductoInput = {
    where: DetalleCompraWhereUniqueInput
    update: XOR<DetalleCompraUpdateWithoutProductoInput, DetalleCompraUncheckedUpdateWithoutProductoInput>
    create: XOR<DetalleCompraCreateWithoutProductoInput, DetalleCompraUncheckedCreateWithoutProductoInput>
  }

  export type DetalleCompraUpdateWithWhereUniqueWithoutProductoInput = {
    where: DetalleCompraWhereUniqueInput
    data: XOR<DetalleCompraUpdateWithoutProductoInput, DetalleCompraUncheckedUpdateWithoutProductoInput>
  }

  export type DetalleCompraUpdateManyWithWhereWithoutProductoInput = {
    where: DetalleCompraScalarWhereInput
    data: XOR<DetalleCompraUpdateManyMutationInput, DetalleCompraUncheckedUpdateManyWithoutProductoInput>
  }

  export type DetalleCompraScalarWhereInput = {
    AND?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
    OR?: DetalleCompraScalarWhereInput[]
    NOT?: DetalleCompraScalarWhereInput | DetalleCompraScalarWhereInput[]
    id?: IntFilter<"DetalleCompra"> | number
    idEncabezadoCompra?: IntFilter<"DetalleCompra"> | number
    idProducto?: IntFilter<"DetalleCompra"> | number
    idBodega?: IntFilter<"DetalleCompra"> | number
    cantidad?: IntFilter<"DetalleCompra"> | number
  }

  export type HistorialUpsertWithWhereUniqueWithoutProductoInput = {
    where: HistorialWhereUniqueInput
    update: XOR<HistorialUpdateWithoutProductoInput, HistorialUncheckedUpdateWithoutProductoInput>
    create: XOR<HistorialCreateWithoutProductoInput, HistorialUncheckedCreateWithoutProductoInput>
  }

  export type HistorialUpdateWithWhereUniqueWithoutProductoInput = {
    where: HistorialWhereUniqueInput
    data: XOR<HistorialUpdateWithoutProductoInput, HistorialUncheckedUpdateWithoutProductoInput>
  }

  export type HistorialUpdateManyWithWhereWithoutProductoInput = {
    where: HistorialScalarWhereInput
    data: XOR<HistorialUpdateManyMutationInput, HistorialUncheckedUpdateManyWithoutProductoInput>
  }

  export type TrasladoUpsertWithWhereUniqueWithoutProductoInput = {
    where: TrasladoWhereUniqueInput
    update: XOR<TrasladoUpdateWithoutProductoInput, TrasladoUncheckedUpdateWithoutProductoInput>
    create: XOR<TrasladoCreateWithoutProductoInput, TrasladoUncheckedCreateWithoutProductoInput>
  }

  export type TrasladoUpdateWithWhereUniqueWithoutProductoInput = {
    where: TrasladoWhereUniqueInput
    data: XOR<TrasladoUpdateWithoutProductoInput, TrasladoUncheckedUpdateWithoutProductoInput>
  }

  export type TrasladoUpdateManyWithWhereWithoutProductoInput = {
    where: TrasladoScalarWhereInput
    data: XOR<TrasladoUpdateManyMutationInput, TrasladoUncheckedUpdateManyWithoutProductoInput>
  }

  export type SubCategoriaUpsertWithoutProductoInput = {
    update: XOR<SubCategoriaUpdateWithoutProductoInput, SubCategoriaUncheckedUpdateWithoutProductoInput>
    create: XOR<SubCategoriaCreateWithoutProductoInput, SubCategoriaUncheckedCreateWithoutProductoInput>
    where?: SubCategoriaWhereInput
  }

  export type SubCategoriaUpdateToOneWithWhereWithoutProductoInput = {
    where?: SubCategoriaWhereInput
    data: XOR<SubCategoriaUpdateWithoutProductoInput, SubCategoriaUncheckedUpdateWithoutProductoInput>
  }

  export type SubCategoriaUpdateWithoutProductoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    categorias?: CategoriaUpdateManyWithoutSubCategoriaNestedInput
  }

  export type SubCategoriaUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    categorias?: CategoriaUncheckedUpdateManyWithoutSubCategoriaNestedInput
  }

  export type ProductoCreateWithoutFotoInput = {
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    categoria: CategoriaCreateNestedOneWithoutProductoInput
    bodegaProductos?: InventarioCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductoInput
    Historial?: HistorialCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoCreateNestedManyWithoutProductoInput
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutFotoInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
    idSubCategoria: number
    bodegaProductos?: InventarioUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductoInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutFotoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutFotoInput, ProductoUncheckedCreateWithoutFotoInput>
  }

  export type ProductoUpsertWithoutFotoInput = {
    update: XOR<ProductoUpdateWithoutFotoInput, ProductoUncheckedUpdateWithoutFotoInput>
    create: XOR<ProductoCreateWithoutFotoInput, ProductoUncheckedCreateWithoutFotoInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutFotoInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutFotoInput, ProductoUncheckedUpdateWithoutFotoInput>
  }

  export type ProductoUpdateWithoutFotoInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductoNestedInput
    bodegaProductos?: InventarioUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUpdateManyWithoutProductoNestedInput
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutFotoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    bodegaProductos?: InventarioUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProveedorCreateWithoutUbicacionInput = {
    identificacion: number
    nombreProveedor: string
    correoElectronico: string
    telefono: number
    encabezadoCompra?: EncabezadoCompraCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateWithoutUbicacionInput = {
    id?: number
    identificacion: number
    nombreProveedor: string
    correoElectronico: string
    telefono: number
    encabezadoCompra?: EncabezadoCompraUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorCreateOrConnectWithoutUbicacionInput = {
    where: ProveedorWhereUniqueInput
    create: XOR<ProveedorCreateWithoutUbicacionInput, ProveedorUncheckedCreateWithoutUbicacionInput>
  }

  export type ProveedorCreateManyUbicacionInputEnvelope = {
    data: ProveedorCreateManyUbicacionInput | ProveedorCreateManyUbicacionInput[]
    skipDuplicates?: boolean
  }

  export type BodegaCreateWithoutUbicacionInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioCreateNestedManyWithoutBodegaInput
    inventario?: InventarioCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutBodegaInput
    Historial?: HistorialCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoCreateNestedManyWithoutBodegaDestinoInput
  }

  export type BodegaUncheckedCreateWithoutUbicacionInput = {
    id?: number
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioUncheckedCreateNestedManyWithoutBodegaInput
    inventario?: InventarioUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutBodegaInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoUncheckedCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoUncheckedCreateNestedManyWithoutBodegaDestinoInput
  }

  export type BodegaCreateOrConnectWithoutUbicacionInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput>
  }

  export type BodegaCreateManyUbicacionInputEnvelope = {
    data: BodegaCreateManyUbicacionInput | BodegaCreateManyUbicacionInput[]
    skipDuplicates?: boolean
  }

  export type ProveedorUpsertWithWhereUniqueWithoutUbicacionInput = {
    where: ProveedorWhereUniqueInput
    update: XOR<ProveedorUpdateWithoutUbicacionInput, ProveedorUncheckedUpdateWithoutUbicacionInput>
    create: XOR<ProveedorCreateWithoutUbicacionInput, ProveedorUncheckedCreateWithoutUbicacionInput>
  }

  export type ProveedorUpdateWithWhereUniqueWithoutUbicacionInput = {
    where: ProveedorWhereUniqueInput
    data: XOR<ProveedorUpdateWithoutUbicacionInput, ProveedorUncheckedUpdateWithoutUbicacionInput>
  }

  export type ProveedorUpdateManyWithWhereWithoutUbicacionInput = {
    where: ProveedorScalarWhereInput
    data: XOR<ProveedorUpdateManyMutationInput, ProveedorUncheckedUpdateManyWithoutUbicacionInput>
  }

  export type ProveedorScalarWhereInput = {
    AND?: ProveedorScalarWhereInput | ProveedorScalarWhereInput[]
    OR?: ProveedorScalarWhereInput[]
    NOT?: ProveedorScalarWhereInput | ProveedorScalarWhereInput[]
    id?: IntFilter<"Proveedor"> | number
    identificacion?: IntFilter<"Proveedor"> | number
    nombreProveedor?: StringFilter<"Proveedor"> | string
    idUbicacion?: IntFilter<"Proveedor"> | number
    correoElectronico?: StringFilter<"Proveedor"> | string
    telefono?: IntFilter<"Proveedor"> | number
  }

  export type BodegaUpsertWithWhereUniqueWithoutUbicacionInput = {
    where: BodegaWhereUniqueInput
    update: XOR<BodegaUpdateWithoutUbicacionInput, BodegaUncheckedUpdateWithoutUbicacionInput>
    create: XOR<BodegaCreateWithoutUbicacionInput, BodegaUncheckedCreateWithoutUbicacionInput>
  }

  export type BodegaUpdateWithWhereUniqueWithoutUbicacionInput = {
    where: BodegaWhereUniqueInput
    data: XOR<BodegaUpdateWithoutUbicacionInput, BodegaUncheckedUpdateWithoutUbicacionInput>
  }

  export type BodegaUpdateManyWithWhereWithoutUbicacionInput = {
    where: BodegaScalarWhereInput
    data: XOR<BodegaUpdateManyMutationInput, BodegaUncheckedUpdateManyWithoutUbicacionInput>
  }

  export type BodegaScalarWhereInput = {
    AND?: BodegaScalarWhereInput | BodegaScalarWhereInput[]
    OR?: BodegaScalarWhereInput[]
    NOT?: BodegaScalarWhereInput | BodegaScalarWhereInput[]
    id?: IntFilter<"Bodega"> | number
    nombre?: StringFilter<"Bodega"> | string
    idUbicacion?: IntFilter<"Bodega"> | number
    tamanno?: FloatFilter<"Bodega"> | number
    capacidad?: FloatFilter<"Bodega"> | number
    seguridad?: BoolFilter<"Bodega"> | boolean
  }

  export type UsuarioCreateWithoutBodegaInput = {
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioCreateNestedManyWithoutUsuarioActualizoInput
  }

  export type UsuarioUncheckedCreateWithoutBodegaInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioUncheckedCreateNestedManyWithoutUsuarioActualizoInput
  }

  export type UsuarioCreateOrConnectWithoutBodegaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutBodegaInput, UsuarioUncheckedCreateWithoutBodegaInput>
  }

  export type UsuarioCreateManyBodegaInputEnvelope = {
    data: UsuarioCreateManyBodegaInput | UsuarioCreateManyBodegaInput[]
    skipDuplicates?: boolean
  }

  export type InventarioCreateWithoutBodegasInput = {
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
    producto: ProductoCreateNestedOneWithoutBodegaProductosInput
    usuarioRegistro: UsuarioCreateNestedOneWithoutInvUsuarioRegistroInput
    usuarioActualizo: UsuarioCreateNestedOneWithoutInvUsuarioActualizoInput
  }

  export type InventarioUncheckedCreateWithoutBodegasInput = {
    idProducto: number
    idUsuarioRegistro: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type InventarioCreateOrConnectWithoutBodegasInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutBodegasInput, InventarioUncheckedCreateWithoutBodegasInput>
  }

  export type InventarioCreateManyBodegasInputEnvelope = {
    data: InventarioCreateManyBodegasInput | InventarioCreateManyBodegasInput[]
    skipDuplicates?: boolean
  }

  export type DetalleCompraCreateWithoutBodegaInput = {
    cantidad: number
    producto: ProductoCreateNestedOneWithoutDetalleComprasInput
    encabezadoCompra: EncabezadoCompraCreateNestedOneWithoutDetalleCompraInput
  }

  export type DetalleCompraUncheckedCreateWithoutBodegaInput = {
    id?: number
    idEncabezadoCompra: number
    idProducto: number
    cantidad: number
  }

  export type DetalleCompraCreateOrConnectWithoutBodegaInput = {
    where: DetalleCompraWhereUniqueInput
    create: XOR<DetalleCompraCreateWithoutBodegaInput, DetalleCompraUncheckedCreateWithoutBodegaInput>
  }

  export type DetalleCompraCreateManyBodegaInputEnvelope = {
    data: DetalleCompraCreateManyBodegaInput | DetalleCompraCreateManyBodegaInput[]
    skipDuplicates?: boolean
  }

  export type HistorialCreateWithoutBodegaInput = {
    justificacion: string
    fechaAjuste?: Date | string
    producto: ProductoCreateNestedOneWithoutHistorialInput
    usuarioRegistro: UsuarioCreateNestedOneWithoutHistorialInput
  }

  export type HistorialUncheckedCreateWithoutBodegaInput = {
    id?: number
    idUsuarioRegistro: number
    idProducto: number
    justificacion: string
    fechaAjuste?: Date | string
  }

  export type HistorialCreateOrConnectWithoutBodegaInput = {
    where: HistorialWhereUniqueInput
    create: XOR<HistorialCreateWithoutBodegaInput, HistorialUncheckedCreateWithoutBodegaInput>
  }

  export type HistorialCreateManyBodegaInputEnvelope = {
    data: HistorialCreateManyBodegaInput | HistorialCreateManyBodegaInput[]
    skipDuplicates?: boolean
  }

  export type TrasladoCreateWithoutBodegaOrigenInput = {
    cantidad: number
    fechaRegistro?: Date | string
    bodegaDestino: BodegaCreateNestedOneWithoutTrasladoDestinoInput
    estadoDestino: EstadoCreateNestedOneWithoutTrasladoInput
    usuario?: UsuarioCreateNestedOneWithoutTrasladoInput
    producto: ProductoCreateNestedOneWithoutTrasladoInput
  }

  export type TrasladoUncheckedCreateWithoutBodegaOrigenInput = {
    id?: number
    idBodegaDestino: number
    idUsuario?: number | null
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type TrasladoCreateOrConnectWithoutBodegaOrigenInput = {
    where: TrasladoWhereUniqueInput
    create: XOR<TrasladoCreateWithoutBodegaOrigenInput, TrasladoUncheckedCreateWithoutBodegaOrigenInput>
  }

  export type TrasladoCreateManyBodegaOrigenInputEnvelope = {
    data: TrasladoCreateManyBodegaOrigenInput | TrasladoCreateManyBodegaOrigenInput[]
    skipDuplicates?: boolean
  }

  export type TrasladoCreateWithoutBodegaDestinoInput = {
    cantidad: number
    fechaRegistro?: Date | string
    bodegaOrigen: BodegaCreateNestedOneWithoutTrasladoOrigenInput
    estadoDestino: EstadoCreateNestedOneWithoutTrasladoInput
    usuario?: UsuarioCreateNestedOneWithoutTrasladoInput
    producto: ProductoCreateNestedOneWithoutTrasladoInput
  }

  export type TrasladoUncheckedCreateWithoutBodegaDestinoInput = {
    id?: number
    idBodegaOrigen: number
    idUsuario?: number | null
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type TrasladoCreateOrConnectWithoutBodegaDestinoInput = {
    where: TrasladoWhereUniqueInput
    create: XOR<TrasladoCreateWithoutBodegaDestinoInput, TrasladoUncheckedCreateWithoutBodegaDestinoInput>
  }

  export type TrasladoCreateManyBodegaDestinoInputEnvelope = {
    data: TrasladoCreateManyBodegaDestinoInput | TrasladoCreateManyBodegaDestinoInput[]
    skipDuplicates?: boolean
  }

  export type UbicacionCreateWithoutBodegaInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta?: string | null
    proveedor?: ProveedorCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateWithoutBodegaInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta?: string | null
    proveedor?: ProveedorUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionCreateOrConnectWithoutBodegaInput = {
    where: UbicacionWhereUniqueInput
    create: XOR<UbicacionCreateWithoutBodegaInput, UbicacionUncheckedCreateWithoutBodegaInput>
  }

  export type UsuarioUpsertWithWhereUniqueWithoutBodegaInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutBodegaInput, UsuarioUncheckedUpdateWithoutBodegaInput>
    create: XOR<UsuarioCreateWithoutBodegaInput, UsuarioUncheckedCreateWithoutBodegaInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutBodegaInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutBodegaInput, UsuarioUncheckedUpdateWithoutBodegaInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutBodegaInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutBodegaInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    correo?: StringFilter<"Usuario"> | string
    contrasenna?: StringFilter<"Usuario"> | string
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    idBodega?: IntNullableFilter<"Usuario"> | number | null
    estado?: BoolFilter<"Usuario"> | boolean
  }

  export type InventarioUpsertWithWhereUniqueWithoutBodegasInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutBodegasInput, InventarioUncheckedUpdateWithoutBodegasInput>
    create: XOR<InventarioCreateWithoutBodegasInput, InventarioUncheckedCreateWithoutBodegasInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutBodegasInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutBodegasInput, InventarioUncheckedUpdateWithoutBodegasInput>
  }

  export type InventarioUpdateManyWithWhereWithoutBodegasInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutBodegasInput>
  }

  export type DetalleCompraUpsertWithWhereUniqueWithoutBodegaInput = {
    where: DetalleCompraWhereUniqueInput
    update: XOR<DetalleCompraUpdateWithoutBodegaInput, DetalleCompraUncheckedUpdateWithoutBodegaInput>
    create: XOR<DetalleCompraCreateWithoutBodegaInput, DetalleCompraUncheckedCreateWithoutBodegaInput>
  }

  export type DetalleCompraUpdateWithWhereUniqueWithoutBodegaInput = {
    where: DetalleCompraWhereUniqueInput
    data: XOR<DetalleCompraUpdateWithoutBodegaInput, DetalleCompraUncheckedUpdateWithoutBodegaInput>
  }

  export type DetalleCompraUpdateManyWithWhereWithoutBodegaInput = {
    where: DetalleCompraScalarWhereInput
    data: XOR<DetalleCompraUpdateManyMutationInput, DetalleCompraUncheckedUpdateManyWithoutBodegaInput>
  }

  export type HistorialUpsertWithWhereUniqueWithoutBodegaInput = {
    where: HistorialWhereUniqueInput
    update: XOR<HistorialUpdateWithoutBodegaInput, HistorialUncheckedUpdateWithoutBodegaInput>
    create: XOR<HistorialCreateWithoutBodegaInput, HistorialUncheckedCreateWithoutBodegaInput>
  }

  export type HistorialUpdateWithWhereUniqueWithoutBodegaInput = {
    where: HistorialWhereUniqueInput
    data: XOR<HistorialUpdateWithoutBodegaInput, HistorialUncheckedUpdateWithoutBodegaInput>
  }

  export type HistorialUpdateManyWithWhereWithoutBodegaInput = {
    where: HistorialScalarWhereInput
    data: XOR<HistorialUpdateManyMutationInput, HistorialUncheckedUpdateManyWithoutBodegaInput>
  }

  export type TrasladoUpsertWithWhereUniqueWithoutBodegaOrigenInput = {
    where: TrasladoWhereUniqueInput
    update: XOR<TrasladoUpdateWithoutBodegaOrigenInput, TrasladoUncheckedUpdateWithoutBodegaOrigenInput>
    create: XOR<TrasladoCreateWithoutBodegaOrigenInput, TrasladoUncheckedCreateWithoutBodegaOrigenInput>
  }

  export type TrasladoUpdateWithWhereUniqueWithoutBodegaOrigenInput = {
    where: TrasladoWhereUniqueInput
    data: XOR<TrasladoUpdateWithoutBodegaOrigenInput, TrasladoUncheckedUpdateWithoutBodegaOrigenInput>
  }

  export type TrasladoUpdateManyWithWhereWithoutBodegaOrigenInput = {
    where: TrasladoScalarWhereInput
    data: XOR<TrasladoUpdateManyMutationInput, TrasladoUncheckedUpdateManyWithoutBodegaOrigenInput>
  }

  export type TrasladoUpsertWithWhereUniqueWithoutBodegaDestinoInput = {
    where: TrasladoWhereUniqueInput
    update: XOR<TrasladoUpdateWithoutBodegaDestinoInput, TrasladoUncheckedUpdateWithoutBodegaDestinoInput>
    create: XOR<TrasladoCreateWithoutBodegaDestinoInput, TrasladoUncheckedCreateWithoutBodegaDestinoInput>
  }

  export type TrasladoUpdateWithWhereUniqueWithoutBodegaDestinoInput = {
    where: TrasladoWhereUniqueInput
    data: XOR<TrasladoUpdateWithoutBodegaDestinoInput, TrasladoUncheckedUpdateWithoutBodegaDestinoInput>
  }

  export type TrasladoUpdateManyWithWhereWithoutBodegaDestinoInput = {
    where: TrasladoScalarWhereInput
    data: XOR<TrasladoUpdateManyMutationInput, TrasladoUncheckedUpdateManyWithoutBodegaDestinoInput>
  }

  export type UbicacionUpsertWithoutBodegaInput = {
    update: XOR<UbicacionUpdateWithoutBodegaInput, UbicacionUncheckedUpdateWithoutBodegaInput>
    create: XOR<UbicacionCreateWithoutBodegaInput, UbicacionUncheckedCreateWithoutBodegaInput>
    where?: UbicacionWhereInput
  }

  export type UbicacionUpdateToOneWithWhereWithoutBodegaInput = {
    where?: UbicacionWhereInput
    data: XOR<UbicacionUpdateWithoutBodegaInput, UbicacionUncheckedUpdateWithoutBodegaInput>
  }

  export type UbicacionUpdateWithoutBodegaInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    direccionExacta?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: ProveedorUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateWithoutBodegaInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    direccionExacta?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: ProveedorUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type BodegaCreateWithoutInventarioInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioCreateNestedManyWithoutBodegaInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutBodegaInput
    Historial?: HistorialCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoCreateNestedManyWithoutBodegaDestinoInput
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
  }

  export type BodegaUncheckedCreateWithoutInventarioInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioUncheckedCreateNestedManyWithoutBodegaInput
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutBodegaInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoUncheckedCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoUncheckedCreateNestedManyWithoutBodegaDestinoInput
  }

  export type BodegaCreateOrConnectWithoutInventarioInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutInventarioInput, BodegaUncheckedCreateWithoutInventarioInput>
  }

  export type ProductoCreateWithoutBodegaProductosInput = {
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    categoria: CategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductoInput
    Historial?: HistorialCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoCreateNestedManyWithoutProductoInput
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutBodegaProductosInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
    idSubCategoria: number
    foto?: FotoUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductoInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutBodegaProductosInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutBodegaProductosInput, ProductoUncheckedCreateWithoutBodegaProductosInput>
  }

  export type UsuarioCreateWithoutInvUsuarioRegistroInput = {
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioCreateNestedManyWithoutUsuarioActualizoInput
    bodega?: BodegaCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutInvUsuarioRegistroInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    idBodega?: number | null
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioUncheckedCreateNestedManyWithoutUsuarioActualizoInput
  }

  export type UsuarioCreateOrConnectWithoutInvUsuarioRegistroInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutInvUsuarioRegistroInput, UsuarioUncheckedCreateWithoutInvUsuarioRegistroInput>
  }

  export type UsuarioCreateWithoutInvUsuarioActualizoInput = {
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioCreateNestedManyWithoutUsuarioRegistroInput
    bodega?: BodegaCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutInvUsuarioActualizoInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    idBodega?: number | null
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioUncheckedCreateNestedManyWithoutUsuarioRegistroInput
  }

  export type UsuarioCreateOrConnectWithoutInvUsuarioActualizoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutInvUsuarioActualizoInput, UsuarioUncheckedCreateWithoutInvUsuarioActualizoInput>
  }

  export type BodegaUpsertWithoutInventarioInput = {
    update: XOR<BodegaUpdateWithoutInventarioInput, BodegaUncheckedUpdateWithoutInventarioInput>
    create: XOR<BodegaCreateWithoutInventarioInput, BodegaUncheckedCreateWithoutInventarioInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutInventarioInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutInventarioInput, BodegaUncheckedUpdateWithoutInventarioInput>
  }

  export type BodegaUpdateWithoutInventarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateManyWithoutBodegaNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUpdateManyWithoutBodegaDestinoNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
  }

  export type BodegaUncheckedUpdateWithoutInventarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUncheckedUpdateManyWithoutBodegaNestedInput
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUncheckedUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUncheckedUpdateManyWithoutBodegaDestinoNestedInput
  }

  export type ProductoUpsertWithoutBodegaProductosInput = {
    update: XOR<ProductoUpdateWithoutBodegaProductosInput, ProductoUncheckedUpdateWithoutBodegaProductosInput>
    create: XOR<ProductoCreateWithoutBodegaProductosInput, ProductoUncheckedCreateWithoutBodegaProductosInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutBodegaProductosInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutBodegaProductosInput, ProductoUncheckedUpdateWithoutBodegaProductosInput>
  }

  export type ProductoUpdateWithoutBodegaProductosInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUpdateManyWithoutProductoNestedInput
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutBodegaProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    foto?: FotoUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type UsuarioUpsertWithoutInvUsuarioRegistroInput = {
    update: XOR<UsuarioUpdateWithoutInvUsuarioRegistroInput, UsuarioUncheckedUpdateWithoutInvUsuarioRegistroInput>
    create: XOR<UsuarioCreateWithoutInvUsuarioRegistroInput, UsuarioUncheckedCreateWithoutInvUsuarioRegistroInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutInvUsuarioRegistroInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutInvUsuarioRegistroInput, UsuarioUncheckedUpdateWithoutInvUsuarioRegistroInput>
  }

  export type UsuarioUpdateWithoutInvUsuarioRegistroInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUpdateManyWithoutUsuarioActualizoNestedInput
    bodega?: BodegaUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutInvUsuarioRegistroInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idBodega?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUncheckedUpdateManyWithoutUsuarioActualizoNestedInput
  }

  export type UsuarioUpsertWithoutInvUsuarioActualizoInput = {
    update: XOR<UsuarioUpdateWithoutInvUsuarioActualizoInput, UsuarioUncheckedUpdateWithoutInvUsuarioActualizoInput>
    create: XOR<UsuarioCreateWithoutInvUsuarioActualizoInput, UsuarioUncheckedCreateWithoutInvUsuarioActualizoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutInvUsuarioActualizoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutInvUsuarioActualizoInput, UsuarioUncheckedUpdateWithoutInvUsuarioActualizoInput>
  }

  export type UsuarioUpdateWithoutInvUsuarioActualizoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUpdateManyWithoutUsuarioRegistroNestedInput
    bodega?: BodegaUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutInvUsuarioActualizoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idBodega?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
  }

  export type EncabezadoCompraCreateWithoutProveedorInput = {
    fechaCompra?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEncabezadoComprasInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutEncabezadoCompraInput
    pedido?: PedidoCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraUncheckedCreateWithoutProveedorInput = {
    id?: number
    fechaCompra?: Date | string
    idUsuario: number
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoCompraInput
    pedido?: PedidoUncheckedCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraCreateOrConnectWithoutProveedorInput = {
    where: EncabezadoCompraWhereUniqueInput
    create: XOR<EncabezadoCompraCreateWithoutProveedorInput, EncabezadoCompraUncheckedCreateWithoutProveedorInput>
  }

  export type EncabezadoCompraCreateManyProveedorInputEnvelope = {
    data: EncabezadoCompraCreateManyProveedorInput | EncabezadoCompraCreateManyProveedorInput[]
    skipDuplicates?: boolean
  }

  export type UbicacionCreateWithoutProveedorInput = {
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta?: string | null
    bodega?: BodegaCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionUncheckedCreateWithoutProveedorInput = {
    id?: number
    idProvincia: number
    idCanton: number
    idDistrito: number
    direccionExacta?: string | null
    bodega?: BodegaUncheckedCreateNestedManyWithoutUbicacionInput
  }

  export type UbicacionCreateOrConnectWithoutProveedorInput = {
    where: UbicacionWhereUniqueInput
    create: XOR<UbicacionCreateWithoutProveedorInput, UbicacionUncheckedCreateWithoutProveedorInput>
  }

  export type EncabezadoCompraUpsertWithWhereUniqueWithoutProveedorInput = {
    where: EncabezadoCompraWhereUniqueInput
    update: XOR<EncabezadoCompraUpdateWithoutProveedorInput, EncabezadoCompraUncheckedUpdateWithoutProveedorInput>
    create: XOR<EncabezadoCompraCreateWithoutProveedorInput, EncabezadoCompraUncheckedCreateWithoutProveedorInput>
  }

  export type EncabezadoCompraUpdateWithWhereUniqueWithoutProveedorInput = {
    where: EncabezadoCompraWhereUniqueInput
    data: XOR<EncabezadoCompraUpdateWithoutProveedorInput, EncabezadoCompraUncheckedUpdateWithoutProveedorInput>
  }

  export type EncabezadoCompraUpdateManyWithWhereWithoutProveedorInput = {
    where: EncabezadoCompraScalarWhereInput
    data: XOR<EncabezadoCompraUpdateManyMutationInput, EncabezadoCompraUncheckedUpdateManyWithoutProveedorInput>
  }

  export type UbicacionUpsertWithoutProveedorInput = {
    update: XOR<UbicacionUpdateWithoutProveedorInput, UbicacionUncheckedUpdateWithoutProveedorInput>
    create: XOR<UbicacionCreateWithoutProveedorInput, UbicacionUncheckedCreateWithoutProveedorInput>
    where?: UbicacionWhereInput
  }

  export type UbicacionUpdateToOneWithWhereWithoutProveedorInput = {
    where?: UbicacionWhereInput
    data: XOR<UbicacionUpdateWithoutProveedorInput, UbicacionUncheckedUpdateWithoutProveedorInput>
  }

  export type UbicacionUpdateWithoutProveedorInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    direccionExacta?: NullableStringFieldUpdateOperationsInput | string | null
    bodega?: BodegaUpdateManyWithoutUbicacionNestedInput
  }

  export type UbicacionUncheckedUpdateWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    idCanton?: IntFieldUpdateOperationsInput | number
    idDistrito?: IntFieldUpdateOperationsInput | number
    direccionExacta?: NullableStringFieldUpdateOperationsInput | string | null
    bodega?: BodegaUncheckedUpdateManyWithoutUbicacionNestedInput
  }

  export type UsuarioCreateWithoutEncabezadoComprasInput = {
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
    Traslado?: TrasladoCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioCreateNestedManyWithoutUsuarioActualizoInput
    bodega?: BodegaCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEncabezadoComprasInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    idBodega?: number | null
    estado?: boolean
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioUncheckedCreateNestedManyWithoutUsuarioActualizoInput
  }

  export type UsuarioCreateOrConnectWithoutEncabezadoComprasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEncabezadoComprasInput, UsuarioUncheckedCreateWithoutEncabezadoComprasInput>
  }

  export type ProveedorCreateWithoutEncabezadoCompraInput = {
    identificacion: number
    nombreProveedor: string
    correoElectronico: string
    telefono: number
    ubicacion: UbicacionCreateNestedOneWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateWithoutEncabezadoCompraInput = {
    id?: number
    identificacion: number
    nombreProveedor: string
    idUbicacion: number
    correoElectronico: string
    telefono: number
  }

  export type ProveedorCreateOrConnectWithoutEncabezadoCompraInput = {
    where: ProveedorWhereUniqueInput
    create: XOR<ProveedorCreateWithoutEncabezadoCompraInput, ProveedorUncheckedCreateWithoutEncabezadoCompraInput>
  }

  export type DetalleCompraCreateWithoutEncabezadoCompraInput = {
    cantidad: number
    producto: ProductoCreateNestedOneWithoutDetalleComprasInput
    bodega: BodegaCreateNestedOneWithoutDetalleCompraInput
  }

  export type DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput = {
    id?: number
    idProducto: number
    idBodega: number
    cantidad: number
  }

  export type DetalleCompraCreateOrConnectWithoutEncabezadoCompraInput = {
    where: DetalleCompraWhereUniqueInput
    create: XOR<DetalleCompraCreateWithoutEncabezadoCompraInput, DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput>
  }

  export type DetalleCompraCreateManyEncabezadoCompraInputEnvelope = {
    data: DetalleCompraCreateManyEncabezadoCompraInput | DetalleCompraCreateManyEncabezadoCompraInput[]
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutEncabezadoCompraInput = {
    observaciones?: string | null
    fechaPedido?: Date | string
    estadoPedido: EstadoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutEncabezadoCompraInput = {
    idEstado: number
    observaciones?: string | null
    fechaPedido?: Date | string
  }

  export type PedidoCreateOrConnectWithoutEncabezadoCompraInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutEncabezadoCompraInput, PedidoUncheckedCreateWithoutEncabezadoCompraInput>
  }

  export type PedidoCreateManyEncabezadoCompraInputEnvelope = {
    data: PedidoCreateManyEncabezadoCompraInput | PedidoCreateManyEncabezadoCompraInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutEncabezadoComprasInput = {
    update: XOR<UsuarioUpdateWithoutEncabezadoComprasInput, UsuarioUncheckedUpdateWithoutEncabezadoComprasInput>
    create: XOR<UsuarioCreateWithoutEncabezadoComprasInput, UsuarioUncheckedCreateWithoutEncabezadoComprasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEncabezadoComprasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEncabezadoComprasInput, UsuarioUncheckedUpdateWithoutEncabezadoComprasInput>
  }

  export type UsuarioUpdateWithoutEncabezadoComprasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
    Traslado?: TrasladoUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUpdateManyWithoutUsuarioActualizoNestedInput
    bodega?: BodegaUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEncabezadoComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idBodega?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    Traslado?: TrasladoUncheckedUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUncheckedUpdateManyWithoutUsuarioActualizoNestedInput
  }

  export type ProveedorUpsertWithoutEncabezadoCompraInput = {
    update: XOR<ProveedorUpdateWithoutEncabezadoCompraInput, ProveedorUncheckedUpdateWithoutEncabezadoCompraInput>
    create: XOR<ProveedorCreateWithoutEncabezadoCompraInput, ProveedorUncheckedCreateWithoutEncabezadoCompraInput>
    where?: ProveedorWhereInput
  }

  export type ProveedorUpdateToOneWithWhereWithoutEncabezadoCompraInput = {
    where?: ProveedorWhereInput
    data: XOR<ProveedorUpdateWithoutEncabezadoCompraInput, ProveedorUncheckedUpdateWithoutEncabezadoCompraInput>
  }

  export type ProveedorUpdateWithoutEncabezadoCompraInput = {
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    ubicacion?: UbicacionUpdateOneRequiredWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateWithoutEncabezadoCompraInput = {
    id?: IntFieldUpdateOperationsInput | number
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUpsertWithWhereUniqueWithoutEncabezadoCompraInput = {
    where: DetalleCompraWhereUniqueInput
    update: XOR<DetalleCompraUpdateWithoutEncabezadoCompraInput, DetalleCompraUncheckedUpdateWithoutEncabezadoCompraInput>
    create: XOR<DetalleCompraCreateWithoutEncabezadoCompraInput, DetalleCompraUncheckedCreateWithoutEncabezadoCompraInput>
  }

  export type DetalleCompraUpdateWithWhereUniqueWithoutEncabezadoCompraInput = {
    where: DetalleCompraWhereUniqueInput
    data: XOR<DetalleCompraUpdateWithoutEncabezadoCompraInput, DetalleCompraUncheckedUpdateWithoutEncabezadoCompraInput>
  }

  export type DetalleCompraUpdateManyWithWhereWithoutEncabezadoCompraInput = {
    where: DetalleCompraScalarWhereInput
    data: XOR<DetalleCompraUpdateManyMutationInput, DetalleCompraUncheckedUpdateManyWithoutEncabezadoCompraInput>
  }

  export type PedidoUpsertWithWhereUniqueWithoutEncabezadoCompraInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutEncabezadoCompraInput, PedidoUncheckedUpdateWithoutEncabezadoCompraInput>
    create: XOR<PedidoCreateWithoutEncabezadoCompraInput, PedidoUncheckedCreateWithoutEncabezadoCompraInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutEncabezadoCompraInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutEncabezadoCompraInput, PedidoUncheckedUpdateWithoutEncabezadoCompraInput>
  }

  export type PedidoUpdateManyWithWhereWithoutEncabezadoCompraInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutEncabezadoCompraInput>
  }

  export type ProductoCreateWithoutDetalleComprasInput = {
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    categoria: CategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioCreateNestedManyWithoutProductoInput
    Historial?: HistorialCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoCreateNestedManyWithoutProductoInput
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutDetalleComprasInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
    idSubCategoria: number
    foto?: FotoUncheckedCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioUncheckedCreateNestedManyWithoutProductoInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutDetalleComprasInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutDetalleComprasInput, ProductoUncheckedCreateWithoutDetalleComprasInput>
  }

  export type EncabezadoCompraCreateWithoutDetalleCompraInput = {
    fechaCompra?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEncabezadoComprasInput
    proveedor: ProveedorCreateNestedOneWithoutEncabezadoCompraInput
    pedido?: PedidoCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraUncheckedCreateWithoutDetalleCompraInput = {
    id?: number
    fechaCompra?: Date | string
    idProveedor: number
    idUsuario: number
    pedido?: PedidoUncheckedCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraCreateOrConnectWithoutDetalleCompraInput = {
    where: EncabezadoCompraWhereUniqueInput
    create: XOR<EncabezadoCompraCreateWithoutDetalleCompraInput, EncabezadoCompraUncheckedCreateWithoutDetalleCompraInput>
  }

  export type BodegaCreateWithoutDetalleCompraInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioCreateNestedManyWithoutBodegaInput
    inventario?: InventarioCreateNestedManyWithoutBodegasInput
    Historial?: HistorialCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoCreateNestedManyWithoutBodegaDestinoInput
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
  }

  export type BodegaUncheckedCreateWithoutDetalleCompraInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioUncheckedCreateNestedManyWithoutBodegaInput
    inventario?: InventarioUncheckedCreateNestedManyWithoutBodegasInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoUncheckedCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoUncheckedCreateNestedManyWithoutBodegaDestinoInput
  }

  export type BodegaCreateOrConnectWithoutDetalleCompraInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutDetalleCompraInput, BodegaUncheckedCreateWithoutDetalleCompraInput>
  }

  export type ProductoUpsertWithoutDetalleComprasInput = {
    update: XOR<ProductoUpdateWithoutDetalleComprasInput, ProductoUncheckedUpdateWithoutDetalleComprasInput>
    create: XOR<ProductoCreateWithoutDetalleComprasInput, ProductoUncheckedCreateWithoutDetalleComprasInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutDetalleComprasInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutDetalleComprasInput, ProductoUncheckedUpdateWithoutDetalleComprasInput>
  }

  export type ProductoUpdateWithoutDetalleComprasInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUpdateManyWithoutProductoNestedInput
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutDetalleComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    foto?: FotoUncheckedUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUncheckedUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type EncabezadoCompraUpsertWithoutDetalleCompraInput = {
    update: XOR<EncabezadoCompraUpdateWithoutDetalleCompraInput, EncabezadoCompraUncheckedUpdateWithoutDetalleCompraInput>
    create: XOR<EncabezadoCompraCreateWithoutDetalleCompraInput, EncabezadoCompraUncheckedCreateWithoutDetalleCompraInput>
    where?: EncabezadoCompraWhereInput
  }

  export type EncabezadoCompraUpdateToOneWithWhereWithoutDetalleCompraInput = {
    where?: EncabezadoCompraWhereInput
    data: XOR<EncabezadoCompraUpdateWithoutDetalleCompraInput, EncabezadoCompraUncheckedUpdateWithoutDetalleCompraInput>
  }

  export type EncabezadoCompraUpdateWithoutDetalleCompraInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput
    proveedor?: ProveedorUpdateOneRequiredWithoutEncabezadoCompraNestedInput
    pedido?: PedidoUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateWithoutDetalleCompraInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idProveedor?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    pedido?: PedidoUncheckedUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type BodegaUpsertWithoutDetalleCompraInput = {
    update: XOR<BodegaUpdateWithoutDetalleCompraInput, BodegaUncheckedUpdateWithoutDetalleCompraInput>
    create: XOR<BodegaCreateWithoutDetalleCompraInput, BodegaUncheckedCreateWithoutDetalleCompraInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutDetalleCompraInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutDetalleCompraInput, BodegaUncheckedUpdateWithoutDetalleCompraInput>
  }

  export type BodegaUpdateWithoutDetalleCompraInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUpdateManyWithoutBodegaDestinoNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
  }

  export type BodegaUncheckedUpdateWithoutDetalleCompraInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUncheckedUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUncheckedUpdateManyWithoutBodegasNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUncheckedUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUncheckedUpdateManyWithoutBodegaDestinoNestedInput
  }

  export type EstadoCreateWithoutPedidosInput = {
    estado: string
    Traslado?: TrasladoCreateNestedManyWithoutEstadoDestinoInput
  }

  export type EstadoUncheckedCreateWithoutPedidosInput = {
    id?: number
    estado: string
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutEstadoDestinoInput
  }

  export type EstadoCreateOrConnectWithoutPedidosInput = {
    where: EstadoWhereUniqueInput
    create: XOR<EstadoCreateWithoutPedidosInput, EstadoUncheckedCreateWithoutPedidosInput>
  }

  export type EncabezadoCompraCreateWithoutPedidoInput = {
    fechaCompra?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEncabezadoComprasInput
    proveedor: ProveedorCreateNestedOneWithoutEncabezadoCompraInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraUncheckedCreateWithoutPedidoInput = {
    id?: number
    fechaCompra?: Date | string
    idProveedor: number
    idUsuario: number
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutEncabezadoCompraInput
  }

  export type EncabezadoCompraCreateOrConnectWithoutPedidoInput = {
    where: EncabezadoCompraWhereUniqueInput
    create: XOR<EncabezadoCompraCreateWithoutPedidoInput, EncabezadoCompraUncheckedCreateWithoutPedidoInput>
  }

  export type EstadoUpsertWithoutPedidosInput = {
    update: XOR<EstadoUpdateWithoutPedidosInput, EstadoUncheckedUpdateWithoutPedidosInput>
    create: XOR<EstadoCreateWithoutPedidosInput, EstadoUncheckedCreateWithoutPedidosInput>
    where?: EstadoWhereInput
  }

  export type EstadoUpdateToOneWithWhereWithoutPedidosInput = {
    where?: EstadoWhereInput
    data: XOR<EstadoUpdateWithoutPedidosInput, EstadoUncheckedUpdateWithoutPedidosInput>
  }

  export type EstadoUpdateWithoutPedidosInput = {
    estado?: StringFieldUpdateOperationsInput | string
    Traslado?: TrasladoUpdateManyWithoutEstadoDestinoNestedInput
  }

  export type EstadoUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    Traslado?: TrasladoUncheckedUpdateManyWithoutEstadoDestinoNestedInput
  }

  export type EncabezadoCompraUpsertWithoutPedidoInput = {
    update: XOR<EncabezadoCompraUpdateWithoutPedidoInput, EncabezadoCompraUncheckedUpdateWithoutPedidoInput>
    create: XOR<EncabezadoCompraCreateWithoutPedidoInput, EncabezadoCompraUncheckedCreateWithoutPedidoInput>
    where?: EncabezadoCompraWhereInput
  }

  export type EncabezadoCompraUpdateToOneWithWhereWithoutPedidoInput = {
    where?: EncabezadoCompraWhereInput
    data: XOR<EncabezadoCompraUpdateWithoutPedidoInput, EncabezadoCompraUncheckedUpdateWithoutPedidoInput>
  }

  export type EncabezadoCompraUpdateWithoutPedidoInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput
    proveedor?: ProveedorUpdateOneRequiredWithoutEncabezadoCompraNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idProveedor?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type BodegaCreateWithoutTrasladoOrigenInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioCreateNestedManyWithoutBodegaInput
    inventario?: InventarioCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutBodegaInput
    Historial?: HistorialCreateNestedManyWithoutBodegaInput
    TrasladoDestino?: TrasladoCreateNestedManyWithoutBodegaDestinoInput
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
  }

  export type BodegaUncheckedCreateWithoutTrasladoOrigenInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioUncheckedCreateNestedManyWithoutBodegaInput
    inventario?: InventarioUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutBodegaInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegaInput
    TrasladoDestino?: TrasladoUncheckedCreateNestedManyWithoutBodegaDestinoInput
  }

  export type BodegaCreateOrConnectWithoutTrasladoOrigenInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutTrasladoOrigenInput, BodegaUncheckedCreateWithoutTrasladoOrigenInput>
  }

  export type BodegaCreateWithoutTrasladoDestinoInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioCreateNestedManyWithoutBodegaInput
    inventario?: InventarioCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutBodegaInput
    Historial?: HistorialCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoCreateNestedManyWithoutBodegaOrigenInput
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
  }

  export type BodegaUncheckedCreateWithoutTrasladoDestinoInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioUncheckedCreateNestedManyWithoutBodegaInput
    inventario?: InventarioUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutBodegaInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoUncheckedCreateNestedManyWithoutBodegaOrigenInput
  }

  export type BodegaCreateOrConnectWithoutTrasladoDestinoInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutTrasladoDestinoInput, BodegaUncheckedCreateWithoutTrasladoDestinoInput>
  }

  export type EstadoCreateWithoutTrasladoInput = {
    estado: string
    pedidos?: PedidoCreateNestedManyWithoutEstadoPedidoInput
  }

  export type EstadoUncheckedCreateWithoutTrasladoInput = {
    id?: number
    estado: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutEstadoPedidoInput
  }

  export type EstadoCreateOrConnectWithoutTrasladoInput = {
    where: EstadoWhereUniqueInput
    create: XOR<EstadoCreateWithoutTrasladoInput, EstadoUncheckedCreateWithoutTrasladoInput>
  }

  export type UsuarioCreateWithoutTrasladoInput = {
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioCreateNestedManyWithoutUsuarioActualizoInput
    bodega?: BodegaCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutTrasladoInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    idBodega?: number | null
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioRegistro?: InventarioUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioUncheckedCreateNestedManyWithoutUsuarioActualizoInput
  }

  export type UsuarioCreateOrConnectWithoutTrasladoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTrasladoInput, UsuarioUncheckedCreateWithoutTrasladoInput>
  }

  export type ProductoCreateWithoutTrasladoInput = {
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    categoria: CategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductoInput
    Historial?: HistorialCreateNestedManyWithoutProductoInput
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutTrasladoInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
    idSubCategoria: number
    foto?: FotoUncheckedCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductoInput
    Historial?: HistorialUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutTrasladoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutTrasladoInput, ProductoUncheckedCreateWithoutTrasladoInput>
  }

  export type BodegaUpsertWithoutTrasladoOrigenInput = {
    update: XOR<BodegaUpdateWithoutTrasladoOrigenInput, BodegaUncheckedUpdateWithoutTrasladoOrigenInput>
    create: XOR<BodegaCreateWithoutTrasladoOrigenInput, BodegaUncheckedCreateWithoutTrasladoOrigenInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutTrasladoOrigenInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutTrasladoOrigenInput, BodegaUncheckedUpdateWithoutTrasladoOrigenInput>
  }

  export type BodegaUpdateWithoutTrasladoOrigenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUpdateManyWithoutBodegaNestedInput
    TrasladoDestino?: TrasladoUpdateManyWithoutBodegaDestinoNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
  }

  export type BodegaUncheckedUpdateWithoutTrasladoOrigenInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUncheckedUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegaNestedInput
    TrasladoDestino?: TrasladoUncheckedUpdateManyWithoutBodegaDestinoNestedInput
  }

  export type BodegaUpsertWithoutTrasladoDestinoInput = {
    update: XOR<BodegaUpdateWithoutTrasladoDestinoInput, BodegaUncheckedUpdateWithoutTrasladoDestinoInput>
    create: XOR<BodegaCreateWithoutTrasladoDestinoInput, BodegaUncheckedCreateWithoutTrasladoDestinoInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutTrasladoDestinoInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutTrasladoDestinoInput, BodegaUncheckedUpdateWithoutTrasladoDestinoInput>
  }

  export type BodegaUpdateWithoutTrasladoDestinoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUpdateManyWithoutBodegaOrigenNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
  }

  export type BodegaUncheckedUpdateWithoutTrasladoDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUncheckedUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUncheckedUpdateManyWithoutBodegaOrigenNestedInput
  }

  export type EstadoUpsertWithoutTrasladoInput = {
    update: XOR<EstadoUpdateWithoutTrasladoInput, EstadoUncheckedUpdateWithoutTrasladoInput>
    create: XOR<EstadoCreateWithoutTrasladoInput, EstadoUncheckedCreateWithoutTrasladoInput>
    where?: EstadoWhereInput
  }

  export type EstadoUpdateToOneWithWhereWithoutTrasladoInput = {
    where?: EstadoWhereInput
    data: XOR<EstadoUpdateWithoutTrasladoInput, EstadoUncheckedUpdateWithoutTrasladoInput>
  }

  export type EstadoUpdateWithoutTrasladoInput = {
    estado?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutEstadoPedidoNestedInput
  }

  export type EstadoUncheckedUpdateWithoutTrasladoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutEstadoPedidoNestedInput
  }

  export type UsuarioUpsertWithoutTrasladoInput = {
    update: XOR<UsuarioUpdateWithoutTrasladoInput, UsuarioUncheckedUpdateWithoutTrasladoInput>
    create: XOR<UsuarioCreateWithoutTrasladoInput, UsuarioUncheckedCreateWithoutTrasladoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutTrasladoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutTrasladoInput, UsuarioUncheckedUpdateWithoutTrasladoInput>
  }

  export type UsuarioUpdateWithoutTrasladoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUpdateManyWithoutUsuarioActualizoNestedInput
    bodega?: BodegaUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTrasladoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idBodega?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUncheckedUpdateManyWithoutUsuarioActualizoNestedInput
  }

  export type ProductoUpsertWithoutTrasladoInput = {
    update: XOR<ProductoUpdateWithoutTrasladoInput, ProductoUncheckedUpdateWithoutTrasladoInput>
    create: XOR<ProductoCreateWithoutTrasladoInput, ProductoUncheckedCreateWithoutTrasladoInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutTrasladoInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutTrasladoInput, ProductoUncheckedUpdateWithoutTrasladoInput>
  }

  export type ProductoUpdateWithoutTrasladoInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUpdateManyWithoutProductoNestedInput
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutTrasladoInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    foto?: FotoUncheckedUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoCreateWithoutHistorialInput = {
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    categoria: CategoriaCreateNestedOneWithoutProductoInput
    foto?: FotoCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoCreateNestedManyWithoutProductoInput
    subCategorias: SubCategoriaCreateNestedOneWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutHistorialInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
    idSubCategoria: number
    foto?: FotoUncheckedCreateNestedManyWithoutProductoInput
    bodegaProductos?: InventarioUncheckedCreateNestedManyWithoutProductoInput
    detalleCompras?: DetalleCompraUncheckedCreateNestedManyWithoutProductoInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutHistorialInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutHistorialInput, ProductoUncheckedCreateWithoutHistorialInput>
  }

  export type BodegaCreateWithoutHistorialInput = {
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioCreateNestedManyWithoutBodegaInput
    inventario?: InventarioCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoCreateNestedManyWithoutBodegaDestinoInput
    ubicacion: UbicacionCreateNestedOneWithoutBodegaInput
  }

  export type BodegaUncheckedCreateWithoutHistorialInput = {
    id?: number
    nombre: string
    idUbicacion: number
    tamanno: number
    capacidad: number
    seguridad: boolean
    usuario?: UsuarioUncheckedCreateNestedManyWithoutBodegaInput
    inventario?: InventarioUncheckedCreateNestedManyWithoutBodegasInput
    detalleCompra?: DetalleCompraUncheckedCreateNestedManyWithoutBodegaInput
    TrasladoOrigen?: TrasladoUncheckedCreateNestedManyWithoutBodegaOrigenInput
    TrasladoDestino?: TrasladoUncheckedCreateNestedManyWithoutBodegaDestinoInput
  }

  export type BodegaCreateOrConnectWithoutHistorialInput = {
    where: BodegaWhereUniqueInput
    create: XOR<BodegaCreateWithoutHistorialInput, BodegaUncheckedCreateWithoutHistorialInput>
  }

  export type UsuarioCreateWithoutHistorialInput = {
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoCreateNestedManyWithoutUsuarioInput
    invUsuarioRegistro?: InventarioCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioCreateNestedManyWithoutUsuarioActualizoInput
    bodega?: BodegaCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutHistorialInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    idBodega?: number | null
    estado?: boolean
    encabezadoCompras?: EncabezadoCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Traslado?: TrasladoUncheckedCreateNestedManyWithoutUsuarioInput
    invUsuarioRegistro?: InventarioUncheckedCreateNestedManyWithoutUsuarioRegistroInput
    invUsuarioActualizo?: InventarioUncheckedCreateNestedManyWithoutUsuarioActualizoInput
  }

  export type UsuarioCreateOrConnectWithoutHistorialInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutHistorialInput, UsuarioUncheckedCreateWithoutHistorialInput>
  }

  export type ProductoUpsertWithoutHistorialInput = {
    update: XOR<ProductoUpdateWithoutHistorialInput, ProductoUncheckedUpdateWithoutHistorialInput>
    create: XOR<ProductoCreateWithoutHistorialInput, ProductoUncheckedCreateWithoutHistorialInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutHistorialInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutHistorialInput, ProductoUncheckedUpdateWithoutHistorialInput>
  }

  export type ProductoUpdateWithoutHistorialInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUpdateManyWithoutProductoNestedInput
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutHistorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    foto?: FotoUncheckedUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type BodegaUpsertWithoutHistorialInput = {
    update: XOR<BodegaUpdateWithoutHistorialInput, BodegaUncheckedUpdateWithoutHistorialInput>
    create: XOR<BodegaCreateWithoutHistorialInput, BodegaUncheckedCreateWithoutHistorialInput>
    where?: BodegaWhereInput
  }

  export type BodegaUpdateToOneWithWhereWithoutHistorialInput = {
    where?: BodegaWhereInput
    data: XOR<BodegaUpdateWithoutHistorialInput, BodegaUncheckedUpdateWithoutHistorialInput>
  }

  export type BodegaUpdateWithoutHistorialInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUpdateManyWithoutBodegaDestinoNestedInput
    ubicacion?: UbicacionUpdateOneRequiredWithoutBodegaNestedInput
  }

  export type BodegaUncheckedUpdateWithoutHistorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    idUbicacion?: IntFieldUpdateOperationsInput | number
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUncheckedUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUncheckedUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUncheckedUpdateManyWithoutBodegaDestinoNestedInput
  }

  export type UsuarioUpsertWithoutHistorialInput = {
    update: XOR<UsuarioUpdateWithoutHistorialInput, UsuarioUncheckedUpdateWithoutHistorialInput>
    create: XOR<UsuarioCreateWithoutHistorialInput, UsuarioUncheckedCreateWithoutHistorialInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutHistorialInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutHistorialInput, UsuarioUncheckedUpdateWithoutHistorialInput>
  }

  export type UsuarioUpdateWithoutHistorialInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUpdateManyWithoutUsuarioNestedInput
    invUsuarioRegistro?: InventarioUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUpdateManyWithoutUsuarioActualizoNestedInput
    bodega?: BodegaUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutHistorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    idBodega?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutUsuarioNestedInput
    invUsuarioRegistro?: InventarioUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUncheckedUpdateManyWithoutUsuarioActualizoNestedInput
  }

  export type EncabezadoCompraCreateManyUsuarioInput = {
    id?: number
    fechaCompra?: Date | string
    idProveedor: number
  }

  export type TrasladoCreateManyUsuarioInput = {
    id?: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type HistorialCreateManyUsuarioRegistroInput = {
    id?: number
    idBodega: number
    idProducto: number
    justificacion: string
    fechaAjuste?: Date | string
  }

  export type InventarioCreateManyUsuarioRegistroInput = {
    idBodega: number
    idProducto: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type InventarioCreateManyUsuarioActualizoInput = {
    idBodega: number
    idProducto: number
    idUsuarioRegistro: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type EncabezadoCompraUpdateWithoutUsuarioInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    proveedor?: ProveedorUpdateOneRequiredWithoutEncabezadoCompraNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutEncabezadoCompraNestedInput
    pedido?: PedidoUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idProveedor?: IntFieldUpdateOperationsInput | number
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutEncabezadoCompraNestedInput
    pedido?: PedidoUncheckedUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idProveedor?: IntFieldUpdateOperationsInput | number
  }

  export type TrasladoUpdateWithoutUsuarioInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegaOrigen?: BodegaUpdateOneRequiredWithoutTrasladoOrigenNestedInput
    bodegaDestino?: BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    estadoDestino?: EstadoUpdateOneRequiredWithoutTrasladoNestedInput
    producto?: ProductoUpdateOneRequiredWithoutTrasladoNestedInput
  }

  export type TrasladoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialUpdateWithoutUsuarioRegistroInput = {
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: ProductoUpdateOneRequiredWithoutHistorialNestedInput
    bodega?: BodegaUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialUncheckedUpdateWithoutUsuarioRegistroInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialUncheckedUpdateManyWithoutUsuarioRegistroInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUpdateWithoutUsuarioRegistroInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegas?: BodegaUpdateOneRequiredWithoutInventarioNestedInput
    producto?: ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput
    usuarioActualizo?: UsuarioUpdateOneRequiredWithoutInvUsuarioActualizoNestedInput
  }

  export type InventarioUncheckedUpdateWithoutUsuarioRegistroInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuarioActualizo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUncheckedUpdateManyWithoutUsuarioRegistroInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuarioActualizo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUpdateWithoutUsuarioActualizoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegas?: BodegaUpdateOneRequiredWithoutInventarioNestedInput
    producto?: ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput
    usuarioRegistro?: UsuarioUpdateOneRequiredWithoutInvUsuarioRegistroNestedInput
  }

  export type InventarioUncheckedUpdateWithoutUsuarioActualizoInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUncheckedUpdateManyWithoutUsuarioActualizoInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateManyEstadoPedidoInput = {
    idEncabezadoCompra: number
    observaciones?: string | null
    fechaPedido?: Date | string
  }

  export type TrasladoCreateManyEstadoDestinoInput = {
    id?: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idUsuario?: number | null
    idProducto: number
    cantidad: number
    fechaRegistro?: Date | string
  }

  export type PedidoUpdateWithoutEstadoPedidoInput = {
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    encabezadoCompra?: EncabezadoCompraUpdateOneRequiredWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutEstadoPedidoInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyWithoutEstadoPedidoInput = {
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUpdateWithoutEstadoDestinoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegaOrigen?: BodegaUpdateOneRequiredWithoutTrasladoOrigenNestedInput
    bodegaDestino?: BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    usuario?: UsuarioUpdateOneWithoutTrasladoNestedInput
    producto?: ProductoUpdateOneRequiredWithoutTrasladoNestedInput
  }

  export type TrasladoUncheckedUpdateWithoutEstadoDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUncheckedUpdateManyWithoutEstadoDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoCreateManyCategoriaInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idSubCategoria: number
  }

  export type SubCategoriaUpdateWithoutCategoriasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUpdateManyWithoutSubCategoriasNestedInput
  }

  export type SubCategoriaUncheckedUpdateWithoutCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUncheckedUpdateManyWithoutSubCategoriasNestedInput
  }

  export type SubCategoriaUncheckedUpdateManyWithoutCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoUpdateWithoutCategoriaInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    foto?: FotoUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUpdateManyWithoutProductoNestedInput
    subCategorias?: SubCategoriaUpdateOneRequiredWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idSubCategoria?: IntFieldUpdateOperationsInput | number
    foto?: FotoUncheckedUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idSubCategoria?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoCreateManySubCategoriasInput = {
    id?: number
    codigoProducto?: string | null
    nombre: string
    descripcion: string
    stock: number
    precio: Decimal | DecimalJsLike | number | string
    estadoProducto: boolean
    idCategoria: number
  }

  export type ProductoUpdateWithoutSubCategoriasInput = {
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductoNestedInput
    foto?: FotoUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutSubCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    foto?: FotoUncheckedUpdateManyWithoutProductoNestedInput
    bodegaProductos?: InventarioUncheckedUpdateManyWithoutProductoNestedInput
    detalleCompras?: DetalleCompraUncheckedUpdateManyWithoutProductoNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutProductoNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateManyWithoutSubCategoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoProducto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoProducto?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
  }

  export type CategoriaUpdateWithoutSubCategoriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutSubCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateManyWithoutSubCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type FotoCreateManyProductoInput = {
    id?: number
    foto: Buffer
  }

  export type InventarioCreateManyProductoInput = {
    idBodega: number
    idUsuarioRegistro: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type DetalleCompraCreateManyProductoInput = {
    id?: number
    idEncabezadoCompra: number
    idBodega: number
    cantidad: number
  }

  export type HistorialCreateManyProductoInput = {
    id?: number
    idBodega: number
    idUsuarioRegistro: number
    justificacion: string
    fechaAjuste?: Date | string
  }

  export type TrasladoCreateManyProductoInput = {
    id?: number
    idBodegaOrigen: number
    idBodegaDestino: number
    idUsuario?: number | null
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type FotoUpdateWithoutProductoInput = {
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type FotoUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type FotoUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type InventarioUpdateWithoutProductoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegas?: BodegaUpdateOneRequiredWithoutInventarioNestedInput
    usuarioRegistro?: UsuarioUpdateOneRequiredWithoutInvUsuarioRegistroNestedInput
    usuarioActualizo?: UsuarioUpdateOneRequiredWithoutInvUsuarioActualizoNestedInput
  }

  export type InventarioUncheckedUpdateWithoutProductoInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idUsuarioActualizo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUncheckedUpdateManyWithoutProductoInput = {
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idUsuarioActualizo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleCompraUpdateWithoutProductoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    encabezadoCompra?: EncabezadoCompraUpdateOneRequiredWithoutDetalleCompraNestedInput
    bodega?: BodegaUpdateOneRequiredWithoutDetalleCompraNestedInput
  }

  export type DetalleCompraUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type HistorialUpdateWithoutProductoInput = {
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    bodega?: BodegaUpdateOneRequiredWithoutHistorialNestedInput
    usuarioRegistro?: UsuarioUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUpdateWithoutProductoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegaOrigen?: BodegaUpdateOneRequiredWithoutTrasladoOrigenNestedInput
    bodegaDestino?: BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    estadoDestino?: EstadoUpdateOneRequiredWithoutTrasladoNestedInput
    usuario?: UsuarioUpdateOneWithoutTrasladoNestedInput
  }

  export type TrasladoUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProveedorCreateManyUbicacionInput = {
    id?: number
    identificacion: number
    nombreProveedor: string
    correoElectronico: string
    telefono: number
  }

  export type BodegaCreateManyUbicacionInput = {
    id?: number
    nombre: string
    tamanno: number
    capacidad: number
    seguridad: boolean
  }

  export type ProveedorUpdateWithoutUbicacionInput = {
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    encabezadoCompra?: EncabezadoCompraUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateWithoutUbicacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    encabezadoCompra?: EncabezadoCompraUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateManyWithoutUbicacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    identificacion?: IntFieldUpdateOperationsInput | number
    nombreProveedor?: StringFieldUpdateOperationsInput | string
    correoElectronico?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
  }

  export type BodegaUpdateWithoutUbicacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUpdateManyWithoutBodegaDestinoNestedInput
  }

  export type BodegaUncheckedUpdateWithoutUbicacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUncheckedUpdateManyWithoutBodegaNestedInput
    inventario?: InventarioUncheckedUpdateManyWithoutBodegasNestedInput
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutBodegaNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutBodegaNestedInput
    TrasladoOrigen?: TrasladoUncheckedUpdateManyWithoutBodegaOrigenNestedInput
    TrasladoDestino?: TrasladoUncheckedUpdateManyWithoutBodegaDestinoNestedInput
  }

  export type BodegaUncheckedUpdateManyWithoutUbicacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tamanno?: FloatFieldUpdateOperationsInput | number
    capacidad?: FloatFieldUpdateOperationsInput | number
    seguridad?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioCreateManyBodegaInput = {
    id?: number
    nombre: string
    apellidos: string
    correo: string
    contrasenna: string
    fechaRegistro?: Date | string
    rol?: $Enums.Rol
    estado?: boolean
  }

  export type InventarioCreateManyBodegasInput = {
    idProducto: number
    idUsuarioRegistro: number
    idUsuarioActualizo: number
    cantidad: number
    cantidadMinima: number
    cantidadMaxima: number
    fechaRegistro?: Date | string
  }

  export type DetalleCompraCreateManyBodegaInput = {
    id?: number
    idEncabezadoCompra: number
    idProducto: number
    cantidad: number
  }

  export type HistorialCreateManyBodegaInput = {
    id?: number
    idUsuarioRegistro: number
    idProducto: number
    justificacion: string
    fechaAjuste?: Date | string
  }

  export type TrasladoCreateManyBodegaOrigenInput = {
    id?: number
    idBodegaDestino: number
    idUsuario?: number | null
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type TrasladoCreateManyBodegaDestinoInput = {
    id?: number
    idBodegaOrigen: number
    idUsuario?: number | null
    idProducto: number
    cantidad: number
    idEstado: number
    fechaRegistro?: Date | string
  }

  export type UsuarioUpdateWithoutBodegaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUpdateManyWithoutUsuarioActualizoNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutBodegaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
    encabezadoCompras?: EncabezadoCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Traslado?: TrasladoUncheckedUpdateManyWithoutUsuarioNestedInput
    Historial?: HistorialUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioRegistro?: InventarioUncheckedUpdateManyWithoutUsuarioRegistroNestedInput
    invUsuarioActualizo?: InventarioUncheckedUpdateManyWithoutUsuarioActualizoNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutBodegaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasenna?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventarioUpdateWithoutBodegasInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: ProductoUpdateOneRequiredWithoutBodegaProductosNestedInput
    usuarioRegistro?: UsuarioUpdateOneRequiredWithoutInvUsuarioRegistroNestedInput
    usuarioActualizo?: UsuarioUpdateOneRequiredWithoutInvUsuarioActualizoNestedInput
  }

  export type InventarioUncheckedUpdateWithoutBodegasInput = {
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idUsuarioActualizo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUncheckedUpdateManyWithoutBodegasInput = {
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idUsuarioActualizo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    cantidadMaxima?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleCompraUpdateWithoutBodegaInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutDetalleComprasNestedInput
    encabezadoCompra?: EncabezadoCompraUpdateOneRequiredWithoutDetalleCompraNestedInput
  }

  export type DetalleCompraUncheckedUpdateWithoutBodegaInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUncheckedUpdateManyWithoutBodegaInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEncabezadoCompra?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type HistorialUpdateWithoutBodegaInput = {
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: ProductoUpdateOneRequiredWithoutHistorialNestedInput
    usuarioRegistro?: UsuarioUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialUncheckedUpdateWithoutBodegaInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialUncheckedUpdateManyWithoutBodegaInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUsuarioRegistro?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    justificacion?: StringFieldUpdateOperationsInput | string
    fechaAjuste?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUpdateWithoutBodegaOrigenInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegaDestino?: BodegaUpdateOneRequiredWithoutTrasladoDestinoNestedInput
    estadoDestino?: EstadoUpdateOneRequiredWithoutTrasladoNestedInput
    usuario?: UsuarioUpdateOneWithoutTrasladoNestedInput
    producto?: ProductoUpdateOneRequiredWithoutTrasladoNestedInput
  }

  export type TrasladoUncheckedUpdateWithoutBodegaOrigenInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUncheckedUpdateManyWithoutBodegaOrigenInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaDestino?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUpdateWithoutBodegaDestinoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    bodegaOrigen?: BodegaUpdateOneRequiredWithoutTrasladoOrigenNestedInput
    estadoDestino?: EstadoUpdateOneRequiredWithoutTrasladoNestedInput
    usuario?: UsuarioUpdateOneWithoutTrasladoNestedInput
    producto?: ProductoUpdateOneRequiredWithoutTrasladoNestedInput
  }

  export type TrasladoUncheckedUpdateWithoutBodegaDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrasladoUncheckedUpdateManyWithoutBodegaDestinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBodegaOrigen?: IntFieldUpdateOperationsInput | number
    idUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idEstado?: IntFieldUpdateOperationsInput | number
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncabezadoCompraCreateManyProveedorInput = {
    id?: number
    fechaCompra?: Date | string
    idUsuario: number
  }

  export type EncabezadoCompraUpdateWithoutProveedorInput = {
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEncabezadoComprasNestedInput
    detalleCompra?: DetalleCompraUpdateManyWithoutEncabezadoCompraNestedInput
    pedido?: PedidoUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuario?: IntFieldUpdateOperationsInput | number
    detalleCompra?: DetalleCompraUncheckedUpdateManyWithoutEncabezadoCompraNestedInput
    pedido?: PedidoUncheckedUpdateManyWithoutEncabezadoCompraNestedInput
  }

  export type EncabezadoCompraUncheckedUpdateManyWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraCreateManyEncabezadoCompraInput = {
    id?: number
    idProducto: number
    idBodega: number
    cantidad: number
  }

  export type PedidoCreateManyEncabezadoCompraInput = {
    idEstado: number
    observaciones?: string | null
    fechaPedido?: Date | string
  }

  export type DetalleCompraUpdateWithoutEncabezadoCompraInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutDetalleComprasNestedInput
    bodega?: BodegaUpdateOneRequiredWithoutDetalleCompraNestedInput
  }

  export type DetalleCompraUncheckedUpdateWithoutEncabezadoCompraInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleCompraUncheckedUpdateManyWithoutEncabezadoCompraInput = {
    id?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idBodega?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoUpdateWithoutEncabezadoCompraInput = {
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
    estadoPedido?: EstadoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutEncabezadoCompraInput = {
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyWithoutEncabezadoCompraInput = {
    idEstado?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPedido?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoCountOutputTypeDefaultArgs instead
     */
    export type EstadoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaCountOutputTypeDefaultArgs instead
     */
    export type CategoriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoriaCountOutputTypeDefaultArgs instead
     */
    export type SubCategoriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductoCountOutputTypeDefaultArgs instead
     */
    export type ProductoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UbicacionCountOutputTypeDefaultArgs instead
     */
    export type UbicacionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UbicacionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BodegaCountOutputTypeDefaultArgs instead
     */
    export type BodegaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BodegaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProveedorCountOutputTypeDefaultArgs instead
     */
    export type ProveedorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProveedorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncabezadoCompraCountOutputTypeDefaultArgs instead
     */
    export type EncabezadoCompraCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncabezadoCompraCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoDefaultArgs instead
     */
    export type EstadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaDefaultArgs instead
     */
    export type CategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoriaDefaultArgs instead
     */
    export type SubCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductoDefaultArgs instead
     */
    export type ProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FotoDefaultArgs instead
     */
    export type FotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UbicacionDefaultArgs instead
     */
    export type UbicacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UbicacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BodegaDefaultArgs instead
     */
    export type BodegaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BodegaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventarioDefaultArgs instead
     */
    export type InventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProveedorDefaultArgs instead
     */
    export type ProveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProveedorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncabezadoCompraDefaultArgs instead
     */
    export type EncabezadoCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncabezadoCompraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetalleCompraDefaultArgs instead
     */
    export type DetalleCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetalleCompraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoDefaultArgs instead
     */
    export type PedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrasladoDefaultArgs instead
     */
    export type TrasladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrasladoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistorialDefaultArgs instead
     */
    export type HistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistorialDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}